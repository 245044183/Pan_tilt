
Pantilt.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000050  00800100  00003970  00003a04  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003970  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000e9  00800150  00800150  00003a54  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003a54  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003ab0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000540  00000000  00000000  00003af0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006a59  00000000  00000000  00004030  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001920  00000000  00000000  0000aa89  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000383b  00000000  00000000  0000c3a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000108c  00000000  00000000  0000fbe4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001e8d  00000000  00000000  00010c70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006105  00000000  00000000  00012afd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005d8  00000000  00000000  00018c02  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__ctors_end>
       4:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
       8:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
       c:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      10:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      14:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      18:	0c 94 4e 0a 	jmp	0x149c	; 0x149c <__vector_6>
      1c:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      20:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      24:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      28:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      2c:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      30:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      34:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      38:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      3c:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      40:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      44:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      48:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      4c:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      50:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      54:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      58:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      5c:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      60:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      64:	0c 94 90 00 	jmp	0x120	; 0x120 <__bad_interrupt>
      68:	0a 14       	cp	r0, r10
      6a:	0a 14       	cp	r0, r10
      6c:	0a 14       	cp	r0, r10
      6e:	3a 14       	cp	r3, r10
      70:	42 14       	cp	r4, r2
      72:	52 14       	cp	r5, r2
      74:	0a 14       	cp	r0, r10
      76:	0a 14       	cp	r0, r10
      78:	3a 14       	cp	r3, r10
      7a:	42 14       	cp	r4, r2
      7c:	03 6e       	ori	r16, 0xE3	; 227
      7e:	db 36       	cpi	r29, 0x6B	; 107
      80:	3d 9a       	sbi	0x07, 5	; 7
      82:	99 99       	sbic	0x13, 1	; 19
      84:	99 3d       	cpi	r25, 0xD9	; 217
      86:	ab aa       	std	Y+51, r10	; 0x33
      88:	aa 2a       	or	r10, r26
      8a:	3e 00       	.word	0x003e	; ????
      8c:	00 00       	nop
      8e:	80 3f       	cpi	r24, 0xF0	; 240
      90:	08 4a       	sbci	r16, 0xA8	; 168
      92:	d7 3b       	cpi	r29, 0xB7	; 183
      94:	3b ce       	rjmp	.-906    	; 0xfffffd0c <__eeprom_end+0xff7efd0c>
      96:	01 6e       	ori	r16, 0xE1	; 225
      98:	84 bc       	out	0x24, r8	; 36
      9a:	bf fd       	.word	0xfdbf	; ????
      9c:	c1 2f       	mov	r28, r17
      9e:	3d 6c       	ori	r19, 0xCD	; 205
      a0:	74 31       	cpi	r23, 0x14	; 20
      a2:	9a bd       	out	0x2a, r25	; 42
      a4:	56 83       	std	Z+6, r21	; 0x06
      a6:	3d da       	rcall	.-2950   	; 0xfffff522 <__eeprom_end+0xff7ef522>
      a8:	3d 00       	.word	0x003d	; ????
      aa:	c7 7f       	andi	r28, 0xF7	; 247
      ac:	11 be       	out	0x31, r1	; 49
      ae:	d9 e4       	ldi	r29, 0x49	; 73
      b0:	bb 4c       	sbci	r27, 0xCB	; 203
      b2:	3e 91       	ld	r19, -X
      b4:	6b aa       	std	Y+51, r6	; 0x33
      b6:	aa be       	out	0x3a, r10	; 58
      b8:	00 00       	nop
      ba:	00 80       	ld	r0, Z
      bc:	3f 07       	cpc	r19, r31
      be:	2c 7a       	andi	r18, 0xAC	; 172
      c0:	a5 ba       	out	0x15, r10	; 21
      c2:	6c c5       	rjmp	.+2776   	; 0xb9c <q2Angle+0x1c4>
      c4:	90 da       	rcall	.-2784   	; 0xfffff5e6 <__eeprom_end+0xff7ef5e6>
      c6:	3b 93       	.word	0x933b	; ????
      c8:	65 fc       	sbrc	r6, 5
      ca:	8b bc       	out	0x2b, r8	; 43
      cc:	53 f8       	bld	r5, 3
      ce:	10 fd       	sbrc	r17, 0
      d0:	3c 56       	subi	r19, 0x6C	; 108
      d2:	92 83       	std	Z+2, r25	; 0x02
      d4:	4d bd       	out	0x2d, r20	; 45
      d6:	87 9d       	mul	r24, r7
      d8:	3a b6       	in	r3, 0x3a	; 58
      da:	3d cb       	rjmp	.-2438   	; 0xfffff756 <__eeprom_end+0xff7ef756>
      dc:	c9 bf       	out	0x39, r28	; 57
      de:	5b be       	out	0x3b, r5	; 59
      e0:	73 da       	rcall	.-2842   	; 0xfffff5c8 <__eeprom_end+0xff7ef5c8>
      e2:	0f c9       	rjmp	.-3554   	; 0xfffff302 <__eeprom_end+0xff7ef302>
      e4:	3f 00       	.word	0x003f	; ????

000000e6 <__ctors_end>:
      e6:	11 24       	eor	r1, r1
      e8:	1f be       	out	0x3f, r1	; 63
      ea:	cf ef       	ldi	r28, 0xFF	; 255
      ec:	d8 e0       	ldi	r29, 0x08	; 8
      ee:	de bf       	out	0x3e, r29	; 62
      f0:	cd bf       	out	0x3d, r28	; 61

000000f2 <__do_copy_data>:
      f2:	11 e0       	ldi	r17, 0x01	; 1
      f4:	a0 e0       	ldi	r26, 0x00	; 0
      f6:	b1 e0       	ldi	r27, 0x01	; 1
      f8:	e0 e7       	ldi	r30, 0x70	; 112
      fa:	f9 e3       	ldi	r31, 0x39	; 57
      fc:	02 c0       	rjmp	.+4      	; 0x102 <__do_copy_data+0x10>
      fe:	05 90       	lpm	r0, Z+
     100:	0d 92       	st	X+, r0
     102:	a0 35       	cpi	r26, 0x50	; 80
     104:	b1 07       	cpc	r27, r17
     106:	d9 f7       	brne	.-10     	; 0xfe <__do_copy_data+0xc>

00000108 <__do_clear_bss>:
     108:	22 e0       	ldi	r18, 0x02	; 2
     10a:	a0 e5       	ldi	r26, 0x50	; 80
     10c:	b1 e0       	ldi	r27, 0x01	; 1
     10e:	01 c0       	rjmp	.+2      	; 0x112 <.do_clear_bss_start>

00000110 <.do_clear_bss_loop>:
     110:	1d 92       	st	X+, r1

00000112 <.do_clear_bss_start>:
     112:	a9 33       	cpi	r26, 0x39	; 57
     114:	b2 07       	cpc	r27, r18
     116:	e1 f7       	brne	.-8      	; 0x110 <.do_clear_bss_loop>
     118:	0e 94 92 00 	call	0x124	; 0x124 <main>
     11c:	0c 94 b6 1c 	jmp	0x396c	; 0x396c <_exit>

00000120 <__bad_interrupt>:
     120:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000124 <main>:
char MyString[10];
/*-----------------------------------------------------*/
int main(void)
{
	/* Replace with your application code */
	UART_init(BAUD_PRESCALER);
     124:	87 e6       	ldi	r24, 0x67	; 103
     126:	90 e0       	ldi	r25, 0x00	; 0
     128:	0e 94 1d 15 	call	0x2a3a	; 0x2a3a <UART_init>
	I2C_Init();
     12c:	0e 94 7f 14 	call	0x28fe	; 0x28fe <I2C_Init>
	MPU_Init();
     130:	0e 94 20 08 	call	0x1040	; 0x1040 <MPU_Init>
		MahonyAHRSupdateIMU(GyroData[0],GyroData[1],GyroData[2],AccData[0],AccData[1],AccData[2]);
		q2Angle(Angle);
		sprintf(MyString,"Angle x:%.3f\n", Angle[0]);
		UART_putstring(MyString);
		*/
		MytaskCreate();
     134:	0e 94 43 01 	call	0x286	; 0x286 <MytaskCreate>
		vTaskStartScheduler();
     138:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <vTaskStartScheduler>
     13c:	fb cf       	rjmp	.-10     	; 0x134 <main+0x10>

0000013e <vMahonyTaskFunction>:
extern float GyroData[3];
extern float Angle[3];
extern char MyString[10];

void vMahonyTaskFunction( void *pvParameters )
{
     13e:	cf 93       	push	r28
     140:	df 93       	push	r29
     142:	00 d0       	rcall	.+0      	; 0x144 <vMahonyTaskFunction+0x6>
     144:	cd b7       	in	r28, 0x3d	; 61
     146:	de b7       	in	r29, 0x3e	; 62
	for( ;; )
	{
		TickType_t xLastWakeTimeMahony;
		const TickType_t xPeriodFrequencyMahony = 10;// 15ms per tick  15ms*50 = 150

		xLastWakeTimeMahony = xTaskGetTickCount();
     148:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <xTaskGetTickCount>
     14c:	9a 83       	std	Y+2, r25	; 0x02
     14e:	89 83       	std	Y+1, r24	; 0x01

		for( ;; )
		{
			vTaskDelayUntil( &xLastWakeTimeMahony, xPeriodFrequencyMahony );
			MahonyAHRSupdateIMU(GyroData[0],GyroData[1],GyroData[2],AccData[0],AccData[1],AccData[2]);
     150:	0f 2e       	mov	r0, r31
     152:	f6 e1       	ldi	r31, 0x16	; 22
     154:	8f 2e       	mov	r8, r31
     156:	f1 e0       	ldi	r31, 0x01	; 1
     158:	9f 2e       	mov	r9, r31
     15a:	f0 2d       	mov	r31, r0
     15c:	0f 2e       	mov	r0, r31
     15e:	fa e0       	ldi	r31, 0x0A	; 10
     160:	4f 2e       	mov	r4, r31
     162:	f1 e0       	ldi	r31, 0x01	; 1
     164:	5f 2e       	mov	r5, r31
     166:	f0 2d       	mov	r31, r0
			q2Angle(Angle);
			sprintf(MyString,"Angle x:%.3f\n", Angle[0]);
     168:	0f 2e       	mov	r0, r31
     16a:	f2 e2       	ldi	r31, 0x22	; 34
     16c:	2f 2e       	mov	r2, r31
     16e:	f1 e0       	ldi	r31, 0x01	; 1
     170:	3f 2e       	mov	r3, r31
     172:	f0 2d       	mov	r31, r0
     174:	0f 2e       	mov	r0, r31
     176:	f3 e0       	ldi	r31, 0x03	; 3
     178:	6f 2e       	mov	r6, r31
     17a:	f2 e0       	ldi	r31, 0x02	; 2
     17c:	7f 2e       	mov	r7, r31
     17e:	f0 2d       	mov	r31, r0

		xLastWakeTimeMahony = xTaskGetTickCount();

		for( ;; )
		{
			vTaskDelayUntil( &xLastWakeTimeMahony, xPeriodFrequencyMahony );
     180:	6a e0       	ldi	r22, 0x0A	; 10
     182:	70 e0       	ldi	r23, 0x00	; 0
     184:	ce 01       	movw	r24, r28
     186:	01 96       	adiw	r24, 0x01	; 1
     188:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <vTaskDelayUntil>
			MahonyAHRSupdateIMU(GyroData[0],GyroData[1],GyroData[2],AccData[0],AccData[1],AccData[2]);
     18c:	d4 01       	movw	r26, r8
     18e:	ad 90       	ld	r10, X+
     190:	bd 90       	ld	r11, X+
     192:	cd 90       	ld	r12, X+
     194:	dc 90       	ld	r13, X
     196:	13 97       	sbiw	r26, 0x03	; 3
     198:	f2 01       	movw	r30, r4
     19a:	e0 84       	ldd	r14, Z+8	; 0x08
     19c:	f1 84       	ldd	r15, Z+9	; 0x09
     19e:	02 85       	ldd	r16, Z+10	; 0x0a
     1a0:	13 85       	ldd	r17, Z+11	; 0x0b
     1a2:	24 81       	ldd	r18, Z+4	; 0x04
     1a4:	35 81       	ldd	r19, Z+5	; 0x05
     1a6:	46 81       	ldd	r20, Z+6	; 0x06
     1a8:	57 81       	ldd	r21, Z+7	; 0x07
     1aa:	60 81       	ld	r22, Z
     1ac:	71 81       	ldd	r23, Z+1	; 0x01
     1ae:	82 81       	ldd	r24, Z+2	; 0x02
     1b0:	93 81       	ldd	r25, Z+3	; 0x03
     1b2:	1b 96       	adiw	r26, 0x0b	; 11
     1b4:	ec 91       	ld	r30, X
     1b6:	1b 97       	sbiw	r26, 0x0b	; 11
     1b8:	ef 93       	push	r30
     1ba:	1a 96       	adiw	r26, 0x0a	; 10
     1bc:	ec 91       	ld	r30, X
     1be:	1a 97       	sbiw	r26, 0x0a	; 10
     1c0:	ef 93       	push	r30
     1c2:	19 96       	adiw	r26, 0x09	; 9
     1c4:	ec 91       	ld	r30, X
     1c6:	19 97       	sbiw	r26, 0x09	; 9
     1c8:	ef 93       	push	r30
     1ca:	18 96       	adiw	r26, 0x08	; 8
     1cc:	ec 91       	ld	r30, X
     1ce:	18 97       	sbiw	r26, 0x08	; 8
     1d0:	ef 93       	push	r30
     1d2:	17 96       	adiw	r26, 0x07	; 7
     1d4:	ec 91       	ld	r30, X
     1d6:	17 97       	sbiw	r26, 0x07	; 7
     1d8:	ef 93       	push	r30
     1da:	16 96       	adiw	r26, 0x06	; 6
     1dc:	ec 91       	ld	r30, X
     1de:	16 97       	sbiw	r26, 0x06	; 6
     1e0:	ef 93       	push	r30
     1e2:	15 96       	adiw	r26, 0x05	; 5
     1e4:	ec 91       	ld	r30, X
     1e6:	15 97       	sbiw	r26, 0x05	; 5
     1e8:	ef 93       	push	r30
     1ea:	14 96       	adiw	r26, 0x04	; 4
     1ec:	ec 91       	ld	r30, X
     1ee:	ef 93       	push	r30
     1f0:	0e 94 a8 01 	call	0x350	; 0x350 <MahonyAHRSupdateIMU>
			q2Angle(Angle);
     1f4:	8d e0       	ldi	r24, 0x0D	; 13
     1f6:	92 e0       	ldi	r25, 0x02	; 2
     1f8:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <q2Angle>
			sprintf(MyString,"Angle x:%.3f\n", Angle[0]);
     1fc:	ed e0       	ldi	r30, 0x0D	; 13
     1fe:	f2 e0       	ldi	r31, 0x02	; 2
     200:	83 81       	ldd	r24, Z+3	; 0x03
     202:	8f 93       	push	r24
     204:	82 81       	ldd	r24, Z+2	; 0x02
     206:	8f 93       	push	r24
     208:	81 81       	ldd	r24, Z+1	; 0x01
     20a:	8f 93       	push	r24
     20c:	80 81       	ld	r24, Z
     20e:	8f 93       	push	r24
     210:	3f 92       	push	r3
     212:	2f 92       	push	r2
     214:	7f 92       	push	r7
     216:	6f 92       	push	r6
     218:	0e 94 cc 19 	call	0x3398	; 0x3398 <sprintf>
			UART_putstring(MyString);
     21c:	c3 01       	movw	r24, r6
     21e:	0e 94 34 15 	call	0x2a68	; 0x2a68 <UART_putstring>
     222:	0f b6       	in	r0, 0x3f	; 63
     224:	f8 94       	cli
     226:	de bf       	out	0x3e, r29	; 62
     228:	0f be       	out	0x3f, r0	; 63
     22a:	cd bf       	out	0x3d, r28	; 61
     22c:	a9 cf       	rjmp	.-174    	; 0x180 <vMahonyTaskFunction+0x42>

0000022e <vMPU6050TaskFunction>:
		}
	}
	vTaskDelete( NULL );
}
void vMPU6050TaskFunction( void *pvParameters )
{
     22e:	cf 93       	push	r28
     230:	df 93       	push	r29
     232:	00 d0       	rcall	.+0      	; 0x234 <vMPU6050TaskFunction+0x6>
     234:	cd b7       	in	r28, 0x3d	; 61
     236:	de b7       	in	r29, 0x3e	; 62
	for( ;; )
	{
		TickType_t xLastWakeTimeMPU;
		const TickType_t xPeriodFrequencyMPU = 8;// 10ms per tick  15ms*80 = 120
		
		xLastWakeTimeMPU = xTaskGetTickCount();
     238:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <xTaskGetTickCount>
     23c:	9a 83       	std	Y+2, r25	; 0x02
     23e:	89 83       	std	Y+1, r24	; 0x01

		for( ;; )
		{
			vTaskDelayUntil( &xLastWakeTimeMPU, xPeriodFrequencyMPU );
     240:	68 e0       	ldi	r22, 0x08	; 8
     242:	70 e0       	ldi	r23, 0x00	; 0
     244:	ce 01       	movw	r24, r28
     246:	01 96       	adiw	r24, 0x01	; 1
     248:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <vTaskDelayUntil>
			MPU_read(AccData,GyroData);
     24c:	6a e0       	ldi	r22, 0x0A	; 10
     24e:	71 e0       	ldi	r23, 0x01	; 1
     250:	86 e1       	ldi	r24, 0x16	; 22
     252:	91 e0       	ldi	r25, 0x01	; 1
     254:	0e 94 31 06 	call	0xc62	; 0xc62 <MPU_read>
     258:	f3 cf       	rjmp	.-26     	; 0x240 <vMPU6050TaskFunction+0x12>

0000025a <vCTaskFunction>:
	vTaskDelete( NULL );
}

// Task C for control
void vCTaskFunction( void *pvParameters )
{
     25a:	cf 93       	push	r28
     25c:	df 93       	push	r29
     25e:	00 d0       	rcall	.+0      	; 0x260 <vCTaskFunction+0x6>
     260:	cd b7       	in	r28, 0x3d	; 61
     262:	de b7       	in	r29, 0x3e	; 62
	{
		TickType_t xLastWakeTimeC;
		const TickType_t xLightupDelayC = 30;		// 15ms*30 = 450
		const TickType_t xPeriodFrequencyC = 100;// 15ms per tick  15ms*93 = 1395
		
		xLastWakeTimeC = xTaskGetTickCount();
     264:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <xTaskGetTickCount>
     268:	9a 83       	std	Y+2, r25	; 0x02
     26a:	89 83       	std	Y+1, r24	; 0x01

		for( ;; )
		{
			vTaskDelayUntil( &xLastWakeTimeC, xPeriodFrequencyC );
     26c:	64 e6       	ldi	r22, 0x64	; 100
     26e:	70 e0       	ldi	r23, 0x00	; 0
     270:	ce 01       	movw	r24, r28
     272:	01 96       	adiw	r24, 0x01	; 1
     274:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <vTaskDelayUntil>
			//led on
			//sprintf(MyString,"TASKC On\n");
			//UART_putstring(MyString);
			PORTB |= (1<<PORTB2);
     278:	2a 9a       	sbi	0x05, 2	; 5
			vTaskDelay(xLightupDelayC);
     27a:	8e e1       	ldi	r24, 0x1E	; 30
     27c:	90 e0       	ldi	r25, 0x00	; 0
     27e:	0e 94 a9 10 	call	0x2152	; 0x2152 <vTaskDelay>
			PORTB &= ~(1<<PORTB2);
     282:	2a 98       	cbi	0x05, 2	; 5
     284:	f3 cf       	rjmp	.-26     	; 0x26c <vCTaskFunction+0x12>

00000286 <MytaskCreate>:
	}
	vTaskDelete( NULL );
}
//
void MytaskCreate(void)
{
     286:	ef 92       	push	r14
     288:	ff 92       	push	r15
     28a:	0f 93       	push	r16
	/* Create tasks and make some magic*/

	xTaskCreate( vMahonyTaskFunction,"TASKA",256,NULL,4,NULL);
     28c:	e1 2c       	mov	r14, r1
     28e:	f1 2c       	mov	r15, r1
     290:	04 e0       	ldi	r16, 0x04	; 4
     292:	20 e0       	ldi	r18, 0x00	; 0
     294:	30 e0       	ldi	r19, 0x00	; 0
     296:	40 e0       	ldi	r20, 0x00	; 0
     298:	51 e0       	ldi	r21, 0x01	; 1
     29a:	60 e3       	ldi	r22, 0x30	; 48
     29c:	71 e0       	ldi	r23, 0x01	; 1
     29e:	8f e9       	ldi	r24, 0x9F	; 159
     2a0:	90 e0       	ldi	r25, 0x00	; 0
     2a2:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <xTaskCreate>
	xTaskCreate( vMPU6050TaskFunction,"TASKB",256,NULL,3,NULL);
     2a6:	03 e0       	ldi	r16, 0x03	; 3
     2a8:	20 e0       	ldi	r18, 0x00	; 0
     2aa:	30 e0       	ldi	r19, 0x00	; 0
     2ac:	40 e0       	ldi	r20, 0x00	; 0
     2ae:	51 e0       	ldi	r21, 0x01	; 1
     2b0:	66 e3       	ldi	r22, 0x36	; 54
     2b2:	71 e0       	ldi	r23, 0x01	; 1
     2b4:	87 e1       	ldi	r24, 0x17	; 23
     2b6:	91 e0       	ldi	r25, 0x01	; 1
     2b8:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <xTaskCreate>
	xTaskCreate( vCTaskFunction,"TASKC",256,NULL,2,NULL);
     2bc:	02 e0       	ldi	r16, 0x02	; 2
     2be:	20 e0       	ldi	r18, 0x00	; 0
     2c0:	30 e0       	ldi	r19, 0x00	; 0
     2c2:	40 e0       	ldi	r20, 0x00	; 0
     2c4:	51 e0       	ldi	r21, 0x01	; 1
     2c6:	6c e3       	ldi	r22, 0x3C	; 60
     2c8:	71 e0       	ldi	r23, 0x01	; 1
     2ca:	8d e2       	ldi	r24, 0x2D	; 45
     2cc:	91 e0       	ldi	r25, 0x01	; 1
     2ce:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <xTaskCreate>

}
     2d2:	0f 91       	pop	r16
     2d4:	ff 90       	pop	r15
     2d6:	ef 90       	pop	r14
     2d8:	08 95       	ret

000002da <invSqrt>:
float integralFBx = 0;
float integralFBy = 0;
float integralFBz = 0;

float invSqrt( float number )
{
     2da:	cf 92       	push	r12
     2dc:	df 92       	push	r13
     2de:	ef 92       	push	r14
     2e0:	ff 92       	push	r15
     2e2:	0f 93       	push	r16
     2e4:	1f 93       	push	r17

	x2 = number * 0.5F;
	y  = number;
	i  = * ( long * ) &y;                       
	i  = 0x5f3759df - ( i >> 1 );               
	y  = * ( float * ) &i;
     2e6:	8b 01       	movw	r16, r22
     2e8:	9c 01       	movw	r18, r24
     2ea:	35 95       	asr	r19
     2ec:	27 95       	ror	r18
     2ee:	17 95       	ror	r17
     2f0:	07 95       	ror	r16
     2f2:	0f 2e       	mov	r0, r31
     2f4:	ff ed       	ldi	r31, 0xDF	; 223
     2f6:	cf 2e       	mov	r12, r31
     2f8:	f9 e5       	ldi	r31, 0x59	; 89
     2fa:	df 2e       	mov	r13, r31
     2fc:	f7 e3       	ldi	r31, 0x37	; 55
     2fe:	ef 2e       	mov	r14, r31
     300:	ff e5       	ldi	r31, 0x5F	; 95
     302:	ff 2e       	mov	r15, r31
     304:	f0 2d       	mov	r31, r0
     306:	c0 1a       	sub	r12, r16
     308:	d1 0a       	sbc	r13, r17
     30a:	e2 0a       	sbc	r14, r18
     30c:	f3 0a       	sbc	r15, r19
	y  = y * ( threehalfs - ( x2 * y * y ) );   

	return y;
     30e:	20 e0       	ldi	r18, 0x00	; 0
     310:	30 e0       	ldi	r19, 0x00	; 0
     312:	40 e0       	ldi	r20, 0x00	; 0
     314:	5f e3       	ldi	r21, 0x3F	; 63
     316:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     31a:	a7 01       	movw	r20, r14
     31c:	96 01       	movw	r18, r12
     31e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     322:	a7 01       	movw	r20, r14
     324:	96 01       	movw	r18, r12
     326:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     32a:	9b 01       	movw	r18, r22
     32c:	ac 01       	movw	r20, r24
     32e:	60 e0       	ldi	r22, 0x00	; 0
     330:	70 e0       	ldi	r23, 0x00	; 0
     332:	80 ec       	ldi	r24, 0xC0	; 192
     334:	9f e3       	ldi	r25, 0x3F	; 63
     336:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     33a:	a7 01       	movw	r20, r14
     33c:	96 01       	movw	r18, r12
     33e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
}
     342:	1f 91       	pop	r17
     344:	0f 91       	pop	r16
     346:	ff 90       	pop	r15
     348:	ef 90       	pop	r14
     34a:	df 90       	pop	r13
     34c:	cf 90       	pop	r12
     34e:	08 95       	ret

00000350 <MahonyAHRSupdateIMU>:

void MahonyAHRSupdateIMU(float gx, float gy, float gz, float ax, float ay, float az) 
{
     350:	4f 92       	push	r4
     352:	5f 92       	push	r5
     354:	6f 92       	push	r6
     356:	7f 92       	push	r7
     358:	8f 92       	push	r8
     35a:	9f 92       	push	r9
     35c:	af 92       	push	r10
     35e:	bf 92       	push	r11
     360:	cf 92       	push	r12
     362:	df 92       	push	r13
     364:	ef 92       	push	r14
     366:	ff 92       	push	r15
     368:	0f 93       	push	r16
     36a:	1f 93       	push	r17
     36c:	cf 93       	push	r28
     36e:	df 93       	push	r29
     370:	cd b7       	in	r28, 0x3d	; 61
     372:	de b7       	in	r29, 0x3e	; 62
     374:	a0 97       	sbiw	r28, 0x20	; 32
     376:	0f b6       	in	r0, 0x3f	; 63
     378:	f8 94       	cli
     37a:	de bf       	out	0x3e, r29	; 62
     37c:	0f be       	out	0x3f, r0	; 63
     37e:	cd bf       	out	0x3d, r28	; 61
     380:	69 87       	std	Y+9, r22	; 0x09
     382:	7a 87       	std	Y+10, r23	; 0x0a
     384:	8b 87       	std	Y+11, r24	; 0x0b
     386:	9c 87       	std	Y+12, r25	; 0x0c
     388:	2d 87       	std	Y+13, r18	; 0x0d
     38a:	3e 87       	std	Y+14, r19	; 0x0e
     38c:	4f 87       	std	Y+15, r20	; 0x0f
     38e:	58 8b       	std	Y+16, r21	; 0x10
     390:	e9 8a       	std	Y+17, r14	; 0x11
     392:	fa 8a       	std	Y+18, r15	; 0x12
     394:	0b 8b       	std	Y+19, r16	; 0x13
     396:	1c 8b       	std	Y+20, r17	; 0x14

	float qa, qb, qc;
	
	// Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation)

	if(!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {
     398:	20 e0       	ldi	r18, 0x00	; 0
     39a:	30 e0       	ldi	r19, 0x00	; 0
     39c:	a9 01       	movw	r20, r18
     39e:	c6 01       	movw	r24, r12
     3a0:	b5 01       	movw	r22, r10
     3a2:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <__cmpsf2>
     3a6:	81 11       	cpse	r24, r1
     3a8:	17 c0       	rjmp	.+46     	; 0x3d8 <MahonyAHRSupdateIMU+0x88>
     3aa:	20 e0       	ldi	r18, 0x00	; 0
     3ac:	30 e0       	ldi	r19, 0x00	; 0
     3ae:	a9 01       	movw	r20, r18
     3b0:	6b a9       	ldd	r22, Y+51	; 0x33
     3b2:	7c a9       	ldd	r23, Y+52	; 0x34
     3b4:	8d a9       	ldd	r24, Y+53	; 0x35
     3b6:	9e a9       	ldd	r25, Y+54	; 0x36
     3b8:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <__cmpsf2>
     3bc:	81 11       	cpse	r24, r1
     3be:	0c c0       	rjmp	.+24     	; 0x3d8 <MahonyAHRSupdateIMU+0x88>
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	30 e0       	ldi	r19, 0x00	; 0
     3c4:	a9 01       	movw	r20, r18
     3c6:	6f a9       	ldd	r22, Y+55	; 0x37
     3c8:	78 ad       	ldd	r23, Y+56	; 0x38
     3ca:	89 ad       	ldd	r24, Y+57	; 0x39
     3cc:	9a ad       	ldd	r25, Y+58	; 0x3a
     3ce:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <__cmpsf2>
     3d2:	88 23       	and	r24, r24
     3d4:	09 f4       	brne	.+2      	; 0x3d8 <MahonyAHRSupdateIMU+0x88>
     3d6:	50 c1       	rjmp	.+672    	; 0x678 <__LOCK_REGION_LENGTH__+0x278>

		// Normalise accelerometer measurement

		recipNorm = invSqrt(ax * ax + ay * ay + az * az);
     3d8:	a6 01       	movw	r20, r12
     3da:	95 01       	movw	r18, r10
     3dc:	c6 01       	movw	r24, r12
     3de:	b5 01       	movw	r22, r10
     3e0:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     3e4:	2b 01       	movw	r4, r22
     3e6:	3c 01       	movw	r6, r24
     3e8:	2b a9       	ldd	r18, Y+51	; 0x33
     3ea:	3c a9       	ldd	r19, Y+52	; 0x34
     3ec:	4d a9       	ldd	r20, Y+53	; 0x35
     3ee:	5e a9       	ldd	r21, Y+54	; 0x36
     3f0:	ca 01       	movw	r24, r20
     3f2:	b9 01       	movw	r22, r18
     3f4:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     3f8:	9b 01       	movw	r18, r22
     3fa:	ac 01       	movw	r20, r24
     3fc:	c3 01       	movw	r24, r6
     3fe:	b2 01       	movw	r22, r4
     400:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     404:	2b 01       	movw	r4, r22
     406:	3c 01       	movw	r6, r24
     408:	2f a9       	ldd	r18, Y+55	; 0x37
     40a:	38 ad       	ldd	r19, Y+56	; 0x38
     40c:	49 ad       	ldd	r20, Y+57	; 0x39
     40e:	5a ad       	ldd	r21, Y+58	; 0x3a
     410:	ca 01       	movw	r24, r20
     412:	b9 01       	movw	r22, r18
     414:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     418:	9b 01       	movw	r18, r22
     41a:	ac 01       	movw	r20, r24
     41c:	c3 01       	movw	r24, r6
     41e:	b2 01       	movw	r22, r4
     420:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     424:	0e 94 6d 01 	call	0x2da	; 0x2da <invSqrt>
     428:	2b 01       	movw	r4, r22
     42a:	3c 01       	movw	r6, r24

		ax *= recipNorm;
     42c:	9b 01       	movw	r18, r22
     42e:	ac 01       	movw	r20, r24
     430:	c6 01       	movw	r24, r12
     432:	b5 01       	movw	r22, r10
     434:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     438:	69 8f       	std	Y+25, r22	; 0x19
     43a:	7a 8f       	std	Y+26, r23	; 0x1a
     43c:	8b 8f       	std	Y+27, r24	; 0x1b
     43e:	9c 8f       	std	Y+28, r25	; 0x1c

		ay *= recipNorm;
     440:	a3 01       	movw	r20, r6
     442:	92 01       	movw	r18, r4
     444:	6b a9       	ldd	r22, Y+51	; 0x33
     446:	7c a9       	ldd	r23, Y+52	; 0x34
     448:	8d a9       	ldd	r24, Y+53	; 0x35
     44a:	9e a9       	ldd	r25, Y+54	; 0x36
     44c:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     450:	6d 8f       	std	Y+29, r22	; 0x1d
     452:	7e 8f       	std	Y+30, r23	; 0x1e
     454:	8f 8f       	std	Y+31, r24	; 0x1f
     456:	98 a3       	std	Y+32, r25	; 0x20

		az *= recipNorm;
     458:	a3 01       	movw	r20, r6
     45a:	92 01       	movw	r18, r4
     45c:	6f a9       	ldd	r22, Y+55	; 0x37
     45e:	78 ad       	ldd	r23, Y+56	; 0x38
     460:	89 ad       	ldd	r24, Y+57	; 0x39
     462:	9a ad       	ldd	r25, Y+58	; 0x3a
     464:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     468:	6d 83       	std	Y+5, r22	; 0x05
     46a:	7e 83       	std	Y+6, r23	; 0x06
     46c:	8f 83       	std	Y+7, r24	; 0x07
     46e:	98 87       	std	Y+8, r25	; 0x08

		// Estimated direction of gravity and vector perpendicular to magnetic flux

		halfvx = q1 * q3 - q0 * q2;
     470:	80 90 64 01 	lds	r8, 0x0164	; 0x800164 <q1>
     474:	90 90 65 01 	lds	r9, 0x0165	; 0x800165 <q1+0x1>
     478:	a0 90 66 01 	lds	r10, 0x0166	; 0x800166 <q1+0x2>
     47c:	b0 90 67 01 	lds	r11, 0x0167	; 0x800167 <q1+0x3>
     480:	40 90 5c 01 	lds	r4, 0x015C	; 0x80015c <q3>
     484:	50 90 5d 01 	lds	r5, 0x015D	; 0x80015d <q3+0x1>
     488:	60 90 5e 01 	lds	r6, 0x015E	; 0x80015e <q3+0x2>
     48c:	70 90 5f 01 	lds	r7, 0x015F	; 0x80015f <q3+0x3>
     490:	c0 90 06 01 	lds	r12, 0x0106	; 0x800106 <q0>
     494:	d0 90 07 01 	lds	r13, 0x0107	; 0x800107 <q0+0x1>
     498:	e0 90 08 01 	lds	r14, 0x0108	; 0x800108 <q0+0x2>
     49c:	f0 90 09 01 	lds	r15, 0x0109	; 0x800109 <q0+0x3>
     4a0:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <q2>
     4a4:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <q2+0x1>
     4a8:	a0 91 62 01 	lds	r26, 0x0162	; 0x800162 <q2+0x2>
     4ac:	b0 91 63 01 	lds	r27, 0x0163	; 0x800163 <q2+0x3>
     4b0:	89 83       	std	Y+1, r24	; 0x01
     4b2:	9a 83       	std	Y+2, r25	; 0x02
     4b4:	ab 83       	std	Y+3, r26	; 0x03
     4b6:	bc 83       	std	Y+4, r27	; 0x04
     4b8:	a3 01       	movw	r20, r6
     4ba:	92 01       	movw	r18, r4
     4bc:	c5 01       	movw	r24, r10
     4be:	b4 01       	movw	r22, r8
     4c0:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     4c4:	6d 8b       	std	Y+21, r22	; 0x15
     4c6:	7e 8b       	std	Y+22, r23	; 0x16
     4c8:	8f 8b       	std	Y+23, r24	; 0x17
     4ca:	98 8f       	std	Y+24, r25	; 0x18
     4cc:	29 81       	ldd	r18, Y+1	; 0x01
     4ce:	3a 81       	ldd	r19, Y+2	; 0x02
     4d0:	4b 81       	ldd	r20, Y+3	; 0x03
     4d2:	5c 81       	ldd	r21, Y+4	; 0x04
     4d4:	c7 01       	movw	r24, r14
     4d6:	b6 01       	movw	r22, r12
     4d8:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     4dc:	9b 01       	movw	r18, r22
     4de:	ac 01       	movw	r20, r24
     4e0:	6d 89       	ldd	r22, Y+21	; 0x15
     4e2:	7e 89       	ldd	r23, Y+22	; 0x16
     4e4:	8f 89       	ldd	r24, Y+23	; 0x17
     4e6:	98 8d       	ldd	r25, Y+24	; 0x18
     4e8:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     4ec:	6d 8b       	std	Y+21, r22	; 0x15
     4ee:	7e 8b       	std	Y+22, r23	; 0x16
     4f0:	8f 8b       	std	Y+23, r24	; 0x17
     4f2:	98 8f       	std	Y+24, r25	; 0x18

		halfvy = q0 * q1 + q2 * q3;
     4f4:	a7 01       	movw	r20, r14
     4f6:	96 01       	movw	r18, r12
     4f8:	c5 01       	movw	r24, r10
     4fa:	b4 01       	movw	r22, r8
     4fc:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     500:	4b 01       	movw	r8, r22
     502:	5c 01       	movw	r10, r24
     504:	29 81       	ldd	r18, Y+1	; 0x01
     506:	3a 81       	ldd	r19, Y+2	; 0x02
     508:	4b 81       	ldd	r20, Y+3	; 0x03
     50a:	5c 81       	ldd	r21, Y+4	; 0x04
     50c:	c3 01       	movw	r24, r6
     50e:	b2 01       	movw	r22, r4
     510:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     514:	9b 01       	movw	r18, r22
     516:	ac 01       	movw	r20, r24
     518:	c5 01       	movw	r24, r10
     51a:	b4 01       	movw	r22, r8
     51c:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     520:	69 83       	std	Y+1, r22	; 0x01
     522:	7a 83       	std	Y+2, r23	; 0x02
     524:	8b 83       	std	Y+3, r24	; 0x03
     526:	9c 83       	std	Y+4, r25	; 0x04

		halfvz = q0 * q0 - 0.5f + q3 * q3;
     528:	a7 01       	movw	r20, r14
     52a:	96 01       	movw	r18, r12
     52c:	c7 01       	movw	r24, r14
     52e:	b6 01       	movw	r22, r12
     530:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     534:	20 e0       	ldi	r18, 0x00	; 0
     536:	30 e0       	ldi	r19, 0x00	; 0
     538:	40 e0       	ldi	r20, 0x00	; 0
     53a:	5f e3       	ldi	r21, 0x3F	; 63
     53c:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     540:	6b 01       	movw	r12, r22
     542:	7c 01       	movw	r14, r24
     544:	a3 01       	movw	r20, r6
     546:	92 01       	movw	r18, r4
     548:	c3 01       	movw	r24, r6
     54a:	b2 01       	movw	r22, r4
     54c:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     550:	9b 01       	movw	r18, r22
     552:	ac 01       	movw	r20, r24
     554:	c7 01       	movw	r24, r14
     556:	b6 01       	movw	r22, r12
     558:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     55c:	6b 01       	movw	r12, r22
     55e:	7c 01       	movw	r14, r24

		}

		else {

			integralFBx = 0.0f; // prevent integral windup
     560:	10 92 58 01 	sts	0x0158, r1	; 0x800158 <integralFBx>
     564:	10 92 59 01 	sts	0x0159, r1	; 0x800159 <integralFBx+0x1>
     568:	10 92 5a 01 	sts	0x015A, r1	; 0x80015a <integralFBx+0x2>
     56c:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <integralFBx+0x3>

			integralFBy = 0.0f;
     570:	10 92 54 01 	sts	0x0154, r1	; 0x800154 <integralFBy>
     574:	10 92 55 01 	sts	0x0155, r1	; 0x800155 <integralFBy+0x1>
     578:	10 92 56 01 	sts	0x0156, r1	; 0x800156 <integralFBy+0x2>
     57c:	10 92 57 01 	sts	0x0157, r1	; 0x800157 <integralFBy+0x3>

			integralFBz = 0.0f;
     580:	10 92 50 01 	sts	0x0150, r1	; 0x800150 <__data_end>
     584:	10 92 51 01 	sts	0x0151, r1	; 0x800151 <__data_end+0x1>
     588:	10 92 52 01 	sts	0x0152, r1	; 0x800152 <__data_end+0x2>
     58c:	10 92 53 01 	sts	0x0153, r1	; 0x800153 <__data_end+0x3>

		}

		// Apply proportional feedback

		gx += twoKp * halfex;
     590:	9b 01       	movw	r18, r22
     592:	ac 01       	movw	r20, r24
     594:	6d 8d       	ldd	r22, Y+29	; 0x1d
     596:	7e 8d       	ldd	r23, Y+30	; 0x1e
     598:	8f 8d       	ldd	r24, Y+31	; 0x1f
     59a:	98 a1       	ldd	r25, Y+32	; 0x20
     59c:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     5a0:	4b 01       	movw	r8, r22
     5a2:	5c 01       	movw	r10, r24
     5a4:	29 81       	ldd	r18, Y+1	; 0x01
     5a6:	3a 81       	ldd	r19, Y+2	; 0x02
     5a8:	4b 81       	ldd	r20, Y+3	; 0x03
     5aa:	5c 81       	ldd	r21, Y+4	; 0x04
     5ac:	6d 81       	ldd	r22, Y+5	; 0x05
     5ae:	7e 81       	ldd	r23, Y+6	; 0x06
     5b0:	8f 81       	ldd	r24, Y+7	; 0x07
     5b2:	98 85       	ldd	r25, Y+8	; 0x08
     5b4:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     5b8:	9b 01       	movw	r18, r22
     5ba:	ac 01       	movw	r20, r24
     5bc:	c5 01       	movw	r24, r10
     5be:	b4 01       	movw	r22, r8
     5c0:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     5c4:	9b 01       	movw	r18, r22
     5c6:	ac 01       	movw	r20, r24
     5c8:	69 85       	ldd	r22, Y+9	; 0x09
     5ca:	7a 85       	ldd	r23, Y+10	; 0x0a
     5cc:	8b 85       	ldd	r24, Y+11	; 0x0b
     5ce:	9c 85       	ldd	r25, Y+12	; 0x0c
     5d0:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     5d4:	69 87       	std	Y+9, r22	; 0x09
     5d6:	7a 87       	std	Y+10, r23	; 0x0a
     5d8:	8b 87       	std	Y+11, r24	; 0x0b
     5da:	9c 87       	std	Y+12, r25	; 0x0c

		gy += twoKp * halfey;
     5dc:	2d 89       	ldd	r18, Y+21	; 0x15
     5de:	3e 89       	ldd	r19, Y+22	; 0x16
     5e0:	4f 89       	ldd	r20, Y+23	; 0x17
     5e2:	58 8d       	ldd	r21, Y+24	; 0x18
     5e4:	6d 81       	ldd	r22, Y+5	; 0x05
     5e6:	7e 81       	ldd	r23, Y+6	; 0x06
     5e8:	8f 81       	ldd	r24, Y+7	; 0x07
     5ea:	98 85       	ldd	r25, Y+8	; 0x08
     5ec:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     5f0:	4b 01       	movw	r8, r22
     5f2:	5c 01       	movw	r10, r24
     5f4:	a7 01       	movw	r20, r14
     5f6:	96 01       	movw	r18, r12
     5f8:	69 8d       	ldd	r22, Y+25	; 0x19
     5fa:	7a 8d       	ldd	r23, Y+26	; 0x1a
     5fc:	8b 8d       	ldd	r24, Y+27	; 0x1b
     5fe:	9c 8d       	ldd	r25, Y+28	; 0x1c
     600:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     604:	9b 01       	movw	r18, r22
     606:	ac 01       	movw	r20, r24
     608:	c5 01       	movw	r24, r10
     60a:	b4 01       	movw	r22, r8
     60c:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     610:	9b 01       	movw	r18, r22
     612:	ac 01       	movw	r20, r24
     614:	6d 85       	ldd	r22, Y+13	; 0x0d
     616:	7e 85       	ldd	r23, Y+14	; 0x0e
     618:	8f 85       	ldd	r24, Y+15	; 0x0f
     61a:	98 89       	ldd	r25, Y+16	; 0x10
     61c:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     620:	6d 87       	std	Y+13, r22	; 0x0d
     622:	7e 87       	std	Y+14, r23	; 0x0e
     624:	8f 87       	std	Y+15, r24	; 0x0f
     626:	98 8b       	std	Y+16, r25	; 0x10

		gz += twoKp * halfez;
     628:	29 81       	ldd	r18, Y+1	; 0x01
     62a:	3a 81       	ldd	r19, Y+2	; 0x02
     62c:	4b 81       	ldd	r20, Y+3	; 0x03
     62e:	5c 81       	ldd	r21, Y+4	; 0x04
     630:	69 8d       	ldd	r22, Y+25	; 0x19
     632:	7a 8d       	ldd	r23, Y+26	; 0x1a
     634:	8b 8d       	ldd	r24, Y+27	; 0x1b
     636:	9c 8d       	ldd	r25, Y+28	; 0x1c
     638:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     63c:	6b 01       	movw	r12, r22
     63e:	7c 01       	movw	r14, r24
     640:	2d 89       	ldd	r18, Y+21	; 0x15
     642:	3e 89       	ldd	r19, Y+22	; 0x16
     644:	4f 89       	ldd	r20, Y+23	; 0x17
     646:	58 8d       	ldd	r21, Y+24	; 0x18
     648:	6d 8d       	ldd	r22, Y+29	; 0x1d
     64a:	7e 8d       	ldd	r23, Y+30	; 0x1e
     64c:	8f 8d       	ldd	r24, Y+31	; 0x1f
     64e:	98 a1       	ldd	r25, Y+32	; 0x20
     650:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     654:	9b 01       	movw	r18, r22
     656:	ac 01       	movw	r20, r24
     658:	c7 01       	movw	r24, r14
     65a:	b6 01       	movw	r22, r12
     65c:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     660:	9b 01       	movw	r18, r22
     662:	ac 01       	movw	r20, r24
     664:	69 89       	ldd	r22, Y+17	; 0x11
     666:	7a 89       	ldd	r23, Y+18	; 0x12
     668:	8b 89       	ldd	r24, Y+19	; 0x13
     66a:	9c 89       	ldd	r25, Y+20	; 0x14
     66c:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     670:	69 8b       	std	Y+17, r22	; 0x11
     672:	7a 8b       	std	Y+18, r23	; 0x12
     674:	8b 8b       	std	Y+19, r24	; 0x13
     676:	9c 8b       	std	Y+20, r25	; 0x14

	}

	// Integrate rate of change of quaternion

	gx *= (0.5f * (1.0f / sampleFreq)); // pre-multiply common factors
     678:	2a e0       	ldi	r18, 0x0A	; 10
     67a:	37 ed       	ldi	r19, 0xD7	; 215
     67c:	43 ea       	ldi	r20, 0xA3	; 163
     67e:	5b e3       	ldi	r21, 0x3B	; 59
     680:	69 85       	ldd	r22, Y+9	; 0x09
     682:	7a 85       	ldd	r23, Y+10	; 0x0a
     684:	8b 85       	ldd	r24, Y+11	; 0x0b
     686:	9c 85       	ldd	r25, Y+12	; 0x0c
     688:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     68c:	69 87       	std	Y+9, r22	; 0x09
     68e:	7a 87       	std	Y+10, r23	; 0x0a
     690:	8b 87       	std	Y+11, r24	; 0x0b
     692:	9c 87       	std	Y+12, r25	; 0x0c

	gy *= (0.5f * (1.0f / sampleFreq));
     694:	2a e0       	ldi	r18, 0x0A	; 10
     696:	37 ed       	ldi	r19, 0xD7	; 215
     698:	43 ea       	ldi	r20, 0xA3	; 163
     69a:	5b e3       	ldi	r21, 0x3B	; 59
     69c:	6d 85       	ldd	r22, Y+13	; 0x0d
     69e:	7e 85       	ldd	r23, Y+14	; 0x0e
     6a0:	8f 85       	ldd	r24, Y+15	; 0x0f
     6a2:	98 89       	ldd	r25, Y+16	; 0x10
     6a4:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     6a8:	6d 87       	std	Y+13, r22	; 0x0d
     6aa:	7e 87       	std	Y+14, r23	; 0x0e
     6ac:	8f 87       	std	Y+15, r24	; 0x0f
     6ae:	98 8b       	std	Y+16, r25	; 0x10

	gz *= (0.5f * (1.0f / sampleFreq));
     6b0:	2a e0       	ldi	r18, 0x0A	; 10
     6b2:	37 ed       	ldi	r19, 0xD7	; 215
     6b4:	43 ea       	ldi	r20, 0xA3	; 163
     6b6:	5b e3       	ldi	r21, 0x3B	; 59
     6b8:	69 89       	ldd	r22, Y+17	; 0x11
     6ba:	7a 89       	ldd	r23, Y+18	; 0x12
     6bc:	8b 89       	ldd	r24, Y+19	; 0x13
     6be:	9c 89       	ldd	r25, Y+20	; 0x14
     6c0:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     6c4:	69 8b       	std	Y+17, r22	; 0x11
     6c6:	7a 8b       	std	Y+18, r23	; 0x12
     6c8:	8b 8b       	std	Y+19, r24	; 0x13
     6ca:	9c 8b       	std	Y+20, r25	; 0x14

	qa = q0;
     6cc:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <q0>
     6d0:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <q0+0x1>
     6d4:	a0 91 08 01 	lds	r26, 0x0108	; 0x800108 <q0+0x2>
     6d8:	b0 91 09 01 	lds	r27, 0x0109	; 0x800109 <q0+0x3>
     6dc:	89 83       	std	Y+1, r24	; 0x01
     6de:	9a 83       	std	Y+2, r25	; 0x02
     6e0:	ab 83       	std	Y+3, r26	; 0x03
     6e2:	bc 83       	std	Y+4, r27	; 0x04

	qb = q1;
     6e4:	c0 90 64 01 	lds	r12, 0x0164	; 0x800164 <q1>
     6e8:	d0 90 65 01 	lds	r13, 0x0165	; 0x800165 <q1+0x1>
     6ec:	e0 90 66 01 	lds	r14, 0x0166	; 0x800166 <q1+0x2>
     6f0:	f0 90 67 01 	lds	r15, 0x0167	; 0x800167 <q1+0x3>

	qc = q2;
     6f4:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <q2>
     6f8:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <q2+0x1>
     6fc:	a0 91 62 01 	lds	r26, 0x0162	; 0x800162 <q2+0x2>
     700:	b0 91 63 01 	lds	r27, 0x0163	; 0x800163 <q2+0x3>
     704:	8d 83       	std	Y+5, r24	; 0x05
     706:	9e 83       	std	Y+6, r25	; 0x06
     708:	af 83       	std	Y+7, r26	; 0x07
     70a:	b8 87       	std	Y+8, r27	; 0x08

	//update

	q0 += (-qb * gx - qc * gy - q3 * gz);
     70c:	40 90 5c 01 	lds	r4, 0x015C	; 0x80015c <q3>
     710:	50 90 5d 01 	lds	r5, 0x015D	; 0x80015d <q3+0x1>
     714:	60 90 5e 01 	lds	r6, 0x015E	; 0x80015e <q3+0x2>
     718:	70 90 5f 01 	lds	r7, 0x015F	; 0x80015f <q3+0x3>
     71c:	c7 01       	movw	r24, r14
     71e:	b6 01       	movw	r22, r12
     720:	90 58       	subi	r25, 0x80	; 128
     722:	29 85       	ldd	r18, Y+9	; 0x09
     724:	3a 85       	ldd	r19, Y+10	; 0x0a
     726:	4b 85       	ldd	r20, Y+11	; 0x0b
     728:	5c 85       	ldd	r21, Y+12	; 0x0c
     72a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     72e:	4b 01       	movw	r8, r22
     730:	5c 01       	movw	r10, r24
     732:	2d 81       	ldd	r18, Y+5	; 0x05
     734:	3e 81       	ldd	r19, Y+6	; 0x06
     736:	4f 81       	ldd	r20, Y+7	; 0x07
     738:	58 85       	ldd	r21, Y+8	; 0x08
     73a:	6d 85       	ldd	r22, Y+13	; 0x0d
     73c:	7e 85       	ldd	r23, Y+14	; 0x0e
     73e:	8f 85       	ldd	r24, Y+15	; 0x0f
     740:	98 89       	ldd	r25, Y+16	; 0x10
     742:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     746:	9b 01       	movw	r18, r22
     748:	ac 01       	movw	r20, r24
     74a:	c5 01       	movw	r24, r10
     74c:	b4 01       	movw	r22, r8
     74e:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     752:	4b 01       	movw	r8, r22
     754:	5c 01       	movw	r10, r24
     756:	a3 01       	movw	r20, r6
     758:	92 01       	movw	r18, r4
     75a:	69 89       	ldd	r22, Y+17	; 0x11
     75c:	7a 89       	ldd	r23, Y+18	; 0x12
     75e:	8b 89       	ldd	r24, Y+19	; 0x13
     760:	9c 89       	ldd	r25, Y+20	; 0x14
     762:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     766:	9b 01       	movw	r18, r22
     768:	ac 01       	movw	r20, r24
     76a:	c5 01       	movw	r24, r10
     76c:	b4 01       	movw	r22, r8
     76e:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     772:	29 81       	ldd	r18, Y+1	; 0x01
     774:	3a 81       	ldd	r19, Y+2	; 0x02
     776:	4b 81       	ldd	r20, Y+3	; 0x03
     778:	5c 81       	ldd	r21, Y+4	; 0x04
     77a:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     77e:	69 8f       	std	Y+25, r22	; 0x19
     780:	7a 8f       	std	Y+26, r23	; 0x1a
     782:	8b 8f       	std	Y+27, r24	; 0x1b
     784:	9c 8f       	std	Y+28, r25	; 0x1c

	q1 += (qa * gx + qc * gz - q3 * gy);
     786:	29 81       	ldd	r18, Y+1	; 0x01
     788:	3a 81       	ldd	r19, Y+2	; 0x02
     78a:	4b 81       	ldd	r20, Y+3	; 0x03
     78c:	5c 81       	ldd	r21, Y+4	; 0x04
     78e:	69 85       	ldd	r22, Y+9	; 0x09
     790:	7a 85       	ldd	r23, Y+10	; 0x0a
     792:	8b 85       	ldd	r24, Y+11	; 0x0b
     794:	9c 85       	ldd	r25, Y+12	; 0x0c
     796:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     79a:	4b 01       	movw	r8, r22
     79c:	5c 01       	movw	r10, r24
     79e:	2d 81       	ldd	r18, Y+5	; 0x05
     7a0:	3e 81       	ldd	r19, Y+6	; 0x06
     7a2:	4f 81       	ldd	r20, Y+7	; 0x07
     7a4:	58 85       	ldd	r21, Y+8	; 0x08
     7a6:	69 89       	ldd	r22, Y+17	; 0x11
     7a8:	7a 89       	ldd	r23, Y+18	; 0x12
     7aa:	8b 89       	ldd	r24, Y+19	; 0x13
     7ac:	9c 89       	ldd	r25, Y+20	; 0x14
     7ae:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     7b2:	9b 01       	movw	r18, r22
     7b4:	ac 01       	movw	r20, r24
     7b6:	c5 01       	movw	r24, r10
     7b8:	b4 01       	movw	r22, r8
     7ba:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     7be:	4b 01       	movw	r8, r22
     7c0:	5c 01       	movw	r10, r24
     7c2:	a3 01       	movw	r20, r6
     7c4:	92 01       	movw	r18, r4
     7c6:	6d 85       	ldd	r22, Y+13	; 0x0d
     7c8:	7e 85       	ldd	r23, Y+14	; 0x0e
     7ca:	8f 85       	ldd	r24, Y+15	; 0x0f
     7cc:	98 89       	ldd	r25, Y+16	; 0x10
     7ce:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     7d2:	9b 01       	movw	r18, r22
     7d4:	ac 01       	movw	r20, r24
     7d6:	c5 01       	movw	r24, r10
     7d8:	b4 01       	movw	r22, r8
     7da:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     7de:	a7 01       	movw	r20, r14
     7e0:	96 01       	movw	r18, r12
     7e2:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     7e6:	6d 8f       	std	Y+29, r22	; 0x1d
     7e8:	7e 8f       	std	Y+30, r23	; 0x1e
     7ea:	8f 8f       	std	Y+31, r24	; 0x1f
     7ec:	98 a3       	std	Y+32, r25	; 0x20

	q2 += (qa * gy - qb * gz + q3 * gx);
     7ee:	29 81       	ldd	r18, Y+1	; 0x01
     7f0:	3a 81       	ldd	r19, Y+2	; 0x02
     7f2:	4b 81       	ldd	r20, Y+3	; 0x03
     7f4:	5c 81       	ldd	r21, Y+4	; 0x04
     7f6:	6d 85       	ldd	r22, Y+13	; 0x0d
     7f8:	7e 85       	ldd	r23, Y+14	; 0x0e
     7fa:	8f 85       	ldd	r24, Y+15	; 0x0f
     7fc:	98 89       	ldd	r25, Y+16	; 0x10
     7fe:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     802:	4b 01       	movw	r8, r22
     804:	5c 01       	movw	r10, r24
     806:	a7 01       	movw	r20, r14
     808:	96 01       	movw	r18, r12
     80a:	69 89       	ldd	r22, Y+17	; 0x11
     80c:	7a 89       	ldd	r23, Y+18	; 0x12
     80e:	8b 89       	ldd	r24, Y+19	; 0x13
     810:	9c 89       	ldd	r25, Y+20	; 0x14
     812:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     816:	9b 01       	movw	r18, r22
     818:	ac 01       	movw	r20, r24
     81a:	c5 01       	movw	r24, r10
     81c:	b4 01       	movw	r22, r8
     81e:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     822:	4b 01       	movw	r8, r22
     824:	5c 01       	movw	r10, r24
     826:	a3 01       	movw	r20, r6
     828:	92 01       	movw	r18, r4
     82a:	69 85       	ldd	r22, Y+9	; 0x09
     82c:	7a 85       	ldd	r23, Y+10	; 0x0a
     82e:	8b 85       	ldd	r24, Y+11	; 0x0b
     830:	9c 85       	ldd	r25, Y+12	; 0x0c
     832:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     836:	9b 01       	movw	r18, r22
     838:	ac 01       	movw	r20, r24
     83a:	c5 01       	movw	r24, r10
     83c:	b4 01       	movw	r22, r8
     83e:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     842:	2d 81       	ldd	r18, Y+5	; 0x05
     844:	3e 81       	ldd	r19, Y+6	; 0x06
     846:	4f 81       	ldd	r20, Y+7	; 0x07
     848:	58 85       	ldd	r21, Y+8	; 0x08
     84a:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     84e:	6d 8b       	std	Y+21, r22	; 0x15
     850:	7e 8b       	std	Y+22, r23	; 0x16
     852:	8f 8b       	std	Y+23, r24	; 0x17
     854:	98 8f       	std	Y+24, r25	; 0x18

	q3 += (qa * gz + qb * gy - qc * gx);
     856:	29 81       	ldd	r18, Y+1	; 0x01
     858:	3a 81       	ldd	r19, Y+2	; 0x02
     85a:	4b 81       	ldd	r20, Y+3	; 0x03
     85c:	5c 81       	ldd	r21, Y+4	; 0x04
     85e:	69 89       	ldd	r22, Y+17	; 0x11
     860:	7a 89       	ldd	r23, Y+18	; 0x12
     862:	8b 89       	ldd	r24, Y+19	; 0x13
     864:	9c 89       	ldd	r25, Y+20	; 0x14
     866:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     86a:	4b 01       	movw	r8, r22
     86c:	5c 01       	movw	r10, r24
     86e:	a7 01       	movw	r20, r14
     870:	96 01       	movw	r18, r12
     872:	6d 85       	ldd	r22, Y+13	; 0x0d
     874:	7e 85       	ldd	r23, Y+14	; 0x0e
     876:	8f 85       	ldd	r24, Y+15	; 0x0f
     878:	98 89       	ldd	r25, Y+16	; 0x10
     87a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     87e:	9b 01       	movw	r18, r22
     880:	ac 01       	movw	r20, r24
     882:	c5 01       	movw	r24, r10
     884:	b4 01       	movw	r22, r8
     886:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     88a:	6b 01       	movw	r12, r22
     88c:	7c 01       	movw	r14, r24
     88e:	2d 81       	ldd	r18, Y+5	; 0x05
     890:	3e 81       	ldd	r19, Y+6	; 0x06
     892:	4f 81       	ldd	r20, Y+7	; 0x07
     894:	58 85       	ldd	r21, Y+8	; 0x08
     896:	69 85       	ldd	r22, Y+9	; 0x09
     898:	7a 85       	ldd	r23, Y+10	; 0x0a
     89a:	8b 85       	ldd	r24, Y+11	; 0x0b
     89c:	9c 85       	ldd	r25, Y+12	; 0x0c
     89e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     8a2:	9b 01       	movw	r18, r22
     8a4:	ac 01       	movw	r20, r24
     8a6:	c7 01       	movw	r24, r14
     8a8:	b6 01       	movw	r22, r12
     8aa:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     8ae:	a3 01       	movw	r20, r6
     8b0:	92 01       	movw	r18, r4
     8b2:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     8b6:	4b 01       	movw	r8, r22
     8b8:	5c 01       	movw	r10, r24

	// Normalise quaternion

	recipNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
     8ba:	29 8d       	ldd	r18, Y+25	; 0x19
     8bc:	3a 8d       	ldd	r19, Y+26	; 0x1a
     8be:	4b 8d       	ldd	r20, Y+27	; 0x1b
     8c0:	5c 8d       	ldd	r21, Y+28	; 0x1c
     8c2:	ca 01       	movw	r24, r20
     8c4:	b9 01       	movw	r22, r18
     8c6:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     8ca:	6b 01       	movw	r12, r22
     8cc:	7c 01       	movw	r14, r24
     8ce:	2d 8d       	ldd	r18, Y+29	; 0x1d
     8d0:	3e 8d       	ldd	r19, Y+30	; 0x1e
     8d2:	4f 8d       	ldd	r20, Y+31	; 0x1f
     8d4:	58 a1       	ldd	r21, Y+32	; 0x20
     8d6:	ca 01       	movw	r24, r20
     8d8:	b9 01       	movw	r22, r18
     8da:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     8de:	9b 01       	movw	r18, r22
     8e0:	ac 01       	movw	r20, r24
     8e2:	c7 01       	movw	r24, r14
     8e4:	b6 01       	movw	r22, r12
     8e6:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     8ea:	6b 01       	movw	r12, r22
     8ec:	7c 01       	movw	r14, r24
     8ee:	2d 89       	ldd	r18, Y+21	; 0x15
     8f0:	3e 89       	ldd	r19, Y+22	; 0x16
     8f2:	4f 89       	ldd	r20, Y+23	; 0x17
     8f4:	58 8d       	ldd	r21, Y+24	; 0x18
     8f6:	ca 01       	movw	r24, r20
     8f8:	b9 01       	movw	r22, r18
     8fa:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     8fe:	9b 01       	movw	r18, r22
     900:	ac 01       	movw	r20, r24
     902:	c7 01       	movw	r24, r14
     904:	b6 01       	movw	r22, r12
     906:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     90a:	6b 01       	movw	r12, r22
     90c:	7c 01       	movw	r14, r24
     90e:	a5 01       	movw	r20, r10
     910:	94 01       	movw	r18, r8
     912:	c5 01       	movw	r24, r10
     914:	b4 01       	movw	r22, r8
     916:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     91a:	9b 01       	movw	r18, r22
     91c:	ac 01       	movw	r20, r24
     91e:	c7 01       	movw	r24, r14
     920:	b6 01       	movw	r22, r12
     922:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     926:	0e 94 6d 01 	call	0x2da	; 0x2da <invSqrt>
     92a:	6b 01       	movw	r12, r22
     92c:	7c 01       	movw	r14, r24

	q0 *= recipNorm;
     92e:	9b 01       	movw	r18, r22
     930:	ac 01       	movw	r20, r24
     932:	69 8d       	ldd	r22, Y+25	; 0x19
     934:	7a 8d       	ldd	r23, Y+26	; 0x1a
     936:	8b 8d       	ldd	r24, Y+27	; 0x1b
     938:	9c 8d       	ldd	r25, Y+28	; 0x1c
     93a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     93e:	60 93 06 01 	sts	0x0106, r22	; 0x800106 <q0>
     942:	70 93 07 01 	sts	0x0107, r23	; 0x800107 <q0+0x1>
     946:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <q0+0x2>
     94a:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <q0+0x3>

	q1 *= recipNorm;
     94e:	a7 01       	movw	r20, r14
     950:	96 01       	movw	r18, r12
     952:	6d 8d       	ldd	r22, Y+29	; 0x1d
     954:	7e 8d       	ldd	r23, Y+30	; 0x1e
     956:	8f 8d       	ldd	r24, Y+31	; 0x1f
     958:	98 a1       	ldd	r25, Y+32	; 0x20
     95a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     95e:	60 93 64 01 	sts	0x0164, r22	; 0x800164 <q1>
     962:	70 93 65 01 	sts	0x0165, r23	; 0x800165 <q1+0x1>
     966:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <q1+0x2>
     96a:	90 93 67 01 	sts	0x0167, r25	; 0x800167 <q1+0x3>

	q2 *= recipNorm;
     96e:	a7 01       	movw	r20, r14
     970:	96 01       	movw	r18, r12
     972:	6d 89       	ldd	r22, Y+21	; 0x15
     974:	7e 89       	ldd	r23, Y+22	; 0x16
     976:	8f 89       	ldd	r24, Y+23	; 0x17
     978:	98 8d       	ldd	r25, Y+24	; 0x18
     97a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     97e:	60 93 60 01 	sts	0x0160, r22	; 0x800160 <q2>
     982:	70 93 61 01 	sts	0x0161, r23	; 0x800161 <q2+0x1>
     986:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <q2+0x2>
     98a:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <q2+0x3>

	q3 *= recipNorm;
     98e:	a7 01       	movw	r20, r14
     990:	96 01       	movw	r18, r12
     992:	c5 01       	movw	r24, r10
     994:	b4 01       	movw	r22, r8
     996:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     99a:	60 93 5c 01 	sts	0x015C, r22	; 0x80015c <q3>
     99e:	70 93 5d 01 	sts	0x015D, r23	; 0x80015d <q3+0x1>
     9a2:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <q3+0x2>
     9a6:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <q3+0x3>

}
     9aa:	a0 96       	adiw	r28, 0x20	; 32
     9ac:	0f b6       	in	r0, 0x3f	; 63
     9ae:	f8 94       	cli
     9b0:	de bf       	out	0x3e, r29	; 62
     9b2:	0f be       	out	0x3f, r0	; 63
     9b4:	cd bf       	out	0x3d, r28	; 61
     9b6:	df 91       	pop	r29
     9b8:	cf 91       	pop	r28
     9ba:	1f 91       	pop	r17
     9bc:	0f 91       	pop	r16
     9be:	ff 90       	pop	r15
     9c0:	ef 90       	pop	r14
     9c2:	df 90       	pop	r13
     9c4:	cf 90       	pop	r12
     9c6:	bf 90       	pop	r11
     9c8:	af 90       	pop	r10
     9ca:	9f 90       	pop	r9
     9cc:	8f 90       	pop	r8
     9ce:	7f 90       	pop	r7
     9d0:	6f 90       	pop	r6
     9d2:	5f 90       	pop	r5
     9d4:	4f 90       	pop	r4
     9d6:	08 95       	ret

000009d8 <q2Angle>:

void q2Angle(float angle[3])
{
     9d8:	4f 92       	push	r4
     9da:	5f 92       	push	r5
     9dc:	6f 92       	push	r6
     9de:	7f 92       	push	r7
     9e0:	8f 92       	push	r8
     9e2:	9f 92       	push	r9
     9e4:	af 92       	push	r10
     9e6:	bf 92       	push	r11
     9e8:	cf 92       	push	r12
     9ea:	df 92       	push	r13
     9ec:	ef 92       	push	r14
     9ee:	ff 92       	push	r15
     9f0:	cf 93       	push	r28
     9f2:	df 93       	push	r29
     9f4:	cd b7       	in	r28, 0x3d	; 61
     9f6:	de b7       	in	r29, 0x3e	; 62
     9f8:	2e 97       	sbiw	r28, 0x0e	; 14
     9fa:	0f b6       	in	r0, 0x3f	; 63
     9fc:	f8 94       	cli
     9fe:	de bf       	out	0x3e, r29	; 62
     a00:	0f be       	out	0x3f, r0	; 63
     a02:	cd bf       	out	0x3d, r28	; 61
     a04:	9e 87       	std	Y+14, r25	; 0x0e
     a06:	8d 87       	std	Y+13, r24	; 0x0d
	angle[2] = atan2(2 * q1 * q2 + 2 * q0 * q3, -2 * q2*q2 - 2 * q3* q3 + 1)* 57.3; // yaw
     a08:	c0 90 60 01 	lds	r12, 0x0160	; 0x800160 <q2>
     a0c:	d0 90 61 01 	lds	r13, 0x0161	; 0x800161 <q2+0x1>
     a10:	e0 90 62 01 	lds	r14, 0x0162	; 0x800162 <q2+0x2>
     a14:	f0 90 63 01 	lds	r15, 0x0163	; 0x800163 <q2+0x3>
     a18:	80 90 5c 01 	lds	r8, 0x015C	; 0x80015c <q3>
     a1c:	90 90 5d 01 	lds	r9, 0x015D	; 0x80015d <q3+0x1>
     a20:	a0 90 5e 01 	lds	r10, 0x015E	; 0x80015e <q3+0x2>
     a24:	b0 90 5f 01 	lds	r11, 0x015F	; 0x80015f <q3+0x3>
     a28:	40 90 64 01 	lds	r4, 0x0164	; 0x800164 <q1>
     a2c:	50 90 65 01 	lds	r5, 0x0165	; 0x800165 <q1+0x1>
     a30:	60 90 66 01 	lds	r6, 0x0166	; 0x800166 <q1+0x2>
     a34:	70 90 67 01 	lds	r7, 0x0167	; 0x800167 <q1+0x3>
     a38:	60 91 06 01 	lds	r22, 0x0106	; 0x800106 <q0>
     a3c:	70 91 07 01 	lds	r23, 0x0107	; 0x800107 <q0+0x1>
     a40:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <q0+0x2>
     a44:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <q0+0x3>
     a48:	9b 01       	movw	r18, r22
     a4a:	ac 01       	movw	r20, r24
     a4c:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     a50:	69 87       	std	Y+9, r22	; 0x09
     a52:	7a 87       	std	Y+10, r23	; 0x0a
     a54:	8b 87       	std	Y+11, r24	; 0x0b
     a56:	9c 87       	std	Y+12, r25	; 0x0c
     a58:	20 e0       	ldi	r18, 0x00	; 0
     a5a:	30 e0       	ldi	r19, 0x00	; 0
     a5c:	40 e0       	ldi	r20, 0x00	; 0
     a5e:	50 ec       	ldi	r21, 0xC0	; 192
     a60:	c7 01       	movw	r24, r14
     a62:	b6 01       	movw	r22, r12
     a64:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     a68:	a7 01       	movw	r20, r14
     a6a:	96 01       	movw	r18, r12
     a6c:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     a70:	69 83       	std	Y+1, r22	; 0x01
     a72:	7a 83       	std	Y+2, r23	; 0x02
     a74:	8b 83       	std	Y+3, r24	; 0x03
     a76:	9c 83       	std	Y+4, r25	; 0x04
     a78:	a5 01       	movw	r20, r10
     a7a:	94 01       	movw	r18, r8
     a7c:	c5 01       	movw	r24, r10
     a7e:	b4 01       	movw	r22, r8
     a80:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     a84:	a5 01       	movw	r20, r10
     a86:	94 01       	movw	r18, r8
     a88:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     a8c:	9b 01       	movw	r18, r22
     a8e:	ac 01       	movw	r20, r24
     a90:	69 81       	ldd	r22, Y+1	; 0x01
     a92:	7a 81       	ldd	r23, Y+2	; 0x02
     a94:	8b 81       	ldd	r24, Y+3	; 0x03
     a96:	9c 81       	ldd	r25, Y+4	; 0x04
     a98:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     a9c:	20 e0       	ldi	r18, 0x00	; 0
     a9e:	30 e0       	ldi	r19, 0x00	; 0
     aa0:	40 e8       	ldi	r20, 0x80	; 128
     aa2:	5f e3       	ldi	r21, 0x3F	; 63
     aa4:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     aa8:	69 83       	std	Y+1, r22	; 0x01
     aaa:	7a 83       	std	Y+2, r23	; 0x02
     aac:	8b 83       	std	Y+3, r24	; 0x03
     aae:	9c 83       	std	Y+4, r25	; 0x04
     ab0:	a3 01       	movw	r20, r6
     ab2:	92 01       	movw	r18, r4
     ab4:	c3 01       	movw	r24, r6
     ab6:	b2 01       	movw	r22, r4
     ab8:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     abc:	a7 01       	movw	r20, r14
     abe:	96 01       	movw	r18, r12
     ac0:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     ac4:	6d 83       	std	Y+5, r22	; 0x05
     ac6:	7e 83       	std	Y+6, r23	; 0x06
     ac8:	8f 83       	std	Y+7, r24	; 0x07
     aca:	98 87       	std	Y+8, r25	; 0x08
     acc:	29 85       	ldd	r18, Y+9	; 0x09
     ace:	3a 85       	ldd	r19, Y+10	; 0x0a
     ad0:	4b 85       	ldd	r20, Y+11	; 0x0b
     ad2:	5c 85       	ldd	r21, Y+12	; 0x0c
     ad4:	c5 01       	movw	r24, r10
     ad6:	b4 01       	movw	r22, r8
     ad8:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     adc:	9b 01       	movw	r18, r22
     ade:	ac 01       	movw	r20, r24
     ae0:	6d 81       	ldd	r22, Y+5	; 0x05
     ae2:	7e 81       	ldd	r23, Y+6	; 0x06
     ae4:	8f 81       	ldd	r24, Y+7	; 0x07
     ae6:	98 85       	ldd	r25, Y+8	; 0x08
     ae8:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     aec:	29 81       	ldd	r18, Y+1	; 0x01
     aee:	3a 81       	ldd	r19, Y+2	; 0x02
     af0:	4b 81       	ldd	r20, Y+3	; 0x03
     af2:	5c 81       	ldd	r21, Y+4	; 0x04
     af4:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <atan2>
     af8:	23 e3       	ldi	r18, 0x33	; 51
     afa:	33 e3       	ldi	r19, 0x33	; 51
     afc:	45 e6       	ldi	r20, 0x65	; 101
     afe:	52 e4       	ldi	r21, 0x42	; 66
     b00:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     b04:	ed 85       	ldd	r30, Y+13	; 0x0d
     b06:	fe 85       	ldd	r31, Y+14	; 0x0e
     b08:	60 87       	std	Z+8, r22	; 0x08
     b0a:	71 87       	std	Z+9, r23	; 0x09
     b0c:	82 87       	std	Z+10, r24	; 0x0a
     b0e:	93 87       	std	Z+11, r25	; 0x0b

	angle[1] = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3; // pitch
     b10:	20 e0       	ldi	r18, 0x00	; 0
     b12:	30 e0       	ldi	r19, 0x00	; 0
     b14:	40 e0       	ldi	r20, 0x00	; 0
     b16:	50 ec       	ldi	r21, 0xC0	; 192
     b18:	c3 01       	movw	r24, r6
     b1a:	b2 01       	movw	r22, r4
     b1c:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     b20:	69 83       	std	Y+1, r22	; 0x01
     b22:	7a 83       	std	Y+2, r23	; 0x02
     b24:	8b 83       	std	Y+3, r24	; 0x03
     b26:	9c 83       	std	Y+4, r25	; 0x04
     b28:	9b 01       	movw	r18, r22
     b2a:	ac 01       	movw	r20, r24
     b2c:	c5 01       	movw	r24, r10
     b2e:	b4 01       	movw	r22, r8
     b30:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     b34:	6d 83       	std	Y+5, r22	; 0x05
     b36:	7e 83       	std	Y+6, r23	; 0x06
     b38:	8f 83       	std	Y+7, r24	; 0x07
     b3a:	98 87       	std	Y+8, r25	; 0x08
     b3c:	29 85       	ldd	r18, Y+9	; 0x09
     b3e:	3a 85       	ldd	r19, Y+10	; 0x0a
     b40:	4b 85       	ldd	r20, Y+11	; 0x0b
     b42:	5c 85       	ldd	r21, Y+12	; 0x0c
     b44:	c7 01       	movw	r24, r14
     b46:	b6 01       	movw	r22, r12
     b48:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     b4c:	9b 01       	movw	r18, r22
     b4e:	ac 01       	movw	r20, r24
     b50:	6d 81       	ldd	r22, Y+5	; 0x05
     b52:	7e 81       	ldd	r23, Y+6	; 0x06
     b54:	8f 81       	ldd	r24, Y+7	; 0x07
     b56:	98 85       	ldd	r25, Y+8	; 0x08
     b58:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     b5c:	0e 94 b0 15 	call	0x2b60	; 0x2b60 <asin>
     b60:	23 e3       	ldi	r18, 0x33	; 51
     b62:	33 e3       	ldi	r19, 0x33	; 51
     b64:	45 e6       	ldi	r20, 0x65	; 101
     b66:	52 e4       	ldi	r21, 0x42	; 66
     b68:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     b6c:	ed 85       	ldd	r30, Y+13	; 0x0d
     b6e:	fe 85       	ldd	r31, Y+14	; 0x0e
     b70:	64 83       	std	Z+4, r22	; 0x04
     b72:	75 83       	std	Z+5, r23	; 0x05
     b74:	86 83       	std	Z+6, r24	; 0x06
     b76:	97 83       	std	Z+7, r25	; 0x07

	angle[0] = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3; // roll
     b78:	a7 01       	movw	r20, r14
     b7a:	96 01       	movw	r18, r12
     b7c:	c7 01       	movw	r24, r14
     b7e:	b6 01       	movw	r22, r12
     b80:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     b84:	6d 83       	std	Y+5, r22	; 0x05
     b86:	7e 83       	std	Y+6, r23	; 0x06
     b88:	8f 83       	std	Y+7, r24	; 0x07
     b8a:	98 87       	std	Y+8, r25	; 0x08
     b8c:	29 81       	ldd	r18, Y+1	; 0x01
     b8e:	3a 81       	ldd	r19, Y+2	; 0x02
     b90:	4b 81       	ldd	r20, Y+3	; 0x03
     b92:	5c 81       	ldd	r21, Y+4	; 0x04
     b94:	c3 01       	movw	r24, r6
     b96:	b2 01       	movw	r22, r4
     b98:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     b9c:	69 83       	std	Y+1, r22	; 0x01
     b9e:	7a 83       	std	Y+2, r23	; 0x02
     ba0:	8b 83       	std	Y+3, r24	; 0x03
     ba2:	9c 83       	std	Y+4, r25	; 0x04
     ba4:	2d 81       	ldd	r18, Y+5	; 0x05
     ba6:	3e 81       	ldd	r19, Y+6	; 0x06
     ba8:	4f 81       	ldd	r20, Y+7	; 0x07
     baa:	58 85       	ldd	r21, Y+8	; 0x08
     bac:	c7 01       	movw	r24, r14
     bae:	b6 01       	movw	r22, r12
     bb0:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     bb4:	9b 01       	movw	r18, r22
     bb6:	ac 01       	movw	r20, r24
     bb8:	69 81       	ldd	r22, Y+1	; 0x01
     bba:	7a 81       	ldd	r23, Y+2	; 0x02
     bbc:	8b 81       	ldd	r24, Y+3	; 0x03
     bbe:	9c 81       	ldd	r25, Y+4	; 0x04
     bc0:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     bc4:	20 e0       	ldi	r18, 0x00	; 0
     bc6:	30 e0       	ldi	r19, 0x00	; 0
     bc8:	40 e8       	ldi	r20, 0x80	; 128
     bca:	5f e3       	ldi	r21, 0x3F	; 63
     bcc:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     bd0:	6b 01       	movw	r12, r22
     bd2:	7c 01       	movw	r14, r24
     bd4:	2d 81       	ldd	r18, Y+5	; 0x05
     bd6:	3e 81       	ldd	r19, Y+6	; 0x06
     bd8:	4f 81       	ldd	r20, Y+7	; 0x07
     bda:	58 85       	ldd	r21, Y+8	; 0x08
     bdc:	c5 01       	movw	r24, r10
     bde:	b4 01       	movw	r22, r8
     be0:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     be4:	4b 01       	movw	r8, r22
     be6:	5c 01       	movw	r10, r24
     be8:	29 85       	ldd	r18, Y+9	; 0x09
     bea:	3a 85       	ldd	r19, Y+10	; 0x0a
     bec:	4b 85       	ldd	r20, Y+11	; 0x0b
     bee:	5c 85       	ldd	r21, Y+12	; 0x0c
     bf0:	c3 01       	movw	r24, r6
     bf2:	b2 01       	movw	r22, r4
     bf4:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     bf8:	9b 01       	movw	r18, r22
     bfa:	ac 01       	movw	r20, r24
     bfc:	c5 01       	movw	r24, r10
     bfe:	b4 01       	movw	r22, r8
     c00:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     c04:	a7 01       	movw	r20, r14
     c06:	96 01       	movw	r18, r12
     c08:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <atan2>
     c0c:	23 e3       	ldi	r18, 0x33	; 51
     c0e:	33 e3       	ldi	r19, 0x33	; 51
     c10:	45 e6       	ldi	r20, 0x65	; 101
     c12:	52 e4       	ldi	r21, 0x42	; 66
     c14:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     c18:	ed 85       	ldd	r30, Y+13	; 0x0d
     c1a:	fe 85       	ldd	r31, Y+14	; 0x0e
     c1c:	60 83       	st	Z, r22
     c1e:	71 83       	std	Z+1, r23	; 0x01
     c20:	82 83       	std	Z+2, r24	; 0x02
     c22:	93 83       	std	Z+3, r25	; 0x03
     c24:	2e 96       	adiw	r28, 0x0e	; 14
     c26:	0f b6       	in	r0, 0x3f	; 63
     c28:	f8 94       	cli
     c2a:	de bf       	out	0x3e, r29	; 62
     c2c:	0f be       	out	0x3f, r0	; 63
     c2e:	cd bf       	out	0x3d, r28	; 61
     c30:	df 91       	pop	r29
     c32:	cf 91       	pop	r28
     c34:	ff 90       	pop	r15
     c36:	ef 90       	pop	r14
     c38:	df 90       	pop	r13
     c3a:	cf 90       	pop	r12
     c3c:	bf 90       	pop	r11
     c3e:	af 90       	pop	r10
     c40:	9f 90       	pop	r9
     c42:	8f 90       	pop	r8
     c44:	7f 90       	pop	r7
     c46:	6f 90       	pop	r6
     c48:	5f 90       	pop	r5
     c4a:	4f 90       	pop	r4
     c4c:	08 95       	ret

00000c4e <MPU_Start_Loc>:
	MPU_Calib(AccData,GyroData);
}

void MPU_Start_Loc(void)
{
	I2C_Start_Wait(MPU6050_addr);								/* I2C start with device write address */
     c4e:	80 ed       	ldi	r24, 0xD0	; 208
     c50:	0e 94 b4 14 	call	0x2968	; 0x2968 <I2C_Start_Wait>
	I2C_Write(0x3B);							/* Write start location address from where to read */
     c54:	8b e3       	ldi	r24, 0x3B	; 59
     c56:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Repeated_Start(0xD1);							/* I2C start with device read address */
     c5a:	81 ed       	ldi	r24, 0xD1	; 209
     c5c:	0e 94 85 14 	call	0x290a	; 0x290a <I2C_Repeated_Start>
     c60:	08 95       	ret

00000c62 <MPU_read>:
}
void MPU_read(float Acc[3], float Gyro[3])
{
     c62:	4f 92       	push	r4
     c64:	5f 92       	push	r5
     c66:	6f 92       	push	r6
     c68:	7f 92       	push	r7
     c6a:	af 92       	push	r10
     c6c:	bf 92       	push	r11
     c6e:	cf 92       	push	r12
     c70:	df 92       	push	r13
     c72:	ef 92       	push	r14
     c74:	ff 92       	push	r15
     c76:	0f 93       	push	r16
     c78:	1f 93       	push	r17
     c7a:	cf 93       	push	r28
     c7c:	df 93       	push	r29
     c7e:	8c 01       	movw	r16, r24
     c80:	eb 01       	movw	r28, r22
	MPU_Start_Loc();									/* Read Gyro values */
     c82:	0e 94 27 06 	call	0xc4e	; 0xc4e <MPU_Start_Loc>
	Acc[0] = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
     c86:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     c8a:	f8 2e       	mov	r15, r24
     c8c:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     c90:	6f 2d       	mov	r22, r15
     c92:	70 e0       	ldi	r23, 0x00	; 0
     c94:	76 2f       	mov	r23, r22
     c96:	66 27       	eor	r22, r22
     c98:	68 2b       	or	r22, r24
     c9a:	07 2e       	mov	r0, r23
     c9c:	00 0c       	add	r0, r0
     c9e:	88 0b       	sbc	r24, r24
     ca0:	99 0b       	sbc	r25, r25
     ca2:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__floatsisf>
     ca6:	f8 01       	movw	r30, r16
     ca8:	60 83       	st	Z, r22
     caa:	71 83       	std	Z+1, r23	; 0x01
     cac:	82 83       	std	Z+2, r24	; 0x02
     cae:	93 83       	std	Z+3, r25	; 0x03
	Acc[1] = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
     cb0:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     cb4:	f8 2e       	mov	r15, r24
     cb6:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     cba:	6f 2d       	mov	r22, r15
     cbc:	70 e0       	ldi	r23, 0x00	; 0
     cbe:	76 2f       	mov	r23, r22
     cc0:	66 27       	eor	r22, r22
     cc2:	68 2b       	or	r22, r24
     cc4:	07 2e       	mov	r0, r23
     cc6:	00 0c       	add	r0, r0
     cc8:	88 0b       	sbc	r24, r24
     cca:	99 0b       	sbc	r25, r25
     ccc:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__floatsisf>
     cd0:	f8 01       	movw	r30, r16
     cd2:	64 83       	std	Z+4, r22	; 0x04
     cd4:	75 83       	std	Z+5, r23	; 0x05
     cd6:	86 83       	std	Z+6, r24	; 0x06
     cd8:	97 83       	std	Z+7, r25	; 0x07
	Acc[2] = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
     cda:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     cde:	f8 2e       	mov	r15, r24
     ce0:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     ce4:	6f 2d       	mov	r22, r15
     ce6:	70 e0       	ldi	r23, 0x00	; 0
     ce8:	76 2f       	mov	r23, r22
     cea:	66 27       	eor	r22, r22
     cec:	68 2b       	or	r22, r24
     cee:	07 2e       	mov	r0, r23
     cf0:	00 0c       	add	r0, r0
     cf2:	88 0b       	sbc	r24, r24
     cf4:	99 0b       	sbc	r25, r25
     cf6:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__floatsisf>
     cfa:	f8 01       	movw	r30, r16
     cfc:	60 87       	std	Z+8, r22	; 0x08
     cfe:	71 87       	std	Z+9, r23	; 0x09
     d00:	82 87       	std	Z+10, r24	; 0x0a
     d02:	93 87       	std	Z+11, r25	; 0x0b
	Temperature = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
     d04:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     d08:	f8 2e       	mov	r15, r24
     d0a:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     d0e:	6f 2d       	mov	r22, r15
     d10:	70 e0       	ldi	r23, 0x00	; 0
     d12:	76 2f       	mov	r23, r22
     d14:	66 27       	eor	r22, r22
     d16:	68 2b       	or	r22, r24
     d18:	07 2e       	mov	r0, r23
     d1a:	00 0c       	add	r0, r0
     d1c:	88 0b       	sbc	r24, r24
     d1e:	99 0b       	sbc	r25, r25
     d20:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__floatsisf>
     d24:	60 93 19 02 	sts	0x0219, r22	; 0x800219 <Temperature>
     d28:	70 93 1a 02 	sts	0x021A, r23	; 0x80021a <Temperature+0x1>
     d2c:	80 93 1b 02 	sts	0x021B, r24	; 0x80021b <Temperature+0x2>
     d30:	90 93 1c 02 	sts	0x021C, r25	; 0x80021c <Temperature+0x3>
	Gyro[0] = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
     d34:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     d38:	f8 2e       	mov	r15, r24
     d3a:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     d3e:	6f 2d       	mov	r22, r15
     d40:	70 e0       	ldi	r23, 0x00	; 0
     d42:	76 2f       	mov	r23, r22
     d44:	66 27       	eor	r22, r22
     d46:	68 2b       	or	r22, r24
     d48:	07 2e       	mov	r0, r23
     d4a:	00 0c       	add	r0, r0
     d4c:	88 0b       	sbc	r24, r24
     d4e:	99 0b       	sbc	r25, r25
     d50:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__floatsisf>
     d54:	68 83       	st	Y, r22
     d56:	79 83       	std	Y+1, r23	; 0x01
     d58:	8a 83       	std	Y+2, r24	; 0x02
     d5a:	9b 83       	std	Y+3, r25	; 0x03
	Gyro[1] = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
     d5c:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     d60:	f8 2e       	mov	r15, r24
     d62:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     d66:	6f 2d       	mov	r22, r15
     d68:	70 e0       	ldi	r23, 0x00	; 0
     d6a:	76 2f       	mov	r23, r22
     d6c:	66 27       	eor	r22, r22
     d6e:	68 2b       	or	r22, r24
     d70:	07 2e       	mov	r0, r23
     d72:	00 0c       	add	r0, r0
     d74:	88 0b       	sbc	r24, r24
     d76:	99 0b       	sbc	r25, r25
     d78:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__floatsisf>
     d7c:	6c 83       	std	Y+4, r22	; 0x04
     d7e:	7d 83       	std	Y+5, r23	; 0x05
     d80:	8e 83       	std	Y+6, r24	; 0x06
     d82:	9f 83       	std	Y+7, r25	; 0x07
	Gyro[2] = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Nack());
     d84:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <I2C_Read_Ack>
     d88:	f8 2e       	mov	r15, r24
     d8a:	0e 94 12 15 	call	0x2a24	; 0x2a24 <I2C_Read_Nack>
     d8e:	6f 2d       	mov	r22, r15
     d90:	70 e0       	ldi	r23, 0x00	; 0
     d92:	76 2f       	mov	r23, r22
     d94:	66 27       	eor	r22, r22
     d96:	68 2b       	or	r22, r24
     d98:	07 2e       	mov	r0, r23
     d9a:	00 0c       	add	r0, r0
     d9c:	88 0b       	sbc	r24, r24
     d9e:	99 0b       	sbc	r25, r25
     da0:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__floatsisf>
     da4:	68 87       	std	Y+8, r22	; 0x08
     da6:	79 87       	std	Y+9, r23	; 0x09
     da8:	8a 87       	std	Y+10, r24	; 0x0a
     daa:	9b 87       	std	Y+11, r25	; 0x0b
	I2C_Stop();
     dac:	0e 94 ab 14 	call	0x2956	; 0x2956 <I2C_Stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     db0:	83 ec       	ldi	r24, 0xC3	; 195
     db2:	99 e0       	ldi	r25, 0x09	; 9
     db4:	01 97       	sbiw	r24, 0x01	; 1
     db6:	f1 f7       	brne	.-4      	; 0xdb4 <MPU_read+0x152>
     db8:	00 c0       	rjmp	.+0      	; 0xdba <MPU_read+0x158>
     dba:	00 00       	nop
     dbc:	0f 2e       	mov	r0, r31
     dbe:	fd e1       	ldi	r31, 0x1D	; 29
     dc0:	ef 2e       	mov	r14, r31
     dc2:	f2 e0       	ldi	r31, 0x02	; 2
     dc4:	ff 2e       	mov	r15, r31
     dc6:	f0 2d       	mov	r31, r0
     dc8:	0f 2e       	mov	r0, r31
     dca:	f9 e2       	ldi	r31, 0x29	; 41
     dcc:	cf 2e       	mov	r12, r31
     dce:	f2 e0       	ldi	r31, 0x02	; 2
     dd0:	df 2e       	mov	r13, r31
     dd2:	f0 2d       	mov	r31, r0
     dd4:	0f 2e       	mov	r0, r31
     dd6:	f9 e2       	ldi	r31, 0x29	; 41
     dd8:	af 2e       	mov	r10, r31
     dda:	f2 e0       	ldi	r31, 0x02	; 2
     ddc:	bf 2e       	mov	r11, r31
     dde:	f0 2d       	mov	r31, r0
	_delay_ms(10);
	//transform the raw data to corresponding range
	for (int i=0;i<3;i++)
	{
		Acc[i] =  Acc[i]*8*9.8/32768 - acc_calib[i]; //range of +- 8g
     de0:	f7 01       	movw	r30, r14
     de2:	41 90       	ld	r4, Z+
     de4:	51 90       	ld	r5, Z+
     de6:	61 90       	ld	r6, Z+
     de8:	71 90       	ld	r7, Z+
     dea:	7f 01       	movw	r14, r30
     dec:	20 e0       	ldi	r18, 0x00	; 0
     dee:	30 e0       	ldi	r19, 0x00	; 0
     df0:	40 e0       	ldi	r20, 0x00	; 0
     df2:	51 e4       	ldi	r21, 0x41	; 65
     df4:	f8 01       	movw	r30, r16
     df6:	60 81       	ld	r22, Z
     df8:	71 81       	ldd	r23, Z+1	; 0x01
     dfa:	82 81       	ldd	r24, Z+2	; 0x02
     dfc:	93 81       	ldd	r25, Z+3	; 0x03
     dfe:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     e02:	2d ec       	ldi	r18, 0xCD	; 205
     e04:	3c ec       	ldi	r19, 0xCC	; 204
     e06:	4c e1       	ldi	r20, 0x1C	; 28
     e08:	51 e4       	ldi	r21, 0x41	; 65
     e0a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     e0e:	20 e0       	ldi	r18, 0x00	; 0
     e10:	30 e0       	ldi	r19, 0x00	; 0
     e12:	40 e0       	ldi	r20, 0x00	; 0
     e14:	58 e3       	ldi	r21, 0x38	; 56
     e16:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     e1a:	a3 01       	movw	r20, r6
     e1c:	92 01       	movw	r18, r4
     e1e:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     e22:	f8 01       	movw	r30, r16
     e24:	61 93       	st	Z+, r22
     e26:	71 93       	st	Z+, r23
     e28:	81 93       	st	Z+, r24
     e2a:	91 93       	st	Z+, r25
     e2c:	8f 01       	movw	r16, r30
		Gyro[i] = Gyro[i]*1000/32768/180*3.14 - gyro_calib[i]; //range of +- 1000 degrees /180*pi 
     e2e:	f6 01       	movw	r30, r12
     e30:	41 90       	ld	r4, Z+
     e32:	51 90       	ld	r5, Z+
     e34:	61 90       	ld	r6, Z+
     e36:	71 90       	ld	r7, Z+
     e38:	6f 01       	movw	r12, r30
     e3a:	20 e0       	ldi	r18, 0x00	; 0
     e3c:	30 e0       	ldi	r19, 0x00	; 0
     e3e:	4a e7       	ldi	r20, 0x7A	; 122
     e40:	54 e4       	ldi	r21, 0x44	; 68
     e42:	68 81       	ld	r22, Y
     e44:	79 81       	ldd	r23, Y+1	; 0x01
     e46:	8a 81       	ldd	r24, Y+2	; 0x02
     e48:	9b 81       	ldd	r25, Y+3	; 0x03
     e4a:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     e4e:	20 e0       	ldi	r18, 0x00	; 0
     e50:	30 e0       	ldi	r19, 0x00	; 0
     e52:	40 e0       	ldi	r20, 0x00	; 0
     e54:	58 e3       	ldi	r21, 0x38	; 56
     e56:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     e5a:	20 e0       	ldi	r18, 0x00	; 0
     e5c:	30 e0       	ldi	r19, 0x00	; 0
     e5e:	44 e3       	ldi	r20, 0x34	; 52
     e60:	53 e4       	ldi	r21, 0x43	; 67
     e62:	0e 94 42 16 	call	0x2c84	; 0x2c84 <__divsf3>
     e66:	23 ec       	ldi	r18, 0xC3	; 195
     e68:	35 ef       	ldi	r19, 0xF5	; 245
     e6a:	48 e4       	ldi	r20, 0x48	; 72
     e6c:	50 e4       	ldi	r21, 0x40	; 64
     e6e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
     e72:	a3 01       	movw	r20, r6
     e74:	92 01       	movw	r18, r4
     e76:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
     e7a:	69 93       	st	Y+, r22
     e7c:	79 93       	st	Y+, r23
     e7e:	89 93       	st	Y+, r24
     e80:	99 93       	st	Y+, r25
	Gyro[1] = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Ack());
	Gyro[2] = (((int)I2C_Read_Ack()<<8) | (int)I2C_Read_Nack());
	I2C_Stop();
	_delay_ms(10);
	//transform the raw data to corresponding range
	for (int i=0;i<3;i++)
     e82:	ea 14       	cp	r14, r10
     e84:	fb 04       	cpc	r15, r11
     e86:	09 f0       	breq	.+2      	; 0xe8a <MPU_read+0x228>
     e88:	ab cf       	rjmp	.-170    	; 0xde0 <MPU_read+0x17e>
	{
		Acc[i] =  Acc[i]*8*9.8/32768 - acc_calib[i]; //range of +- 8g
		Gyro[i] = Gyro[i]*1000/32768/180*3.14 - gyro_calib[i]; //range of +- 1000 degrees /180*pi 
	}
}
     e8a:	df 91       	pop	r29
     e8c:	cf 91       	pop	r28
     e8e:	1f 91       	pop	r17
     e90:	0f 91       	pop	r16
     e92:	ff 90       	pop	r15
     e94:	ef 90       	pop	r14
     e96:	df 90       	pop	r13
     e98:	cf 90       	pop	r12
     e9a:	bf 90       	pop	r11
     e9c:	af 90       	pop	r10
     e9e:	7f 90       	pop	r7
     ea0:	6f 90       	pop	r6
     ea2:	5f 90       	pop	r5
     ea4:	4f 90       	pop	r4
     ea6:	08 95       	ret

00000ea8 <MPU_Calib>:

void MPU_Calib(float Acc[3], float Gyro[3])
{
     ea8:	2f 92       	push	r2
     eaa:	3f 92       	push	r3
     eac:	4f 92       	push	r4
     eae:	5f 92       	push	r5
     eb0:	6f 92       	push	r6
     eb2:	7f 92       	push	r7
     eb4:	8f 92       	push	r8
     eb6:	9f 92       	push	r9
     eb8:	af 92       	push	r10
     eba:	bf 92       	push	r11
     ebc:	cf 92       	push	r12
     ebe:	df 92       	push	r13
     ec0:	ef 92       	push	r14
     ec2:	ff 92       	push	r15
     ec4:	0f 93       	push	r16
     ec6:	1f 93       	push	r17
     ec8:	cf 93       	push	r28
     eca:	df 93       	push	r29
     ecc:	00 d0       	rcall	.+0      	; 0xece <MPU_Calib+0x26>
     ece:	00 d0       	rcall	.+0      	; 0xed0 <MPU_Calib+0x28>
     ed0:	cd b7       	in	r28, 0x3d	; 61
     ed2:	de b7       	in	r29, 0x3e	; 62
     ed4:	1c 01       	movw	r2, r24
     ed6:	69 83       	std	Y+1, r22	; 0x01
     ed8:	7a 83       	std	Y+2, r23	; 0x02
     eda:	81 2c       	mov	r8, r1
     edc:	91 2c       	mov	r9, r1
     ede:	5c 01       	movw	r10, r24
     ee0:	8c e0       	ldi	r24, 0x0C	; 12
     ee2:	a8 0e       	add	r10, r24
     ee4:	b1 1c       	adc	r11, r1
	static float calib_loops = 100;
	static float sum_acc_cal_sum[3]={0,0,0};
	static float sum_gyro_cal_sum[3]={0,0,0};
	for (int i =0;i<calib_loops;i++)
	{ 
		MPU_read(Acc,Gyro);
     ee6:	69 81       	ldd	r22, Y+1	; 0x01
     ee8:	7a 81       	ldd	r23, Y+2	; 0x02
     eea:	c1 01       	movw	r24, r2
     eec:	0e 94 31 06 	call	0xc62	; 0xc62 <MPU_read>
     ef0:	71 01       	movw	r14, r2
     ef2:	0f 2e       	mov	r0, r31
     ef4:	f4 e7       	ldi	r31, 0x74	; 116
     ef6:	6f 2e       	mov	r6, r31
     ef8:	f1 e0       	ldi	r31, 0x01	; 1
     efa:	7f 2e       	mov	r7, r31
     efc:	f0 2d       	mov	r31, r0
     efe:	c9 80       	ldd	r12, Y+1	; 0x01
     f00:	da 80       	ldd	r13, Y+2	; 0x02
     f02:	0f 2e       	mov	r0, r31
     f04:	f8 e6       	ldi	r31, 0x68	; 104
     f06:	4f 2e       	mov	r4, r31
     f08:	f1 e0       	ldi	r31, 0x01	; 1
     f0a:	5f 2e       	mov	r5, r31
     f0c:	f0 2d       	mov	r31, r0
     f0e:	82 01       	movw	r16, r4
     f10:	7c 82       	std	Y+4, r7	; 0x04
     f12:	6b 82       	std	Y+3, r6	; 0x03
		for (int j=0;j<3;j++)
		{
			sum_acc_cal_sum[j] += Acc[j];
     f14:	f7 01       	movw	r30, r14
     f16:	21 91       	ld	r18, Z+
     f18:	31 91       	ld	r19, Z+
     f1a:	41 91       	ld	r20, Z+
     f1c:	51 91       	ld	r21, Z+
     f1e:	7f 01       	movw	r14, r30
     f20:	eb 81       	ldd	r30, Y+3	; 0x03
     f22:	fc 81       	ldd	r31, Y+4	; 0x04
     f24:	60 81       	ld	r22, Z
     f26:	71 81       	ldd	r23, Z+1	; 0x01
     f28:	82 81       	ldd	r24, Z+2	; 0x02
     f2a:	93 81       	ldd	r25, Z+3	; 0x03
     f2c:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     f30:	eb 81       	ldd	r30, Y+3	; 0x03
     f32:	fc 81       	ldd	r31, Y+4	; 0x04
     f34:	61 93       	st	Z+, r22
     f36:	71 93       	st	Z+, r23
     f38:	81 93       	st	Z+, r24
     f3a:	91 93       	st	Z+, r25
     f3c:	fc 83       	std	Y+4, r31	; 0x04
     f3e:	eb 83       	std	Y+3, r30	; 0x03
			sum_gyro_cal_sum[j] += Gyro[j];
     f40:	f6 01       	movw	r30, r12
     f42:	21 91       	ld	r18, Z+
     f44:	31 91       	ld	r19, Z+
     f46:	41 91       	ld	r20, Z+
     f48:	51 91       	ld	r21, Z+
     f4a:	6f 01       	movw	r12, r30
     f4c:	f8 01       	movw	r30, r16
     f4e:	60 81       	ld	r22, Z
     f50:	71 81       	ldd	r23, Z+1	; 0x01
     f52:	82 81       	ldd	r24, Z+2	; 0x02
     f54:	93 81       	ldd	r25, Z+3	; 0x03
     f56:	0e 94 44 15 	call	0x2a88	; 0x2a88 <__addsf3>
     f5a:	f8 01       	movw	r30, r16
     f5c:	61 93       	st	Z+, r22
     f5e:	71 93       	st	Z+, r23
     f60:	81 93       	st	Z+, r24
     f62:	91 93       	st	Z+, r25
     f64:	8f 01       	movw	r16, r30
	static float sum_acc_cal_sum[3]={0,0,0};
	static float sum_gyro_cal_sum[3]={0,0,0};
	for (int i =0;i<calib_loops;i++)
	{ 
		MPU_read(Acc,Gyro);
		for (int j=0;j<3;j++)
     f66:	ea 14       	cp	r14, r10
     f68:	fb 04       	cpc	r15, r11
     f6a:	a1 f6       	brne	.-88     	; 0xf14 <MPU_Calib+0x6c>
void MPU_Calib(float Acc[3], float Gyro[3])
{
	static float calib_loops = 100;
	static float sum_acc_cal_sum[3]={0,0,0};
	static float sum_gyro_cal_sum[3]={0,0,0};
	for (int i =0;i<calib_loops;i++)
     f6c:	ff ef       	ldi	r31, 0xFF	; 255
     f6e:	8f 1a       	sub	r8, r31
     f70:	9f 0a       	sbc	r9, r31
     f72:	84 e6       	ldi	r24, 0x64	; 100
     f74:	88 16       	cp	r8, r24
     f76:	91 04       	cpc	r9, r1
     f78:	09 f0       	breq	.+2      	; 0xf7c <MPU_Calib+0xd4>
     f7a:	b5 cf       	rjmp	.-150    	; 0xee6 <MPU_Calib+0x3e>
     f7c:	0d e1       	ldi	r16, 0x1D	; 29
     f7e:	12 e0       	ldi	r17, 0x02	; 2
     f80:	e9 e2       	ldi	r30, 0x29	; 41
     f82:	f2 e0       	ldi	r31, 0x02	; 2
     f84:	fc 83       	std	Y+4, r31	; 0x04
     f86:	eb 83       	std	Y+3, r30	; 0x03
     f88:	0f 2e       	mov	r0, r31
     f8a:	f0 e8       	ldi	r31, 0x80	; 128
     f8c:	ef 2e       	mov	r14, r31
     f8e:	f1 e0       	ldi	r31, 0x01	; 1
     f90:	ff 2e       	mov	r15, r31
     f92:	f0 2d       	mov	r31, r0
			sum_gyro_cal_sum[j] += Gyro[j];
		}
	}
	for (int j=0;j<3;j++)
	{
		acc_calib[j] =  sum_acc_cal_sum[j]/(float)calib_loops;
     f94:	f3 01       	movw	r30, r6
     f96:	61 91       	ld	r22, Z+
     f98:	71 91       	ld	r23, Z+
     f9a:	81 91       	ld	r24, Z+
     f9c:	91 91       	ld	r25, Z+
     f9e:	3f 01       	movw	r6, r30
     fa0:	20 e0       	ldi	r18, 0x00	; 0
     fa2:	30 e0       	ldi	r19, 0x00	; 0
     fa4:	48 ec       	ldi	r20, 0xC8	; 200
     fa6:	52 e4       	ldi	r21, 0x42	; 66
     fa8:	0e 94 42 16 	call	0x2c84	; 0x2c84 <__divsf3>
     fac:	f8 01       	movw	r30, r16
     fae:	61 93       	st	Z+, r22
     fb0:	71 93       	st	Z+, r23
     fb2:	81 93       	st	Z+, r24
     fb4:	91 93       	st	Z+, r25
     fb6:	8f 01       	movw	r16, r30
		gyro_calib[j] = sum_gyro_cal_sum[j]/(float)calib_loops;
     fb8:	f2 01       	movw	r30, r4
     fba:	61 91       	ld	r22, Z+
     fbc:	71 91       	ld	r23, Z+
     fbe:	81 91       	ld	r24, Z+
     fc0:	91 91       	ld	r25, Z+
     fc2:	2f 01       	movw	r4, r30
     fc4:	20 e0       	ldi	r18, 0x00	; 0
     fc6:	30 e0       	ldi	r19, 0x00	; 0
     fc8:	48 ec       	ldi	r20, 0xC8	; 200
     fca:	52 e4       	ldi	r21, 0x42	; 66
     fcc:	0e 94 42 16 	call	0x2c84	; 0x2c84 <__divsf3>
     fd0:	eb 81       	ldd	r30, Y+3	; 0x03
     fd2:	fc 81       	ldd	r31, Y+4	; 0x04
     fd4:	61 93       	st	Z+, r22
     fd6:	71 93       	st	Z+, r23
     fd8:	81 93       	st	Z+, r24
     fda:	91 93       	st	Z+, r25
     fdc:	fc 83       	std	Y+4, r31	; 0x04
     fde:	eb 83       	std	Y+3, r30	; 0x03
		{
			sum_acc_cal_sum[j] += Acc[j];
			sum_gyro_cal_sum[j] += Gyro[j];
		}
	}
	for (int j=0;j<3;j++)
     fe0:	6e 14       	cp	r6, r14
     fe2:	7f 04       	cpc	r7, r15
     fe4:	b9 f6       	brne	.-82     	; 0xf94 <MPU_Calib+0xec>
	{
		acc_calib[j] =  sum_acc_cal_sum[j]/(float)calib_loops;
		gyro_calib[j] = sum_gyro_cal_sum[j]/(float)calib_loops;
	}
	acc_calib[2] -= 10;
     fe6:	20 e0       	ldi	r18, 0x00	; 0
     fe8:	30 e0       	ldi	r19, 0x00	; 0
     fea:	40 e2       	ldi	r20, 0x20	; 32
     fec:	51 e4       	ldi	r21, 0x41	; 65
     fee:	60 91 25 02 	lds	r22, 0x0225	; 0x800225 <acc_calib+0x8>
     ff2:	70 91 26 02 	lds	r23, 0x0226	; 0x800226 <acc_calib+0x9>
     ff6:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <acc_calib+0xa>
     ffa:	90 91 28 02 	lds	r25, 0x0228	; 0x800228 <acc_calib+0xb>
     ffe:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
    1002:	60 93 25 02 	sts	0x0225, r22	; 0x800225 <acc_calib+0x8>
    1006:	70 93 26 02 	sts	0x0226, r23	; 0x800226 <acc_calib+0x9>
    100a:	80 93 27 02 	sts	0x0227, r24	; 0x800227 <acc_calib+0xa>
    100e:	90 93 28 02 	sts	0x0228, r25	; 0x800228 <acc_calib+0xb>
}
    1012:	0f 90       	pop	r0
    1014:	0f 90       	pop	r0
    1016:	0f 90       	pop	r0
    1018:	0f 90       	pop	r0
    101a:	df 91       	pop	r29
    101c:	cf 91       	pop	r28
    101e:	1f 91       	pop	r17
    1020:	0f 91       	pop	r16
    1022:	ff 90       	pop	r15
    1024:	ef 90       	pop	r14
    1026:	df 90       	pop	r13
    1028:	cf 90       	pop	r12
    102a:	bf 90       	pop	r11
    102c:	af 90       	pop	r10
    102e:	9f 90       	pop	r9
    1030:	8f 90       	pop	r8
    1032:	7f 90       	pop	r7
    1034:	6f 90       	pop	r6
    1036:	5f 90       	pop	r5
    1038:	4f 90       	pop	r4
    103a:	3f 90       	pop	r3
    103c:	2f 90       	pop	r2
    103e:	08 95       	ret

00001040 <MPU_Init>:
    1040:	8b e7       	ldi	r24, 0x7B	; 123
    1042:	92 e9       	ldi	r25, 0x92	; 146
    1044:	01 97       	sbiw	r24, 0x01	; 1
    1046:	f1 f7       	brne	.-4      	; 0x1044 <MPU_Init+0x4>
    1048:	00 c0       	rjmp	.+0      	; 0x104a <MPU_Init+0xa>
    104a:	00 00       	nop
void MPU_Init(void)
{
	//
	_delay_ms(150);										/* Power up time >100ms */
	//0x68
	I2C_Start_Wait(MPU6050_addr);
    104c:	80 ed       	ldi	r24, 0xD0	; 208
    104e:	0e 94 b4 14 	call	0x2968	; 0x2968 <I2C_Start_Wait>
	I2C_Write(0x6B);								/* Write to power management register */
    1052:	8b e6       	ldi	r24, 0x6B	; 107
    1054:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Write(0x01);									//select the clock X-axis 
    1058:	81 e0       	ldi	r24, 0x01	; 1
    105a:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Stop();
    105e:	0e 94 ab 14 	call	0x2956	; 0x2956 <I2C_Stop>

	I2C_Start_Wait(MPU6050_addr);
    1062:	80 ed       	ldi	r24, 0xD0	; 208
    1064:	0e 94 b4 14 	call	0x2968	; 0x2968 <I2C_Start_Wait>
	I2C_Write(0x1A);								//Low pass digital filter
    1068:	8a e1       	ldi	r24, 0x1A	; 26
    106a:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Write(0x05);									
    106e:	85 e0       	ldi	r24, 0x05	; 5
    1070:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Stop();
    1074:	0e 94 ab 14 	call	0x2956	; 0x2956 <I2C_Stop>
	00	+- 250 degrees/s
	01	+- 500 degrees/s
	10	+- 1000 degrees/s
	11	+- 2000 degrees/s
	*/
	I2C_Start_Wait(MPU6050_addr);
    1078:	80 ed       	ldi	r24, 0xD0	; 208
    107a:	0e 94 b4 14 	call	0x2968	; 0x2968 <I2C_Start_Wait>
	I2C_Write(0x1B);			
    107e:	8b e1       	ldi	r24, 0x1B	; 27
    1080:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Write(0x08);
    1084:	88 e0       	ldi	r24, 0x08	; 8
    1086:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Stop();
    108a:	0e 94 ab 14 	call	0x2956	; 0x2956 <I2C_Stop>
	00	+- 2 g
	01	+- 4 g
	10	+- 8 g
	11	+- 16 g
	*/
	I2C_Start_Wait(MPU6050_addr);
    108e:	80 ed       	ldi	r24, 0xD0	; 208
    1090:	0e 94 b4 14 	call	0x2968	; 0x2968 <I2C_Start_Wait>
	I2C_Write(0x1C);
    1094:	8c e1       	ldi	r24, 0x1C	; 28
    1096:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Write(0x10);
    109a:	80 e1       	ldi	r24, 0x10	; 16
    109c:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Stop();
    10a0:	0e 94 ab 14 	call	0x2956	; 0x2956 <I2C_Stop>
	//disable INT 
	I2C_Start_Wait(MPU6050_addr);
    10a4:	80 ed       	ldi	r24, 0xD0	; 208
    10a6:	0e 94 b4 14 	call	0x2968	; 0x2968 <I2C_Start_Wait>
	I2C_Write(0x38);								/* Write to interrupt enable register */
    10aa:	88 e3       	ldi	r24, 0x38	; 56
    10ac:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Write(0x01);
    10b0:	81 e0       	ldi	r24, 0x01	; 1
    10b2:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Stop();
    10b6:	0e 94 ab 14 	call	0x2956	; 0x2956 <I2C_Stop>
	//
	I2C_Start_Wait(0xD0);								/* Start with device write address */
    10ba:	80 ed       	ldi	r24, 0xD0	; 208
    10bc:	0e 94 b4 14 	call	0x2968	; 0x2968 <I2C_Start_Wait>
	I2C_Write(0x19);								/* Write to sample rate register */
    10c0:	89 e1       	ldi	r24, 0x19	; 25
    10c2:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Write(0x07);									/* 1KHz sample rate */
    10c6:	87 e0       	ldi	r24, 0x07	; 7
    10c8:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <I2C_Write>
	I2C_Stop();
    10cc:	0e 94 ab 14 	call	0x2956	; 0x2956 <I2C_Stop>
	
	MPU_Calib(AccData,GyroData);
    10d0:	6a e0       	ldi	r22, 0x0A	; 10
    10d2:	71 e0       	ldi	r23, 0x01	; 1
    10d4:	86 e1       	ldi	r24, 0x16	; 22
    10d6:	91 e0       	ldi	r25, 0x01	; 1
    10d8:	0e 94 54 07 	call	0xea8	; 0xea8 <MPU_Calib>
    10dc:	08 95       	ret

000010de <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10de:	cf 93       	push	r28
    10e0:	df 93       	push	r29
    10e2:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    10e4:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    10e8:	ce 01       	movw	r24, r28
    10ea:	0e 94 9b 18 	call	0x3136	; 0x3136 <malloc>
    10ee:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    10f0:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    10f4:	20 97       	sbiw	r28, 0x00	; 0
    10f6:	11 f4       	brne	.+4      	; 0x10fc <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    10f8:	0e 94 ad 08 	call	0x115a	; 0x115a <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    10fc:	ce 01       	movw	r24, r28
    10fe:	df 91       	pop	r29
    1100:	cf 91       	pop	r28
    1102:	08 95       	ret

00001104 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1104:	cf 93       	push	r28
    1106:	df 93       	push	r29
    if( pv )
    1108:	00 97       	sbiw	r24, 0x00	; 0
    110a:	41 f0       	breq	.+16     	; 0x111c <vPortFree+0x18>
    110c:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    110e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspendAll>
        {
            free( pv );
    1112:	ce 01       	movw	r24, r28
    1114:	0e 94 33 19 	call	0x3266	; 0x3266 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    1118:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    }
}
    111c:	df 91       	pop	r29
    111e:	cf 91       	pop	r28
    1120:	08 95       	ret

00001122 <vApplicationIdleHook>:

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // with 1284p
    DIDR0 = 0xFF;

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino with 328p
    DIDR0 = 0x3F;
    1122:	8f e3       	ldi	r24, 0x3F	; 63
    1124:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__DATA_REGION_ORIGIN__+0x1e>
    // When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
    // This bit can be set at any time to turn off the Analogue Comparator.
    // This will Yellowuce power consumption in Active and Idle mode.
    // When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
    // Otherwise an interrupt can occur when the ACD bit is changed.
    ACSR &= ~_BV(ACIE);
    1128:	80 b7       	in	r24, 0x30	; 48
    112a:	87 7f       	andi	r24, 0xF7	; 247
    112c:	80 bf       	out	0x30, r24	; 48
    ACSR |=  _BV(ACD);
    112e:	80 b7       	in	r24, 0x30	; 48
    1130:	80 68       	ori	r24, 0x80	; 128
    1132:	80 bf       	out	0x30, r24	; 48
    // SLEEP_MODE_PWR_DOWN     _BV(SM1)
    // SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
    // SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
    // SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

    set_sleep_mode( SLEEP_MODE_IDLE );
    1134:	83 b7       	in	r24, 0x33	; 51
    1136:	81 7f       	andi	r24, 0xF1	; 241
    1138:	83 bf       	out	0x33, r24	; 51

    portENTER_CRITICAL();
    113a:	0f b6       	in	r0, 0x3f	; 63
    113c:	f8 94       	cli
    113e:	0f 92       	push	r0
    sleep_enable();
    1140:	83 b7       	in	r24, 0x33	; 51
    1142:	81 60       	ori	r24, 0x01	; 1
    1144:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
    sleep_bod_disable();
    1146:	85 b7       	in	r24, 0x35	; 53
    1148:	80 66       	ori	r24, 0x60	; 96
    114a:	85 bf       	out	0x35, r24	; 53
    114c:	8f 7d       	andi	r24, 0xDF	; 223
    114e:	85 bf       	out	0x35, r24	; 53
#endif

    portEXIT_CRITICAL();
    1150:	0f 90       	pop	r0
    1152:	0f be       	out	0x3f, r0	; 63
    sleep_cpu();            // good night.
    1154:	88 95       	sleep

    sleep_reset();          // reset the sleep_mode() faster than sleep_disable();
    1156:	13 be       	out	0x33, r1	; 51
    1158:	08 95       	ret

0000115a <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (Yellow PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    115a:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (Yellow PB5) LED on. Main LED on.
    115c:	2d 9a       	sbi	0x05, 5	; 5
    115e:	83 ed       	ldi	r24, 0xD3	; 211
    1160:	90 e3       	ldi	r25, 0x30	; 48
    1162:	01 97       	sbiw	r24, 0x01	; 1
    1164:	f1 f7       	brne	.-4      	; 0x1162 <vApplicationMallocFailedHook+0x8>
    1166:	00 c0       	rjmp	.+0      	; 0x1168 <vApplicationMallocFailedHook+0xe>
    1168:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (Yellow PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (Yellow PB5) LED toggle. Main LED fast blink.
    116a:	1d 9a       	sbi	0x03, 5	; 3
    116c:	f8 cf       	rjmp	.-16     	; 0x115e <vApplicationMallocFailedHook+0x4>

0000116e <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (Yellow PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    116e:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (Yellow PB5) LED on. Main LED on.
    1170:	2d 9a       	sbi	0x05, 5	; 5
    1172:	2f e7       	ldi	r18, 0x7F	; 127
    1174:	8a e1       	ldi	r24, 0x1A	; 26
    1176:	96 e0       	ldi	r25, 0x06	; 6
    1178:	21 50       	subi	r18, 0x01	; 1
    117a:	80 40       	sbci	r24, 0x00	; 0
    117c:	90 40       	sbci	r25, 0x00	; 0
    117e:	e1 f7       	brne	.-8      	; 0x1178 <vApplicationStackOverflowHook+0xa>
    1180:	00 c0       	rjmp	.+0      	; 0x1182 <vApplicationStackOverflowHook+0x14>
    1182:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (Yellow PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (Yellow PB5) LED toggle. Main LED slow blink.
    1184:	1d 9a       	sbi	0x03, 5	; 3
    1186:	f5 cf       	rjmp	.-22     	; 0x1172 <vApplicationStackOverflowHook+0x4>

00001188 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1188:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    118a:	03 96       	adiw	r24, 0x03	; 3
    118c:	92 83       	std	Z+2, r25	; 0x02
    118e:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1190:	2f ef       	ldi	r18, 0xFF	; 255
    1192:	3f ef       	ldi	r19, 0xFF	; 255
    1194:	34 83       	std	Z+4, r19	; 0x04
    1196:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1198:	96 83       	std	Z+6, r25	; 0x06
    119a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    119c:	90 87       	std	Z+8, r25	; 0x08
    119e:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    11a0:	10 82       	st	Z, r1
    11a2:	08 95       	ret

000011a4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    11a4:	fc 01       	movw	r30, r24
    11a6:	11 86       	std	Z+9, r1	; 0x09
    11a8:	10 86       	std	Z+8, r1	; 0x08
    11aa:	08 95       	ret

000011ac <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    11ac:	cf 93       	push	r28
    11ae:	df 93       	push	r29
    11b0:	9c 01       	movw	r18, r24
    11b2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    11b4:	dc 01       	movw	r26, r24
    11b6:	11 96       	adiw	r26, 0x01	; 1
    11b8:	cd 91       	ld	r28, X+
    11ba:	dc 91       	ld	r29, X
    11bc:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    11be:	d3 83       	std	Z+3, r29	; 0x03
    11c0:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    11c2:	8c 81       	ldd	r24, Y+4	; 0x04
    11c4:	9d 81       	ldd	r25, Y+5	; 0x05
    11c6:	95 83       	std	Z+5, r25	; 0x05
    11c8:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    11ca:	8c 81       	ldd	r24, Y+4	; 0x04
    11cc:	9d 81       	ldd	r25, Y+5	; 0x05
    11ce:	dc 01       	movw	r26, r24
    11d0:	13 96       	adiw	r26, 0x03	; 3
    11d2:	7c 93       	st	X, r23
    11d4:	6e 93       	st	-X, r22
    11d6:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    11d8:	7d 83       	std	Y+5, r23	; 0x05
    11da:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    11dc:	31 87       	std	Z+9, r19	; 0x09
    11de:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    11e0:	f9 01       	movw	r30, r18
    11e2:	80 81       	ld	r24, Z
    11e4:	8f 5f       	subi	r24, 0xFF	; 255
    11e6:	80 83       	st	Z, r24
}
    11e8:	df 91       	pop	r29
    11ea:	cf 91       	pop	r28
    11ec:	08 95       	ret

000011ee <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    11f4:	48 81       	ld	r20, Y
    11f6:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stoYellow in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    11f8:	4f 3f       	cpi	r20, 0xFF	; 255
    11fa:	2f ef       	ldi	r18, 0xFF	; 255
    11fc:	52 07       	cpc	r21, r18
    11fe:	21 f4       	brne	.+8      	; 0x1208 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1200:	fc 01       	movw	r30, r24
    1202:	a7 81       	ldd	r26, Z+7	; 0x07
    1204:	b0 85       	ldd	r27, Z+8	; 0x08
    1206:	0d c0       	rjmp	.+26     	; 0x1222 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1208:	dc 01       	movw	r26, r24
    120a:	13 96       	adiw	r26, 0x03	; 3
    120c:	01 c0       	rjmp	.+2      	; 0x1210 <vListInsert+0x22>
    120e:	df 01       	movw	r26, r30
    1210:	12 96       	adiw	r26, 0x02	; 2
    1212:	ed 91       	ld	r30, X+
    1214:	fc 91       	ld	r31, X
    1216:	13 97       	sbiw	r26, 0x03	; 3
    1218:	20 81       	ld	r18, Z
    121a:	31 81       	ldd	r19, Z+1	; 0x01
    121c:	42 17       	cp	r20, r18
    121e:	53 07       	cpc	r21, r19
    1220:	b0 f7       	brcc	.-20     	; 0x120e <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1222:	12 96       	adiw	r26, 0x02	; 2
    1224:	ed 91       	ld	r30, X+
    1226:	fc 91       	ld	r31, X
    1228:	13 97       	sbiw	r26, 0x03	; 3
    122a:	fb 83       	std	Y+3, r31	; 0x03
    122c:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    122e:	d5 83       	std	Z+5, r29	; 0x05
    1230:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1232:	bd 83       	std	Y+5, r27	; 0x05
    1234:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1236:	13 96       	adiw	r26, 0x03	; 3
    1238:	dc 93       	st	X, r29
    123a:	ce 93       	st	-X, r28
    123c:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    123e:	99 87       	std	Y+9, r25	; 0x09
    1240:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1242:	fc 01       	movw	r30, r24
    1244:	20 81       	ld	r18, Z
    1246:	2f 5f       	subi	r18, 0xFF	; 255
    1248:	20 83       	st	Z, r18
}
    124a:	df 91       	pop	r29
    124c:	cf 91       	pop	r28
    124e:	08 95       	ret

00001250 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1250:	cf 93       	push	r28
    1252:	df 93       	push	r29
    1254:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1256:	a0 85       	ldd	r26, Z+8	; 0x08
    1258:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    125a:	c2 81       	ldd	r28, Z+2	; 0x02
    125c:	d3 81       	ldd	r29, Z+3	; 0x03
    125e:	84 81       	ldd	r24, Z+4	; 0x04
    1260:	95 81       	ldd	r25, Z+5	; 0x05
    1262:	9d 83       	std	Y+5, r25	; 0x05
    1264:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1266:	c4 81       	ldd	r28, Z+4	; 0x04
    1268:	d5 81       	ldd	r29, Z+5	; 0x05
    126a:	82 81       	ldd	r24, Z+2	; 0x02
    126c:	93 81       	ldd	r25, Z+3	; 0x03
    126e:	9b 83       	std	Y+3, r25	; 0x03
    1270:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1272:	11 96       	adiw	r26, 0x01	; 1
    1274:	8d 91       	ld	r24, X+
    1276:	9c 91       	ld	r25, X
    1278:	12 97       	sbiw	r26, 0x02	; 2
    127a:	e8 17       	cp	r30, r24
    127c:	f9 07       	cpc	r31, r25
    127e:	31 f4       	brne	.+12     	; 0x128c <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1280:	84 81       	ldd	r24, Z+4	; 0x04
    1282:	95 81       	ldd	r25, Z+5	; 0x05
    1284:	12 96       	adiw	r26, 0x02	; 2
    1286:	9c 93       	st	X, r25
    1288:	8e 93       	st	-X, r24
    128a:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    128c:	11 86       	std	Z+9, r1	; 0x09
    128e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1290:	8c 91       	ld	r24, X
    1292:	81 50       	subi	r24, 0x01	; 1
    1294:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1296:	8c 91       	ld	r24, X
}
    1298:	df 91       	pop	r29
    129a:	cf 91       	pop	r28
    129c:	08 95       	ret

0000129e <pxPortInitialiseStack>:
{
    portSAVE_CONTEXT();
    vTaskSwitchContext();
    portRESTORE_CONTEXT();

    __asm__ __volatile__ ( "reti" );
    129e:	fc 01       	movw	r30, r24
    12a0:	60 83       	st	Z, r22
    12a2:	31 97       	sbiw	r30, 0x01	; 1
    12a4:	70 83       	st	Z, r23
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	10 82       	st	Z, r1
    12aa:	31 97       	sbiw	r30, 0x01	; 1
    12ac:	20 e8       	ldi	r18, 0x80	; 128
    12ae:	20 83       	st	Z, r18
    12b0:	31 97       	sbiw	r30, 0x01	; 1
    12b2:	10 82       	st	Z, r1
    12b4:	77 97       	sbiw	r30, 0x17	; 23
    12b6:	40 83       	st	Z, r20
    12b8:	31 97       	sbiw	r30, 0x01	; 1
    12ba:	50 83       	st	Z, r21
    12bc:	83 97       	sbiw	r24, 0x23	; 35
    12be:	08 95       	ret

000012c0 <xPortStartScheduler>:
    12c0:	a8 95       	wdr
    12c2:	90 ec       	ldi	r25, 0xC0	; 192
    12c4:	88 e1       	ldi	r24, 0x18	; 24
    12c6:	0f b6       	in	r0, 0x3f	; 63
    12c8:	f8 94       	cli
    12ca:	a8 95       	wdr
    12cc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    12d0:	0f be       	out	0x3f, r0	; 63
    12d2:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    12d6:	a0 91 e5 01 	lds	r26, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    12da:	b0 91 e6 01 	lds	r27, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    12de:	cd 91       	ld	r28, X+
    12e0:	cd bf       	out	0x3d, r28	; 61
    12e2:	dd 91       	ld	r29, X+
    12e4:	de bf       	out	0x3e, r29	; 62
    12e6:	ff 91       	pop	r31
    12e8:	ef 91       	pop	r30
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	bf 91       	pop	r27
    12f0:	af 91       	pop	r26
    12f2:	9f 91       	pop	r25
    12f4:	8f 91       	pop	r24
    12f6:	7f 91       	pop	r23
    12f8:	6f 91       	pop	r22
    12fa:	5f 91       	pop	r21
    12fc:	4f 91       	pop	r20
    12fe:	3f 91       	pop	r19
    1300:	2f 91       	pop	r18
    1302:	1f 91       	pop	r17
    1304:	0f 91       	pop	r16
    1306:	ff 90       	pop	r15
    1308:	ef 90       	pop	r14
    130a:	df 90       	pop	r13
    130c:	cf 90       	pop	r12
    130e:	bf 90       	pop	r11
    1310:	af 90       	pop	r10
    1312:	9f 90       	pop	r9
    1314:	8f 90       	pop	r8
    1316:	7f 90       	pop	r7
    1318:	6f 90       	pop	r6
    131a:	5f 90       	pop	r5
    131c:	4f 90       	pop	r4
    131e:	3f 90       	pop	r3
    1320:	2f 90       	pop	r2
    1322:	1f 90       	pop	r1
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63
    1328:	0f 90       	pop	r0
    132a:	08 95       	ret
    132c:	81 e0       	ldi	r24, 0x01	; 1
    132e:	08 95       	ret

00001330 <vPortYield>:
    1330:	0f 92       	push	r0
    1332:	0f b6       	in	r0, 0x3f	; 63
    1334:	f8 94       	cli
    1336:	0f 92       	push	r0
    1338:	1f 92       	push	r1
    133a:	11 24       	eor	r1, r1
    133c:	2f 92       	push	r2
    133e:	3f 92       	push	r3
    1340:	4f 92       	push	r4
    1342:	5f 92       	push	r5
    1344:	6f 92       	push	r6
    1346:	7f 92       	push	r7
    1348:	8f 92       	push	r8
    134a:	9f 92       	push	r9
    134c:	af 92       	push	r10
    134e:	bf 92       	push	r11
    1350:	cf 92       	push	r12
    1352:	df 92       	push	r13
    1354:	ef 92       	push	r14
    1356:	ff 92       	push	r15
    1358:	0f 93       	push	r16
    135a:	1f 93       	push	r17
    135c:	2f 93       	push	r18
    135e:	3f 93       	push	r19
    1360:	4f 93       	push	r20
    1362:	5f 93       	push	r21
    1364:	6f 93       	push	r22
    1366:	7f 93       	push	r23
    1368:	8f 93       	push	r24
    136a:	9f 93       	push	r25
    136c:	af 93       	push	r26
    136e:	bf 93       	push	r27
    1370:	cf 93       	push	r28
    1372:	df 93       	push	r29
    1374:	ef 93       	push	r30
    1376:	ff 93       	push	r31
    1378:	a0 91 e5 01 	lds	r26, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    137c:	b0 91 e6 01 	lds	r27, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1380:	0d b6       	in	r0, 0x3d	; 61
    1382:	0d 92       	st	X+, r0
    1384:	0e b6       	in	r0, 0x3e	; 62
    1386:	0d 92       	st	X+, r0
    1388:	0e 94 bd 10 	call	0x217a	; 0x217a <vTaskSwitchContext>
    138c:	a0 91 e5 01 	lds	r26, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1390:	b0 91 e6 01 	lds	r27, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1394:	cd 91       	ld	r28, X+
    1396:	cd bf       	out	0x3d, r28	; 61
    1398:	dd 91       	ld	r29, X+
    139a:	de bf       	out	0x3e, r29	; 62
    139c:	ff 91       	pop	r31
    139e:	ef 91       	pop	r30
    13a0:	df 91       	pop	r29
    13a2:	cf 91       	pop	r28
    13a4:	bf 91       	pop	r27
    13a6:	af 91       	pop	r26
    13a8:	9f 91       	pop	r25
    13aa:	8f 91       	pop	r24
    13ac:	7f 91       	pop	r23
    13ae:	6f 91       	pop	r22
    13b0:	5f 91       	pop	r21
    13b2:	4f 91       	pop	r20
    13b4:	3f 91       	pop	r19
    13b6:	2f 91       	pop	r18
    13b8:	1f 91       	pop	r17
    13ba:	0f 91       	pop	r16
    13bc:	ff 90       	pop	r15
    13be:	ef 90       	pop	r14
    13c0:	df 90       	pop	r13
    13c2:	cf 90       	pop	r12
    13c4:	bf 90       	pop	r11
    13c6:	af 90       	pop	r10
    13c8:	9f 90       	pop	r9
    13ca:	8f 90       	pop	r8
    13cc:	7f 90       	pop	r7
    13ce:	6f 90       	pop	r6
    13d0:	5f 90       	pop	r5
    13d2:	4f 90       	pop	r4
    13d4:	3f 90       	pop	r3
    13d6:	2f 90       	pop	r2
    13d8:	1f 90       	pop	r1
    13da:	0f 90       	pop	r0
    13dc:	0f be       	out	0x3f, r0	; 63
    13de:	0f 90       	pop	r0
    13e0:	08 95       	ret

000013e2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    13e2:	0f 92       	push	r0
    13e4:	0f b6       	in	r0, 0x3f	; 63
    13e6:	f8 94       	cli
    13e8:	0f 92       	push	r0
    13ea:	1f 92       	push	r1
    13ec:	11 24       	eor	r1, r1
    13ee:	2f 92       	push	r2
    13f0:	3f 92       	push	r3
    13f2:	4f 92       	push	r4
    13f4:	5f 92       	push	r5
    13f6:	6f 92       	push	r6
    13f8:	7f 92       	push	r7
    13fa:	8f 92       	push	r8
    13fc:	9f 92       	push	r9
    13fe:	af 92       	push	r10
    1400:	bf 92       	push	r11
    1402:	cf 92       	push	r12
    1404:	df 92       	push	r13
    1406:	ef 92       	push	r14
    1408:	ff 92       	push	r15
    140a:	0f 93       	push	r16
    140c:	1f 93       	push	r17
    140e:	2f 93       	push	r18
    1410:	3f 93       	push	r19
    1412:	4f 93       	push	r20
    1414:	5f 93       	push	r21
    1416:	6f 93       	push	r22
    1418:	7f 93       	push	r23
    141a:	8f 93       	push	r24
    141c:	9f 93       	push	r25
    141e:	af 93       	push	r26
    1420:	bf 93       	push	r27
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	ef 93       	push	r30
    1428:	ff 93       	push	r31
    142a:	a0 91 e5 01 	lds	r26, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    142e:	b0 91 e6 01 	lds	r27, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1432:	0d b6       	in	r0, 0x3d	; 61
    1434:	0d 92       	st	X+, r0
    1436:	0e b6       	in	r0, 0x3e	; 62
    1438:	0d 92       	st	X+, r0
    sleep_reset();        /* reset the sleep_mode() faster than sleep_disable(); */
    143a:	13 be       	out	0x33, r1	; 51
    if( xTaskIncrementTick() != pdFALSE )
    143c:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xTaskIncrementTick>
    1440:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    1442:	0e 94 bd 10 	call	0x217a	; 0x217a <vTaskSwitchContext>
    }
    portRESTORE_CONTEXT();
    1446:	a0 91 e5 01 	lds	r26, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    144a:	b0 91 e6 01 	lds	r27, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    144e:	cd 91       	ld	r28, X+
    1450:	cd bf       	out	0x3d, r28	; 61
    1452:	dd 91       	ld	r29, X+
    1454:	de bf       	out	0x3e, r29	; 62
    1456:	ff 91       	pop	r31
    1458:	ef 91       	pop	r30
    145a:	df 91       	pop	r29
    145c:	cf 91       	pop	r28
    145e:	bf 91       	pop	r27
    1460:	af 91       	pop	r26
    1462:	9f 91       	pop	r25
    1464:	8f 91       	pop	r24
    1466:	7f 91       	pop	r23
    1468:	6f 91       	pop	r22
    146a:	5f 91       	pop	r21
    146c:	4f 91       	pop	r20
    146e:	3f 91       	pop	r19
    1470:	2f 91       	pop	r18
    1472:	1f 91       	pop	r17
    1474:	0f 91       	pop	r16
    1476:	ff 90       	pop	r15
    1478:	ef 90       	pop	r14
    147a:	df 90       	pop	r13
    147c:	cf 90       	pop	r12
    147e:	bf 90       	pop	r11
    1480:	af 90       	pop	r10
    1482:	9f 90       	pop	r9
    1484:	8f 90       	pop	r8
    1486:	7f 90       	pop	r7
    1488:	6f 90       	pop	r6
    148a:	5f 90       	pop	r5
    148c:	4f 90       	pop	r4
    148e:	3f 90       	pop	r3
    1490:	2f 90       	pop	r2
    1492:	1f 90       	pop	r1
    1494:	0f 90       	pop	r0
    1496:	0f be       	out	0x3f, r0	; 63
    1498:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    149a:	08 95       	ret

0000149c <__vector_6>:
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
/*  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
 */
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    149c:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    14a0:	18 95       	reti

000014a2 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    14a2:	0f b6       	in	r0, 0x3f	; 63
    14a4:	f8 94       	cli
    14a6:	0f 92       	push	r0
    14a8:	fc 01       	movw	r30, r24
    14aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    14ac:	0f 90       	pop	r0
    14ae:	0f be       	out	0x3f, r0	; 63
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	91 11       	cpse	r25, r1
    14b4:	80 e0       	ldi	r24, 0x00	; 0
    14b6:	08 95       	ret

000014b8 <prvCopyDataToQueue>:
    14b8:	0f 93       	push	r16
    14ba:	1f 93       	push	r17
    14bc:	cf 93       	push	r28
    14be:	df 93       	push	r29
    14c0:	ec 01       	movw	r28, r24
    14c2:	04 2f       	mov	r16, r20
    14c4:	1a 8d       	ldd	r17, Y+26	; 0x1a
    14c6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    14c8:	41 11       	cpse	r20, r1
    14ca:	0c c0       	rjmp	.+24     	; 0x14e4 <prvCopyDataToQueue+0x2c>
    14cc:	88 81       	ld	r24, Y
    14ce:	99 81       	ldd	r25, Y+1	; 0x01
    14d0:	89 2b       	or	r24, r25
    14d2:	09 f0       	breq	.+2      	; 0x14d6 <prvCopyDataToQueue+0x1e>
    14d4:	42 c0       	rjmp	.+132    	; 0x155a <prvCopyDataToQueue+0xa2>
    14d6:	8c 81       	ldd	r24, Y+4	; 0x04
    14d8:	9d 81       	ldd	r25, Y+5	; 0x05
    14da:	0e 94 04 12 	call	0x2408	; 0x2408 <xTaskPriorityDisinherit>
    14de:	1d 82       	std	Y+5, r1	; 0x05
    14e0:	1c 82       	std	Y+4, r1	; 0x04
    14e2:	42 c0       	rjmp	.+132    	; 0x1568 <prvCopyDataToQueue+0xb0>
    14e4:	01 11       	cpse	r16, r1
    14e6:	17 c0       	rjmp	.+46     	; 0x1516 <prvCopyDataToQueue+0x5e>
    14e8:	50 e0       	ldi	r21, 0x00	; 0
    14ea:	8a 81       	ldd	r24, Y+2	; 0x02
    14ec:	9b 81       	ldd	r25, Y+3	; 0x03
    14ee:	0e 94 bc 19 	call	0x3378	; 0x3378 <memcpy>
    14f2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    14f4:	8a 81       	ldd	r24, Y+2	; 0x02
    14f6:	9b 81       	ldd	r25, Y+3	; 0x03
    14f8:	82 0f       	add	r24, r18
    14fa:	91 1d       	adc	r25, r1
    14fc:	9b 83       	std	Y+3, r25	; 0x03
    14fe:	8a 83       	std	Y+2, r24	; 0x02
    1500:	2c 81       	ldd	r18, Y+4	; 0x04
    1502:	3d 81       	ldd	r19, Y+5	; 0x05
    1504:	82 17       	cp	r24, r18
    1506:	93 07       	cpc	r25, r19
    1508:	50 f1       	brcs	.+84     	; 0x155e <prvCopyDataToQueue+0xa6>
    150a:	88 81       	ld	r24, Y
    150c:	99 81       	ldd	r25, Y+1	; 0x01
    150e:	9b 83       	std	Y+3, r25	; 0x03
    1510:	8a 83       	std	Y+2, r24	; 0x02
    1512:	80 e0       	ldi	r24, 0x00	; 0
    1514:	29 c0       	rjmp	.+82     	; 0x1568 <prvCopyDataToQueue+0xb0>
    1516:	50 e0       	ldi	r21, 0x00	; 0
    1518:	8e 81       	ldd	r24, Y+6	; 0x06
    151a:	9f 81       	ldd	r25, Y+7	; 0x07
    151c:	0e 94 bc 19 	call	0x3378	; 0x3378 <memcpy>
    1520:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	91 95       	neg	r25
    1526:	81 95       	neg	r24
    1528:	91 09       	sbc	r25, r1
    152a:	2e 81       	ldd	r18, Y+6	; 0x06
    152c:	3f 81       	ldd	r19, Y+7	; 0x07
    152e:	28 0f       	add	r18, r24
    1530:	39 1f       	adc	r19, r25
    1532:	3f 83       	std	Y+7, r19	; 0x07
    1534:	2e 83       	std	Y+6, r18	; 0x06
    1536:	48 81       	ld	r20, Y
    1538:	59 81       	ldd	r21, Y+1	; 0x01
    153a:	24 17       	cp	r18, r20
    153c:	35 07       	cpc	r19, r21
    153e:	30 f4       	brcc	.+12     	; 0x154c <prvCopyDataToQueue+0x94>
    1540:	2c 81       	ldd	r18, Y+4	; 0x04
    1542:	3d 81       	ldd	r19, Y+5	; 0x05
    1544:	82 0f       	add	r24, r18
    1546:	93 1f       	adc	r25, r19
    1548:	9f 83       	std	Y+7, r25	; 0x07
    154a:	8e 83       	std	Y+6, r24	; 0x06
    154c:	02 30       	cpi	r16, 0x02	; 2
    154e:	49 f4       	brne	.+18     	; 0x1562 <prvCopyDataToQueue+0xaa>
    1550:	11 23       	and	r17, r17
    1552:	49 f0       	breq	.+18     	; 0x1566 <prvCopyDataToQueue+0xae>
    1554:	11 50       	subi	r17, 0x01	; 1
    1556:	80 e0       	ldi	r24, 0x00	; 0
    1558:	07 c0       	rjmp	.+14     	; 0x1568 <prvCopyDataToQueue+0xb0>
    155a:	80 e0       	ldi	r24, 0x00	; 0
    155c:	05 c0       	rjmp	.+10     	; 0x1568 <prvCopyDataToQueue+0xb0>
    155e:	80 e0       	ldi	r24, 0x00	; 0
    1560:	03 c0       	rjmp	.+6      	; 0x1568 <prvCopyDataToQueue+0xb0>
    1562:	80 e0       	ldi	r24, 0x00	; 0
    1564:	01 c0       	rjmp	.+2      	; 0x1568 <prvCopyDataToQueue+0xb0>
    1566:	80 e0       	ldi	r24, 0x00	; 0
    1568:	1f 5f       	subi	r17, 0xFF	; 255
    156a:	1a 8f       	std	Y+26, r17	; 0x1a
    156c:	df 91       	pop	r29
    156e:	cf 91       	pop	r28
    1570:	1f 91       	pop	r17
    1572:	0f 91       	pop	r16
    1574:	08 95       	ret

00001576 <prvCopyDataFromQueue>:
    1576:	fc 01       	movw	r30, r24
    1578:	44 8d       	ldd	r20, Z+28	; 0x1c
    157a:	44 23       	and	r20, r20
    157c:	a9 f0       	breq	.+42     	; 0x15a8 <prvCopyDataFromQueue+0x32>
    157e:	50 e0       	ldi	r21, 0x00	; 0
    1580:	26 81       	ldd	r18, Z+6	; 0x06
    1582:	37 81       	ldd	r19, Z+7	; 0x07
    1584:	24 0f       	add	r18, r20
    1586:	35 1f       	adc	r19, r21
    1588:	37 83       	std	Z+7, r19	; 0x07
    158a:	26 83       	std	Z+6, r18	; 0x06
    158c:	84 81       	ldd	r24, Z+4	; 0x04
    158e:	95 81       	ldd	r25, Z+5	; 0x05
    1590:	28 17       	cp	r18, r24
    1592:	39 07       	cpc	r19, r25
    1594:	20 f0       	brcs	.+8      	; 0x159e <prvCopyDataFromQueue+0x28>
    1596:	80 81       	ld	r24, Z
    1598:	91 81       	ldd	r25, Z+1	; 0x01
    159a:	97 83       	std	Z+7, r25	; 0x07
    159c:	86 83       	std	Z+6, r24	; 0x06
    159e:	cb 01       	movw	r24, r22
    15a0:	66 81       	ldd	r22, Z+6	; 0x06
    15a2:	77 81       	ldd	r23, Z+7	; 0x07
    15a4:	0e 94 bc 19 	call	0x3378	; 0x3378 <memcpy>
    15a8:	08 95       	ret

000015aa <prvUnlockQueue>:
    15aa:	ef 92       	push	r14
    15ac:	ff 92       	push	r15
    15ae:	0f 93       	push	r16
    15b0:	1f 93       	push	r17
    15b2:	cf 93       	push	r28
    15b4:	8c 01       	movw	r16, r24
    15b6:	0f b6       	in	r0, 0x3f	; 63
    15b8:	f8 94       	cli
    15ba:	0f 92       	push	r0
    15bc:	fc 01       	movw	r30, r24
    15be:	c6 8d       	ldd	r28, Z+30	; 0x1e
    15c0:	1c 16       	cp	r1, r28
    15c2:	ac f4       	brge	.+42     	; 0x15ee <prvUnlockQueue+0x44>
    15c4:	81 89       	ldd	r24, Z+17	; 0x11
    15c6:	81 11       	cpse	r24, r1
    15c8:	06 c0       	rjmp	.+12     	; 0x15d6 <prvUnlockQueue+0x2c>
    15ca:	11 c0       	rjmp	.+34     	; 0x15ee <prvUnlockQueue+0x44>
    15cc:	f8 01       	movw	r30, r16
    15ce:	81 89       	ldd	r24, Z+17	; 0x11
    15d0:	81 11       	cpse	r24, r1
    15d2:	05 c0       	rjmp	.+10     	; 0x15de <prvUnlockQueue+0x34>
    15d4:	0c c0       	rjmp	.+24     	; 0x15ee <prvUnlockQueue+0x44>
    15d6:	78 01       	movw	r14, r16
    15d8:	f1 e1       	ldi	r31, 0x11	; 17
    15da:	ef 0e       	add	r14, r31
    15dc:	f1 1c       	adc	r15, r1
    15de:	c7 01       	movw	r24, r14
    15e0:	0e 94 69 11 	call	0x22d2	; 0x22d2 <xTaskRemoveFromEventList>
    15e4:	81 11       	cpse	r24, r1
    15e6:	0e 94 f2 11 	call	0x23e4	; 0x23e4 <vTaskMissedYield>
    15ea:	c1 50       	subi	r28, 0x01	; 1
    15ec:	79 f7       	brne	.-34     	; 0x15cc <prvUnlockQueue+0x22>
    15ee:	8f ef       	ldi	r24, 0xFF	; 255
    15f0:	f8 01       	movw	r30, r16
    15f2:	86 8f       	std	Z+30, r24	; 0x1e
    15f4:	0f 90       	pop	r0
    15f6:	0f be       	out	0x3f, r0	; 63
    15f8:	0f b6       	in	r0, 0x3f	; 63
    15fa:	f8 94       	cli
    15fc:	0f 92       	push	r0
    15fe:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1600:	1c 16       	cp	r1, r28
    1602:	ac f4       	brge	.+42     	; 0x162e <prvUnlockQueue+0x84>
    1604:	80 85       	ldd	r24, Z+8	; 0x08
    1606:	81 11       	cpse	r24, r1
    1608:	06 c0       	rjmp	.+12     	; 0x1616 <prvUnlockQueue+0x6c>
    160a:	11 c0       	rjmp	.+34     	; 0x162e <prvUnlockQueue+0x84>
    160c:	f8 01       	movw	r30, r16
    160e:	80 85       	ldd	r24, Z+8	; 0x08
    1610:	81 11       	cpse	r24, r1
    1612:	05 c0       	rjmp	.+10     	; 0x161e <prvUnlockQueue+0x74>
    1614:	0c c0       	rjmp	.+24     	; 0x162e <prvUnlockQueue+0x84>
    1616:	78 01       	movw	r14, r16
    1618:	f8 e0       	ldi	r31, 0x08	; 8
    161a:	ef 0e       	add	r14, r31
    161c:	f1 1c       	adc	r15, r1
    161e:	c7 01       	movw	r24, r14
    1620:	0e 94 69 11 	call	0x22d2	; 0x22d2 <xTaskRemoveFromEventList>
    1624:	81 11       	cpse	r24, r1
    1626:	0e 94 f2 11 	call	0x23e4	; 0x23e4 <vTaskMissedYield>
    162a:	c1 50       	subi	r28, 0x01	; 1
    162c:	79 f7       	brne	.-34     	; 0x160c <prvUnlockQueue+0x62>
    162e:	8f ef       	ldi	r24, 0xFF	; 255
    1630:	f8 01       	movw	r30, r16
    1632:	85 8f       	std	Z+29, r24	; 0x1d
    1634:	0f 90       	pop	r0
    1636:	0f be       	out	0x3f, r0	; 63
    1638:	cf 91       	pop	r28
    163a:	1f 91       	pop	r17
    163c:	0f 91       	pop	r16
    163e:	ff 90       	pop	r15
    1640:	ef 90       	pop	r14
    1642:	08 95       	ret

00001644 <xQueueGenericReset>:
    1644:	cf 93       	push	r28
    1646:	df 93       	push	r29
    1648:	ec 01       	movw	r28, r24
    164a:	0f b6       	in	r0, 0x3f	; 63
    164c:	f8 94       	cli
    164e:	0f 92       	push	r0
    1650:	e8 81       	ld	r30, Y
    1652:	f9 81       	ldd	r31, Y+1	; 0x01
    1654:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1656:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1658:	90 e0       	ldi	r25, 0x00	; 0
    165a:	30 e0       	ldi	r19, 0x00	; 0
    165c:	82 9f       	mul	r24, r18
    165e:	a0 01       	movw	r20, r0
    1660:	83 9f       	mul	r24, r19
    1662:	50 0d       	add	r21, r0
    1664:	92 9f       	mul	r25, r18
    1666:	50 0d       	add	r21, r0
    1668:	11 24       	eor	r1, r1
    166a:	4e 0f       	add	r20, r30
    166c:	5f 1f       	adc	r21, r31
    166e:	5d 83       	std	Y+5, r21	; 0x05
    1670:	4c 83       	std	Y+4, r20	; 0x04
    1672:	1a 8e       	std	Y+26, r1	; 0x1a
    1674:	fb 83       	std	Y+3, r31	; 0x03
    1676:	ea 83       	std	Y+2, r30	; 0x02
    1678:	01 97       	sbiw	r24, 0x01	; 1
    167a:	82 9f       	mul	r24, r18
    167c:	a0 01       	movw	r20, r0
    167e:	83 9f       	mul	r24, r19
    1680:	50 0d       	add	r21, r0
    1682:	92 9f       	mul	r25, r18
    1684:	50 0d       	add	r21, r0
    1686:	11 24       	eor	r1, r1
    1688:	cf 01       	movw	r24, r30
    168a:	84 0f       	add	r24, r20
    168c:	95 1f       	adc	r25, r21
    168e:	9f 83       	std	Y+7, r25	; 0x07
    1690:	8e 83       	std	Y+6, r24	; 0x06
    1692:	8f ef       	ldi	r24, 0xFF	; 255
    1694:	8d 8f       	std	Y+29, r24	; 0x1d
    1696:	8e 8f       	std	Y+30, r24	; 0x1e
    1698:	61 11       	cpse	r22, r1
    169a:	0c c0       	rjmp	.+24     	; 0x16b4 <xQueueGenericReset+0x70>
    169c:	88 85       	ldd	r24, Y+8	; 0x08
    169e:	88 23       	and	r24, r24
    16a0:	89 f0       	breq	.+34     	; 0x16c4 <xQueueGenericReset+0x80>
    16a2:	ce 01       	movw	r24, r28
    16a4:	08 96       	adiw	r24, 0x08	; 8
    16a6:	0e 94 69 11 	call	0x22d2	; 0x22d2 <xTaskRemoveFromEventList>
    16aa:	88 23       	and	r24, r24
    16ac:	59 f0       	breq	.+22     	; 0x16c4 <xQueueGenericReset+0x80>
    16ae:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    16b2:	08 c0       	rjmp	.+16     	; 0x16c4 <xQueueGenericReset+0x80>
    16b4:	ce 01       	movw	r24, r28
    16b6:	08 96       	adiw	r24, 0x08	; 8
    16b8:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    16bc:	ce 01       	movw	r24, r28
    16be:	41 96       	adiw	r24, 0x11	; 17
    16c0:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    16c4:	0f 90       	pop	r0
    16c6:	0f be       	out	0x3f, r0	; 63
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	df 91       	pop	r29
    16cc:	cf 91       	pop	r28
    16ce:	08 95       	ret

000016d0 <xQueueGenericCreate>:
    16d0:	0f 93       	push	r16
    16d2:	1f 93       	push	r17
    16d4:	cf 93       	push	r28
    16d6:	df 93       	push	r29
    16d8:	08 2f       	mov	r16, r24
    16da:	16 2f       	mov	r17, r22
    16dc:	86 9f       	mul	r24, r22
    16de:	c0 01       	movw	r24, r0
    16e0:	11 24       	eor	r1, r1
    16e2:	4f 96       	adiw	r24, 0x1f	; 31
    16e4:	0e 94 6f 08 	call	0x10de	; 0x10de <pvPortMalloc>
    16e8:	ec 01       	movw	r28, r24
    16ea:	00 97       	sbiw	r24, 0x00	; 0
    16ec:	71 f0       	breq	.+28     	; 0x170a <xQueueGenericCreate+0x3a>
    16ee:	11 11       	cpse	r17, r1
    16f0:	03 c0       	rjmp	.+6      	; 0x16f8 <xQueueGenericCreate+0x28>
    16f2:	99 83       	std	Y+1, r25	; 0x01
    16f4:	88 83       	st	Y, r24
    16f6:	03 c0       	rjmp	.+6      	; 0x16fe <xQueueGenericCreate+0x2e>
    16f8:	4f 96       	adiw	r24, 0x1f	; 31
    16fa:	99 83       	std	Y+1, r25	; 0x01
    16fc:	88 83       	st	Y, r24
    16fe:	0b 8f       	std	Y+27, r16	; 0x1b
    1700:	1c 8f       	std	Y+28, r17	; 0x1c
    1702:	61 e0       	ldi	r22, 0x01	; 1
    1704:	ce 01       	movw	r24, r28
    1706:	0e 94 22 0b 	call	0x1644	; 0x1644 <xQueueGenericReset>
    170a:	ce 01       	movw	r24, r28
    170c:	df 91       	pop	r29
    170e:	cf 91       	pop	r28
    1710:	1f 91       	pop	r17
    1712:	0f 91       	pop	r16
    1714:	08 95       	ret

00001716 <xQueueGenericSend>:
    1716:	9f 92       	push	r9
    1718:	af 92       	push	r10
    171a:	bf 92       	push	r11
    171c:	cf 92       	push	r12
    171e:	df 92       	push	r13
    1720:	ef 92       	push	r14
    1722:	ff 92       	push	r15
    1724:	0f 93       	push	r16
    1726:	1f 93       	push	r17
    1728:	cf 93       	push	r28
    172a:	df 93       	push	r29
    172c:	00 d0       	rcall	.+0      	; 0x172e <xQueueGenericSend+0x18>
    172e:	00 d0       	rcall	.+0      	; 0x1730 <xQueueGenericSend+0x1a>
    1730:	1f 92       	push	r1
    1732:	cd b7       	in	r28, 0x3d	; 61
    1734:	de b7       	in	r29, 0x3e	; 62
    1736:	8c 01       	movw	r16, r24
    1738:	6b 01       	movw	r12, r22
    173a:	5d 83       	std	Y+5, r21	; 0x05
    173c:	4c 83       	std	Y+4, r20	; 0x04
    173e:	a2 2e       	mov	r10, r18
    1740:	b1 2c       	mov	r11, r1
    1742:	99 24       	eor	r9, r9
    1744:	93 94       	inc	r9
    1746:	7c 01       	movw	r14, r24
    1748:	88 e0       	ldi	r24, 0x08	; 8
    174a:	e8 0e       	add	r14, r24
    174c:	f1 1c       	adc	r15, r1
    174e:	0f b6       	in	r0, 0x3f	; 63
    1750:	f8 94       	cli
    1752:	0f 92       	push	r0
    1754:	f8 01       	movw	r30, r16
    1756:	92 8d       	ldd	r25, Z+26	; 0x1a
    1758:	83 8d       	ldd	r24, Z+27	; 0x1b
    175a:	98 17       	cp	r25, r24
    175c:	18 f0       	brcs	.+6      	; 0x1764 <xQueueGenericSend+0x4e>
    175e:	f2 e0       	ldi	r31, 0x02	; 2
    1760:	af 12       	cpse	r10, r31
    1762:	19 c0       	rjmp	.+50     	; 0x1796 <xQueueGenericSend+0x80>
    1764:	4a 2d       	mov	r20, r10
    1766:	b6 01       	movw	r22, r12
    1768:	c8 01       	movw	r24, r16
    176a:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <prvCopyDataToQueue>
    176e:	f8 01       	movw	r30, r16
    1770:	91 89       	ldd	r25, Z+17	; 0x11
    1772:	99 23       	and	r25, r25
    1774:	49 f0       	breq	.+18     	; 0x1788 <xQueueGenericSend+0x72>
    1776:	c8 01       	movw	r24, r16
    1778:	41 96       	adiw	r24, 0x11	; 17
    177a:	0e 94 69 11 	call	0x22d2	; 0x22d2 <xTaskRemoveFromEventList>
    177e:	88 23       	and	r24, r24
    1780:	31 f0       	breq	.+12     	; 0x178e <xQueueGenericSend+0x78>
    1782:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    1786:	03 c0       	rjmp	.+6      	; 0x178e <xQueueGenericSend+0x78>
    1788:	81 11       	cpse	r24, r1
    178a:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    178e:	0f 90       	pop	r0
    1790:	0f be       	out	0x3f, r0	; 63
    1792:	81 e0       	ldi	r24, 0x01	; 1
    1794:	50 c0       	rjmp	.+160    	; 0x1836 <xQueueGenericSend+0x120>
    1796:	8c 81       	ldd	r24, Y+4	; 0x04
    1798:	9d 81       	ldd	r25, Y+5	; 0x05
    179a:	89 2b       	or	r24, r25
    179c:	21 f4       	brne	.+8      	; 0x17a6 <xQueueGenericSend+0x90>
    179e:	0f 90       	pop	r0
    17a0:	0f be       	out	0x3f, r0	; 63
    17a2:	80 e0       	ldi	r24, 0x00	; 0
    17a4:	48 c0       	rjmp	.+144    	; 0x1836 <xQueueGenericSend+0x120>
    17a6:	b1 10       	cpse	r11, r1
    17a8:	05 c0       	rjmp	.+10     	; 0x17b4 <xQueueGenericSend+0x9e>
    17aa:	ce 01       	movw	r24, r28
    17ac:	01 96       	adiw	r24, 0x01	; 1
    17ae:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskInternalSetTimeOutState>
    17b2:	b9 2c       	mov	r11, r9
    17b4:	0f 90       	pop	r0
    17b6:	0f be       	out	0x3f, r0	; 63
    17b8:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspendAll>
    17bc:	0f b6       	in	r0, 0x3f	; 63
    17be:	f8 94       	cli
    17c0:	0f 92       	push	r0
    17c2:	f8 01       	movw	r30, r16
    17c4:	85 8d       	ldd	r24, Z+29	; 0x1d
    17c6:	8f 3f       	cpi	r24, 0xFF	; 255
    17c8:	09 f4       	brne	.+2      	; 0x17cc <xQueueGenericSend+0xb6>
    17ca:	15 8e       	std	Z+29, r1	; 0x1d
    17cc:	f8 01       	movw	r30, r16
    17ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    17d0:	8f 3f       	cpi	r24, 0xFF	; 255
    17d2:	09 f4       	brne	.+2      	; 0x17d6 <xQueueGenericSend+0xc0>
    17d4:	16 8e       	std	Z+30, r1	; 0x1e
    17d6:	0f 90       	pop	r0
    17d8:	0f be       	out	0x3f, r0	; 63
    17da:	be 01       	movw	r22, r28
    17dc:	6c 5f       	subi	r22, 0xFC	; 252
    17de:	7f 4f       	sbci	r23, 0xFF	; 255
    17e0:	ce 01       	movw	r24, r28
    17e2:	01 96       	adiw	r24, 0x01	; 1
    17e4:	0e 94 bc 11 	call	0x2378	; 0x2378 <xTaskCheckForTimeOut>
    17e8:	81 11       	cpse	r24, r1
    17ea:	1f c0       	rjmp	.+62     	; 0x182a <xQueueGenericSend+0x114>
    17ec:	0f b6       	in	r0, 0x3f	; 63
    17ee:	f8 94       	cli
    17f0:	0f 92       	push	r0
    17f2:	f8 01       	movw	r30, r16
    17f4:	92 8d       	ldd	r25, Z+26	; 0x1a
    17f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    17f8:	0f 90       	pop	r0
    17fa:	0f be       	out	0x3f, r0	; 63
    17fc:	98 13       	cpse	r25, r24
    17fe:	0f c0       	rjmp	.+30     	; 0x181e <xQueueGenericSend+0x108>
    1800:	6c 81       	ldd	r22, Y+4	; 0x04
    1802:	7d 81       	ldd	r23, Y+5	; 0x05
    1804:	c7 01       	movw	r24, r14
    1806:	0e 94 3e 11 	call	0x227c	; 0x227c <vTaskPlaceOnEventList>
    180a:	c8 01       	movw	r24, r16
    180c:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvUnlockQueue>
    1810:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    1814:	81 11       	cpse	r24, r1
    1816:	9b cf       	rjmp	.-202    	; 0x174e <xQueueGenericSend+0x38>
    1818:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    181c:	98 cf       	rjmp	.-208    	; 0x174e <xQueueGenericSend+0x38>
    181e:	c8 01       	movw	r24, r16
    1820:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvUnlockQueue>
    1824:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    1828:	92 cf       	rjmp	.-220    	; 0x174e <xQueueGenericSend+0x38>
    182a:	c8 01       	movw	r24, r16
    182c:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvUnlockQueue>
    1830:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    1834:	80 e0       	ldi	r24, 0x00	; 0
    1836:	0f 90       	pop	r0
    1838:	0f 90       	pop	r0
    183a:	0f 90       	pop	r0
    183c:	0f 90       	pop	r0
    183e:	0f 90       	pop	r0
    1840:	df 91       	pop	r29
    1842:	cf 91       	pop	r28
    1844:	1f 91       	pop	r17
    1846:	0f 91       	pop	r16
    1848:	ff 90       	pop	r15
    184a:	ef 90       	pop	r14
    184c:	df 90       	pop	r13
    184e:	cf 90       	pop	r12
    1850:	bf 90       	pop	r11
    1852:	af 90       	pop	r10
    1854:	9f 90       	pop	r9
    1856:	08 95       	ret

00001858 <xQueueGenericSendFromISR>:
    1858:	ef 92       	push	r14
    185a:	ff 92       	push	r15
    185c:	0f 93       	push	r16
    185e:	1f 93       	push	r17
    1860:	cf 93       	push	r28
    1862:	df 93       	push	r29
    1864:	8a 01       	movw	r16, r20
    1866:	fc 01       	movw	r30, r24
    1868:	52 8d       	ldd	r21, Z+26	; 0x1a
    186a:	33 8d       	ldd	r19, Z+27	; 0x1b
    186c:	53 17       	cp	r21, r19
    186e:	10 f0       	brcs	.+4      	; 0x1874 <xQueueGenericSendFromISR+0x1c>
    1870:	22 30       	cpi	r18, 0x02	; 2
    1872:	01 f5       	brne	.+64     	; 0x18b4 <xQueueGenericSendFromISR+0x5c>
    1874:	42 2f       	mov	r20, r18
    1876:	78 01       	movw	r14, r16
    1878:	ec 01       	movw	r28, r24
    187a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    187c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    187e:	ce 01       	movw	r24, r28
    1880:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <prvCopyDataToQueue>
    1884:	1f 3f       	cpi	r17, 0xFF	; 255
    1886:	81 f4       	brne	.+32     	; 0x18a8 <xQueueGenericSendFromISR+0x50>
    1888:	89 89       	ldd	r24, Y+17	; 0x11
    188a:	88 23       	and	r24, r24
    188c:	a9 f0       	breq	.+42     	; 0x18b8 <xQueueGenericSendFromISR+0x60>
    188e:	ce 01       	movw	r24, r28
    1890:	41 96       	adiw	r24, 0x11	; 17
    1892:	0e 94 69 11 	call	0x22d2	; 0x22d2 <xTaskRemoveFromEventList>
    1896:	88 23       	and	r24, r24
    1898:	89 f0       	breq	.+34     	; 0x18bc <xQueueGenericSendFromISR+0x64>
    189a:	e1 14       	cp	r14, r1
    189c:	f1 04       	cpc	r15, r1
    189e:	81 f0       	breq	.+32     	; 0x18c0 <xQueueGenericSendFromISR+0x68>
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	f7 01       	movw	r30, r14
    18a4:	80 83       	st	Z, r24
    18a6:	0d c0       	rjmp	.+26     	; 0x18c2 <xQueueGenericSendFromISR+0x6a>
    18a8:	ff 24       	eor	r15, r15
    18aa:	f3 94       	inc	r15
    18ac:	f1 0e       	add	r15, r17
    18ae:	fe 8e       	std	Y+30, r15	; 0x1e
    18b0:	81 e0       	ldi	r24, 0x01	; 1
    18b2:	07 c0       	rjmp	.+14     	; 0x18c2 <xQueueGenericSendFromISR+0x6a>
    18b4:	80 e0       	ldi	r24, 0x00	; 0
    18b6:	05 c0       	rjmp	.+10     	; 0x18c2 <xQueueGenericSendFromISR+0x6a>
    18b8:	81 e0       	ldi	r24, 0x01	; 1
    18ba:	03 c0       	rjmp	.+6      	; 0x18c2 <xQueueGenericSendFromISR+0x6a>
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	01 c0       	rjmp	.+2      	; 0x18c2 <xQueueGenericSendFromISR+0x6a>
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	df 91       	pop	r29
    18c4:	cf 91       	pop	r28
    18c6:	1f 91       	pop	r17
    18c8:	0f 91       	pop	r16
    18ca:	ff 90       	pop	r15
    18cc:	ef 90       	pop	r14
    18ce:	08 95       	ret

000018d0 <xQueueReceive>:
    18d0:	9f 92       	push	r9
    18d2:	af 92       	push	r10
    18d4:	bf 92       	push	r11
    18d6:	cf 92       	push	r12
    18d8:	df 92       	push	r13
    18da:	ef 92       	push	r14
    18dc:	ff 92       	push	r15
    18de:	0f 93       	push	r16
    18e0:	1f 93       	push	r17
    18e2:	cf 93       	push	r28
    18e4:	df 93       	push	r29
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <xQueueReceive+0x18>
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <xQueueReceive+0x1a>
    18ea:	1f 92       	push	r1
    18ec:	cd b7       	in	r28, 0x3d	; 61
    18ee:	de b7       	in	r29, 0x3e	; 62
    18f0:	8c 01       	movw	r16, r24
    18f2:	5b 01       	movw	r10, r22
    18f4:	5d 83       	std	Y+5, r21	; 0x05
    18f6:	4c 83       	std	Y+4, r20	; 0x04
    18f8:	e1 2c       	mov	r14, r1
    18fa:	99 24       	eor	r9, r9
    18fc:	93 94       	inc	r9
    18fe:	6c 01       	movw	r12, r24
    1900:	81 e1       	ldi	r24, 0x11	; 17
    1902:	c8 0e       	add	r12, r24
    1904:	d1 1c       	adc	r13, r1
    1906:	0f b6       	in	r0, 0x3f	; 63
    1908:	f8 94       	cli
    190a:	0f 92       	push	r0
    190c:	f8 01       	movw	r30, r16
    190e:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1910:	ff 20       	and	r15, r15
    1912:	a9 f0       	breq	.+42     	; 0x193e <xQueueReceive+0x6e>
    1914:	b5 01       	movw	r22, r10
    1916:	c8 01       	movw	r24, r16
    1918:	0e 94 bb 0a 	call	0x1576	; 0x1576 <prvCopyDataFromQueue>
    191c:	fa 94       	dec	r15
    191e:	f8 01       	movw	r30, r16
    1920:	f2 8e       	std	Z+26, r15	; 0x1a
    1922:	80 85       	ldd	r24, Z+8	; 0x08
    1924:	88 23       	and	r24, r24
    1926:	39 f0       	breq	.+14     	; 0x1936 <xQueueReceive+0x66>
    1928:	c8 01       	movw	r24, r16
    192a:	08 96       	adiw	r24, 0x08	; 8
    192c:	0e 94 69 11 	call	0x22d2	; 0x22d2 <xTaskRemoveFromEventList>
    1930:	81 11       	cpse	r24, r1
    1932:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    1936:	0f 90       	pop	r0
    1938:	0f be       	out	0x3f, r0	; 63
    193a:	81 e0       	ldi	r24, 0x01	; 1
    193c:	51 c0       	rjmp	.+162    	; 0x19e0 <xQueueReceive+0x110>
    193e:	8c 81       	ldd	r24, Y+4	; 0x04
    1940:	9d 81       	ldd	r25, Y+5	; 0x05
    1942:	89 2b       	or	r24, r25
    1944:	21 f4       	brne	.+8      	; 0x194e <xQueueReceive+0x7e>
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63
    194a:	80 e0       	ldi	r24, 0x00	; 0
    194c:	49 c0       	rjmp	.+146    	; 0x19e0 <xQueueReceive+0x110>
    194e:	e1 10       	cpse	r14, r1
    1950:	05 c0       	rjmp	.+10     	; 0x195c <xQueueReceive+0x8c>
    1952:	ce 01       	movw	r24, r28
    1954:	01 96       	adiw	r24, 0x01	; 1
    1956:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskInternalSetTimeOutState>
    195a:	e9 2c       	mov	r14, r9
    195c:	0f 90       	pop	r0
    195e:	0f be       	out	0x3f, r0	; 63
    1960:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspendAll>
    1964:	0f b6       	in	r0, 0x3f	; 63
    1966:	f8 94       	cli
    1968:	0f 92       	push	r0
    196a:	f8 01       	movw	r30, r16
    196c:	85 8d       	ldd	r24, Z+29	; 0x1d
    196e:	8f 3f       	cpi	r24, 0xFF	; 255
    1970:	09 f4       	brne	.+2      	; 0x1974 <xQueueReceive+0xa4>
    1972:	15 8e       	std	Z+29, r1	; 0x1d
    1974:	f8 01       	movw	r30, r16
    1976:	86 8d       	ldd	r24, Z+30	; 0x1e
    1978:	8f 3f       	cpi	r24, 0xFF	; 255
    197a:	09 f4       	brne	.+2      	; 0x197e <xQueueReceive+0xae>
    197c:	16 8e       	std	Z+30, r1	; 0x1e
    197e:	0f 90       	pop	r0
    1980:	0f be       	out	0x3f, r0	; 63
    1982:	be 01       	movw	r22, r28
    1984:	6c 5f       	subi	r22, 0xFC	; 252
    1986:	7f 4f       	sbci	r23, 0xFF	; 255
    1988:	ce 01       	movw	r24, r28
    198a:	01 96       	adiw	r24, 0x01	; 1
    198c:	0e 94 bc 11 	call	0x2378	; 0x2378 <xTaskCheckForTimeOut>
    1990:	81 11       	cpse	r24, r1
    1992:	1a c0       	rjmp	.+52     	; 0x19c8 <xQueueReceive+0xf8>
    1994:	c8 01       	movw	r24, r16
    1996:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <prvIsQueueEmpty>
    199a:	88 23       	and	r24, r24
    199c:	79 f0       	breq	.+30     	; 0x19bc <xQueueReceive+0xec>
    199e:	6c 81       	ldd	r22, Y+4	; 0x04
    19a0:	7d 81       	ldd	r23, Y+5	; 0x05
    19a2:	c6 01       	movw	r24, r12
    19a4:	0e 94 3e 11 	call	0x227c	; 0x227c <vTaskPlaceOnEventList>
    19a8:	c8 01       	movw	r24, r16
    19aa:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvUnlockQueue>
    19ae:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    19b2:	81 11       	cpse	r24, r1
    19b4:	a8 cf       	rjmp	.-176    	; 0x1906 <xQueueReceive+0x36>
    19b6:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    19ba:	a5 cf       	rjmp	.-182    	; 0x1906 <xQueueReceive+0x36>
    19bc:	c8 01       	movw	r24, r16
    19be:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvUnlockQueue>
    19c2:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    19c6:	9f cf       	rjmp	.-194    	; 0x1906 <xQueueReceive+0x36>
    19c8:	c8 01       	movw	r24, r16
    19ca:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvUnlockQueue>
    19ce:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    19d2:	c8 01       	movw	r24, r16
    19d4:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <prvIsQueueEmpty>
    19d8:	88 23       	and	r24, r24
    19da:	09 f4       	brne	.+2      	; 0x19de <xQueueReceive+0x10e>
    19dc:	94 cf       	rjmp	.-216    	; 0x1906 <xQueueReceive+0x36>
    19de:	80 e0       	ldi	r24, 0x00	; 0
    19e0:	0f 90       	pop	r0
    19e2:	0f 90       	pop	r0
    19e4:	0f 90       	pop	r0
    19e6:	0f 90       	pop	r0
    19e8:	0f 90       	pop	r0
    19ea:	df 91       	pop	r29
    19ec:	cf 91       	pop	r28
    19ee:	1f 91       	pop	r17
    19f0:	0f 91       	pop	r16
    19f2:	ff 90       	pop	r15
    19f4:	ef 90       	pop	r14
    19f6:	df 90       	pop	r13
    19f8:	cf 90       	pop	r12
    19fa:	bf 90       	pop	r11
    19fc:	af 90       	pop	r10
    19fe:	9f 90       	pop	r9
    1a00:	08 95       	ret

00001a02 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1a02:	cf 93       	push	r28
    1a04:	df 93       	push	r29
    1a06:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1a08:	0f b6       	in	r0, 0x3f	; 63
    1a0a:	f8 94       	cli
    1a0c:	0f 92       	push	r0
    1a0e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1a10:	8f 3f       	cpi	r24, 0xFF	; 255
    1a12:	09 f4       	brne	.+2      	; 0x1a16 <vQueueWaitForMessageRestricted+0x14>
    1a14:	1d 8e       	std	Y+29, r1	; 0x1d
    1a16:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a18:	8f 3f       	cpi	r24, 0xFF	; 255
    1a1a:	09 f4       	brne	.+2      	; 0x1a1e <vQueueWaitForMessageRestricted+0x1c>
    1a1c:	1e 8e       	std	Y+30, r1	; 0x1e
    1a1e:	0f 90       	pop	r0
    1a20:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1a22:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a24:	81 11       	cpse	r24, r1
    1a26:	04 c0       	rjmp	.+8      	; 0x1a30 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1a28:	ce 01       	movw	r24, r28
    1a2a:	41 96       	adiw	r24, 0x11	; 17
    1a2c:	0e 94 50 11 	call	0x22a0	; 0x22a0 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1a30:	ce 01       	movw	r24, r28
    1a32:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <prvUnlockQueue>
    }
    1a36:	df 91       	pop	r29
    1a38:	cf 91       	pop	r28
    1a3a:	08 95       	ret

00001a3c <prvResetNextTaskUnblockTime>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1a3c:	e0 91 ad 01 	lds	r30, 0x01AD	; 0x8001ad <pxDelayedTaskList>
    1a40:	f0 91 ae 01 	lds	r31, 0x01AE	; 0x8001ae <pxDelayedTaskList+0x1>
    1a44:	80 81       	ld	r24, Z
    1a46:	81 11       	cpse	r24, r1
    1a48:	07 c0       	rjmp	.+14     	; 0x1a58 <prvResetNextTaskUnblockTime+0x1c>
    1a4a:	8f ef       	ldi	r24, 0xFF	; 255
    1a4c:	9f ef       	ldi	r25, 0xFF	; 255
    1a4e:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <xNextTaskUnblockTime+0x1>
    1a52:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <xNextTaskUnblockTime>
    1a56:	08 95       	ret
    1a58:	e0 91 ad 01 	lds	r30, 0x01AD	; 0x8001ad <pxDelayedTaskList>
    1a5c:	f0 91 ae 01 	lds	r31, 0x01AE	; 0x8001ae <pxDelayedTaskList+0x1>
    1a60:	05 80       	ldd	r0, Z+5	; 0x05
    1a62:	f6 81       	ldd	r31, Z+6	; 0x06
    1a64:	e0 2d       	mov	r30, r0
    1a66:	06 80       	ldd	r0, Z+6	; 0x06
    1a68:	f7 81       	ldd	r31, Z+7	; 0x07
    1a6a:	e0 2d       	mov	r30, r0
    1a6c:	82 81       	ldd	r24, Z+2	; 0x02
    1a6e:	93 81       	ldd	r25, Z+3	; 0x03
    1a70:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <xNextTaskUnblockTime+0x1>
    1a74:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <xNextTaskUnblockTime>
    1a78:	08 95       	ret

00001a7a <prvAddCurrentTaskToDelayedList>:
    1a7a:	ff 92       	push	r15
    1a7c:	0f 93       	push	r16
    1a7e:	1f 93       	push	r17
    1a80:	cf 93       	push	r28
    1a82:	df 93       	push	r29
    1a84:	ec 01       	movw	r28, r24
    1a86:	f6 2e       	mov	r15, r22
    1a88:	00 91 8c 01 	lds	r16, 0x018C	; 0x80018c <xTickCount>
    1a8c:	10 91 8d 01 	lds	r17, 0x018D	; 0x80018d <xTickCount+0x1>
    1a90:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1a94:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1a98:	02 96       	adiw	r24, 0x02	; 2
    1a9a:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    1a9e:	cf 3f       	cpi	r28, 0xFF	; 255
    1aa0:	8f ef       	ldi	r24, 0xFF	; 255
    1aa2:	d8 07       	cpc	r29, r24
    1aa4:	69 f4       	brne	.+26     	; 0x1ac0 <prvAddCurrentTaskToDelayedList+0x46>
    1aa6:	ff 20       	and	r15, r15
    1aa8:	59 f0       	breq	.+22     	; 0x1ac0 <prvAddCurrentTaskToDelayedList+0x46>
    1aaa:	60 91 e5 01 	lds	r22, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1aae:	70 91 e6 01 	lds	r23, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1ab2:	6e 5f       	subi	r22, 0xFE	; 254
    1ab4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ab6:	8f e8       	ldi	r24, 0x8F	; 143
    1ab8:	91 e0       	ldi	r25, 0x01	; 1
    1aba:	0e 94 d6 08 	call	0x11ac	; 0x11ac <vListInsertEnd>
    1abe:	2f c0       	rjmp	.+94     	; 0x1b1e <prvAddCurrentTaskToDelayedList+0xa4>
    1ac0:	c0 0f       	add	r28, r16
    1ac2:	d1 1f       	adc	r29, r17
    1ac4:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1ac8:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1acc:	d3 83       	std	Z+3, r29	; 0x03
    1ace:	c2 83       	std	Z+2, r28	; 0x02
    1ad0:	c0 17       	cp	r28, r16
    1ad2:	d1 07       	cpc	r29, r17
    1ad4:	68 f4       	brcc	.+26     	; 0x1af0 <prvAddCurrentTaskToDelayedList+0x76>
    1ad6:	60 91 e5 01 	lds	r22, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1ada:	70 91 e6 01 	lds	r23, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1ade:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <pxOverflowDelayedTaskList>
    1ae2:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <pxOverflowDelayedTaskList+0x1>
    1ae6:	6e 5f       	subi	r22, 0xFE	; 254
    1ae8:	7f 4f       	sbci	r23, 0xFF	; 255
    1aea:	0e 94 f7 08 	call	0x11ee	; 0x11ee <vListInsert>
    1aee:	17 c0       	rjmp	.+46     	; 0x1b1e <prvAddCurrentTaskToDelayedList+0xa4>
    1af0:	60 91 e5 01 	lds	r22, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1af4:	70 91 e6 01 	lds	r23, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1af8:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <pxDelayedTaskList>
    1afc:	90 91 ae 01 	lds	r25, 0x01AE	; 0x8001ae <pxDelayedTaskList+0x1>
    1b00:	6e 5f       	subi	r22, 0xFE	; 254
    1b02:	7f 4f       	sbci	r23, 0xFF	; 255
    1b04:	0e 94 f7 08 	call	0x11ee	; 0x11ee <vListInsert>
    1b08:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <xNextTaskUnblockTime>
    1b0c:	90 91 84 01 	lds	r25, 0x0184	; 0x800184 <xNextTaskUnblockTime+0x1>
    1b10:	c8 17       	cp	r28, r24
    1b12:	d9 07       	cpc	r29, r25
    1b14:	20 f4       	brcc	.+8      	; 0x1b1e <prvAddCurrentTaskToDelayedList+0xa4>
    1b16:	d0 93 84 01 	sts	0x0184, r29	; 0x800184 <xNextTaskUnblockTime+0x1>
    1b1a:	c0 93 83 01 	sts	0x0183, r28	; 0x800183 <xNextTaskUnblockTime>
    1b1e:	df 91       	pop	r29
    1b20:	cf 91       	pop	r28
    1b22:	1f 91       	pop	r17
    1b24:	0f 91       	pop	r16
    1b26:	ff 90       	pop	r15
    1b28:	08 95       	ret

00001b2a <prvIdleTask>:
    1b2a:	09 e9       	ldi	r16, 0x99	; 153
    1b2c:	11 e0       	ldi	r17, 0x01	; 1
    1b2e:	0f 2e       	mov	r0, r31
    1b30:	f1 ec       	ldi	r31, 0xC1	; 193
    1b32:	ef 2e       	mov	r14, r31
    1b34:	f1 e0       	ldi	r31, 0x01	; 1
    1b36:	ff 2e       	mov	r15, r31
    1b38:	f0 2d       	mov	r31, r0
    1b3a:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <uxDeletedTasksWaitingCleanUp>
    1b3e:	88 23       	and	r24, r24
    1b40:	29 f1       	breq	.+74     	; 0x1b8c <prvIdleTask+0x62>
    1b42:	0f b6       	in	r0, 0x3f	; 63
    1b44:	f8 94       	cli
    1b46:	0f 92       	push	r0
    1b48:	d8 01       	movw	r26, r16
    1b4a:	15 96       	adiw	r26, 0x05	; 5
    1b4c:	ed 91       	ld	r30, X+
    1b4e:	fc 91       	ld	r31, X
    1b50:	16 97       	sbiw	r26, 0x06	; 6
    1b52:	c6 81       	ldd	r28, Z+6	; 0x06
    1b54:	d7 81       	ldd	r29, Z+7	; 0x07
    1b56:	ce 01       	movw	r24, r28
    1b58:	02 96       	adiw	r24, 0x02	; 2
    1b5a:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    1b5e:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <uxCurrentNumberOfTasks>
    1b62:	81 50       	subi	r24, 0x01	; 1
    1b64:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxCurrentNumberOfTasks>
    1b68:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <uxDeletedTasksWaitingCleanUp>
    1b6c:	81 50       	subi	r24, 0x01	; 1
    1b6e:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <uxDeletedTasksWaitingCleanUp>
    1b72:	0f 90       	pop	r0
    1b74:	0f be       	out	0x3f, r0	; 63
    1b76:	8f 89       	ldd	r24, Y+23	; 0x17
    1b78:	98 8d       	ldd	r25, Y+24	; 0x18
    1b7a:	0e 94 82 08 	call	0x1104	; 0x1104 <vPortFree>
    1b7e:	ce 01       	movw	r24, r28
    1b80:	0e 94 82 08 	call	0x1104	; 0x1104 <vPortFree>
    1b84:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <uxDeletedTasksWaitingCleanUp>
    1b88:	81 11       	cpse	r24, r1
    1b8a:	db cf       	rjmp	.-74     	; 0x1b42 <prvIdleTask+0x18>
    1b8c:	f7 01       	movw	r30, r14
    1b8e:	80 81       	ld	r24, Z
    1b90:	82 30       	cpi	r24, 0x02	; 2
    1b92:	10 f0       	brcs	.+4      	; 0x1b98 <prvIdleTask+0x6e>
    1b94:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    1b98:	0e 94 91 08 	call	0x1122	; 0x1122 <vApplicationIdleHook>
    1b9c:	ce cf       	rjmp	.-100    	; 0x1b3a <prvIdleTask+0x10>

00001b9e <xTaskCreate>:
    1b9e:	4f 92       	push	r4
    1ba0:	5f 92       	push	r5
    1ba2:	6f 92       	push	r6
    1ba4:	7f 92       	push	r7
    1ba6:	8f 92       	push	r8
    1ba8:	9f 92       	push	r9
    1baa:	af 92       	push	r10
    1bac:	bf 92       	push	r11
    1bae:	cf 92       	push	r12
    1bb0:	df 92       	push	r13
    1bb2:	ef 92       	push	r14
    1bb4:	ff 92       	push	r15
    1bb6:	0f 93       	push	r16
    1bb8:	cf 93       	push	r28
    1bba:	df 93       	push	r29
    1bbc:	4c 01       	movw	r8, r24
    1bbe:	6b 01       	movw	r12, r22
    1bc0:	5a 01       	movw	r10, r20
    1bc2:	29 01       	movw	r4, r18
    1bc4:	ca 01       	movw	r24, r20
    1bc6:	0e 94 6f 08 	call	0x10de	; 0x10de <pvPortMalloc>
    1bca:	3c 01       	movw	r6, r24
    1bcc:	89 2b       	or	r24, r25
    1bce:	09 f4       	brne	.+2      	; 0x1bd2 <xTaskCreate+0x34>
    1bd0:	f1 c0       	rjmp	.+482    	; 0x1db4 <xTaskCreate+0x216>
    1bd2:	88 e2       	ldi	r24, 0x28	; 40
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	0e 94 6f 08 	call	0x10de	; 0x10de <pvPortMalloc>
    1bda:	ec 01       	movw	r28, r24
    1bdc:	89 2b       	or	r24, r25
    1bde:	99 f0       	breq	.+38     	; 0x1c06 <xTaskCreate+0x68>
    1be0:	78 8e       	std	Y+24, r7	; 0x18
    1be2:	6f 8a       	std	Y+23, r6	; 0x17
    1be4:	a5 01       	movw	r20, r10
    1be6:	65 ea       	ldi	r22, 0xA5	; 165
    1be8:	70 e0       	ldi	r23, 0x00	; 0
    1bea:	c3 01       	movw	r24, r6
    1bec:	0e 94 c5 19 	call	0x338a	; 0x338a <memset>
    1bf0:	81 e0       	ldi	r24, 0x01	; 1
    1bf2:	a8 1a       	sub	r10, r24
    1bf4:	b1 08       	sbc	r11, r1
    1bf6:	8f 89       	ldd	r24, Y+23	; 0x17
    1bf8:	98 8d       	ldd	r25, Y+24	; 0x18
    1bfa:	a8 0e       	add	r10, r24
    1bfc:	b9 1e       	adc	r11, r25
    1bfe:	c1 14       	cp	r12, r1
    1c00:	d1 04       	cpc	r13, r1
    1c02:	29 f4       	brne	.+10     	; 0x1c0e <xTaskCreate+0x70>
    1c04:	20 c0       	rjmp	.+64     	; 0x1c46 <xTaskCreate+0xa8>
    1c06:	c3 01       	movw	r24, r6
    1c08:	0e 94 82 08 	call	0x1104	; 0x1104 <vPortFree>
    1c0c:	d3 c0       	rjmp	.+422    	; 0x1db4 <xTaskCreate+0x216>
    1c0e:	d6 01       	movw	r26, r12
    1c10:	8c 91       	ld	r24, X
    1c12:	89 8f       	std	Y+25, r24	; 0x19
    1c14:	8c 91       	ld	r24, X
    1c16:	88 23       	and	r24, r24
    1c18:	a1 f0       	breq	.+40     	; 0x1c42 <xTaskCreate+0xa4>
    1c1a:	ae 01       	movw	r20, r28
    1c1c:	46 5e       	subi	r20, 0xE6	; 230
    1c1e:	5f 4f       	sbci	r21, 0xFF	; 255
    1c20:	f6 01       	movw	r30, r12
    1c22:	31 96       	adiw	r30, 0x01	; 1
    1c24:	b8 e0       	ldi	r27, 0x08	; 8
    1c26:	cb 0e       	add	r12, r27
    1c28:	d1 1c       	adc	r13, r1
    1c2a:	cf 01       	movw	r24, r30
    1c2c:	21 91       	ld	r18, Z+
    1c2e:	da 01       	movw	r26, r20
    1c30:	2d 93       	st	X+, r18
    1c32:	ad 01       	movw	r20, r26
    1c34:	dc 01       	movw	r26, r24
    1c36:	8c 91       	ld	r24, X
    1c38:	88 23       	and	r24, r24
    1c3a:	19 f0       	breq	.+6      	; 0x1c42 <xTaskCreate+0xa4>
    1c3c:	ec 15       	cp	r30, r12
    1c3e:	fd 05       	cpc	r31, r13
    1c40:	a1 f7       	brne	.-24     	; 0x1c2a <xTaskCreate+0x8c>
    1c42:	18 a2       	std	Y+32, r1	; 0x20
    1c44:	01 c0       	rjmp	.+2      	; 0x1c48 <xTaskCreate+0xaa>
    1c46:	19 8e       	std	Y+25, r1	; 0x19
    1c48:	04 30       	cpi	r16, 0x04	; 4
    1c4a:	08 f0       	brcs	.+2      	; 0x1c4e <xTaskCreate+0xb0>
    1c4c:	03 e0       	ldi	r16, 0x03	; 3
    1c4e:	0e 8b       	std	Y+22, r16	; 0x16
    1c50:	09 a3       	std	Y+33, r16	; 0x21
    1c52:	1a a2       	std	Y+34, r1	; 0x22
    1c54:	6e 01       	movw	r12, r28
    1c56:	b2 e0       	ldi	r27, 0x02	; 2
    1c58:	cb 0e       	add	r12, r27
    1c5a:	d1 1c       	adc	r13, r1
    1c5c:	c6 01       	movw	r24, r12
    1c5e:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <vListInitialiseItem>
    1c62:	ce 01       	movw	r24, r28
    1c64:	0c 96       	adiw	r24, 0x0c	; 12
    1c66:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <vListInitialiseItem>
    1c6a:	d9 87       	std	Y+9, r29	; 0x09
    1c6c:	c8 87       	std	Y+8, r28	; 0x08
    1c6e:	84 e0       	ldi	r24, 0x04	; 4
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	80 1b       	sub	r24, r16
    1c74:	91 09       	sbc	r25, r1
    1c76:	9d 87       	std	Y+13, r25	; 0x0d
    1c78:	8c 87       	std	Y+12, r24	; 0x0c
    1c7a:	db 8b       	std	Y+19, r29	; 0x13
    1c7c:	ca 8b       	std	Y+18, r28	; 0x12
    1c7e:	1b a2       	std	Y+35, r1	; 0x23
    1c80:	1c a2       	std	Y+36, r1	; 0x24
    1c82:	1d a2       	std	Y+37, r1	; 0x25
    1c84:	1e a2       	std	Y+38, r1	; 0x26
    1c86:	1f a2       	std	Y+39, r1	; 0x27
    1c88:	a2 01       	movw	r20, r4
    1c8a:	b4 01       	movw	r22, r8
    1c8c:	c5 01       	movw	r24, r10
    1c8e:	0e 94 4f 09 	call	0x129e	; 0x129e <pxPortInitialiseStack>
    1c92:	99 83       	std	Y+1, r25	; 0x01
    1c94:	88 83       	st	Y, r24
    1c96:	e1 14       	cp	r14, r1
    1c98:	f1 04       	cpc	r15, r1
    1c9a:	19 f0       	breq	.+6      	; 0x1ca2 <xTaskCreate+0x104>
    1c9c:	f7 01       	movw	r30, r14
    1c9e:	d1 83       	std	Z+1, r29	; 0x01
    1ca0:	c0 83       	st	Z, r28
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	0f 92       	push	r0
    1ca8:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <uxCurrentNumberOfTasks>
    1cac:	8f 5f       	subi	r24, 0xFF	; 255
    1cae:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxCurrentNumberOfTasks>
    1cb2:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1cb6:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1cba:	89 2b       	or	r24, r25
    1cbc:	d1 f5       	brne	.+116    	; 0x1d32 <xTaskCreate+0x194>
    1cbe:	d0 93 e6 01 	sts	0x01E6, r29	; 0x8001e6 <pxCurrentTCB+0x1>
    1cc2:	c0 93 e5 01 	sts	0x01E5, r28	; 0x8001e5 <pxCurrentTCB>
    1cc6:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <uxCurrentNumberOfTasks>
    1cca:	81 30       	cpi	r24, 0x01	; 1
    1ccc:	09 f0       	breq	.+2      	; 0x1cd0 <xTaskCreate+0x132>
    1cce:	41 c0       	rjmp	.+130    	; 0x1d52 <xTaskCreate+0x1b4>
    1cd0:	81 ec       	ldi	r24, 0xC1	; 193
    1cd2:	91 e0       	ldi	r25, 0x01	; 1
    1cd4:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1cd8:	8a ec       	ldi	r24, 0xCA	; 202
    1cda:	91 e0       	ldi	r25, 0x01	; 1
    1cdc:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1ce0:	83 ed       	ldi	r24, 0xD3	; 211
    1ce2:	91 e0       	ldi	r25, 0x01	; 1
    1ce4:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1ce8:	8c ed       	ldi	r24, 0xDC	; 220
    1cea:	91 e0       	ldi	r25, 0x01	; 1
    1cec:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1cf0:	88 eb       	ldi	r24, 0xB8	; 184
    1cf2:	91 e0       	ldi	r25, 0x01	; 1
    1cf4:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1cf8:	8f ea       	ldi	r24, 0xAF	; 175
    1cfa:	91 e0       	ldi	r25, 0x01	; 1
    1cfc:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1d00:	82 ea       	ldi	r24, 0xA2	; 162
    1d02:	91 e0       	ldi	r25, 0x01	; 1
    1d04:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1d08:	89 e9       	ldi	r24, 0x99	; 153
    1d0a:	91 e0       	ldi	r25, 0x01	; 1
    1d0c:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1d10:	8f e8       	ldi	r24, 0x8F	; 143
    1d12:	91 e0       	ldi	r25, 0x01	; 1
    1d14:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    1d18:	88 eb       	ldi	r24, 0xB8	; 184
    1d1a:	91 e0       	ldi	r25, 0x01	; 1
    1d1c:	90 93 ae 01 	sts	0x01AE, r25	; 0x8001ae <pxDelayedTaskList+0x1>
    1d20:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <pxDelayedTaskList>
    1d24:	8f ea       	ldi	r24, 0xAF	; 175
    1d26:	91 e0       	ldi	r25, 0x01	; 1
    1d28:	90 93 ac 01 	sts	0x01AC, r25	; 0x8001ac <pxOverflowDelayedTaskList+0x1>
    1d2c:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <pxOverflowDelayedTaskList>
    1d30:	10 c0       	rjmp	.+32     	; 0x1d52 <xTaskCreate+0x1b4>
    1d32:	80 91 8a 01 	lds	r24, 0x018A	; 0x80018a <xSchedulerRunning>
    1d36:	81 11       	cpse	r24, r1
    1d38:	0c c0       	rjmp	.+24     	; 0x1d52 <xTaskCreate+0x1b4>
    1d3a:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1d3e:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1d42:	96 89       	ldd	r25, Z+22	; 0x16
    1d44:	8e 89       	ldd	r24, Y+22	; 0x16
    1d46:	89 17       	cp	r24, r25
    1d48:	20 f0       	brcs	.+8      	; 0x1d52 <xTaskCreate+0x1b4>
    1d4a:	d0 93 e6 01 	sts	0x01E6, r29	; 0x8001e6 <pxCurrentTCB+0x1>
    1d4e:	c0 93 e5 01 	sts	0x01E5, r28	; 0x8001e5 <pxCurrentTCB>
    1d52:	80 91 85 01 	lds	r24, 0x0185	; 0x800185 <uxTaskNumber>
    1d56:	8f 5f       	subi	r24, 0xFF	; 255
    1d58:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTaskNumber>
    1d5c:	8e 89       	ldd	r24, Y+22	; 0x16
    1d5e:	90 91 8b 01 	lds	r25, 0x018B	; 0x80018b <uxTopReadyPriority>
    1d62:	98 17       	cp	r25, r24
    1d64:	10 f4       	brcc	.+4      	; 0x1d6a <xTaskCreate+0x1cc>
    1d66:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <uxTopReadyPriority>
    1d6a:	90 e0       	ldi	r25, 0x00	; 0
    1d6c:	9c 01       	movw	r18, r24
    1d6e:	22 0f       	add	r18, r18
    1d70:	33 1f       	adc	r19, r19
    1d72:	22 0f       	add	r18, r18
    1d74:	33 1f       	adc	r19, r19
    1d76:	22 0f       	add	r18, r18
    1d78:	33 1f       	adc	r19, r19
    1d7a:	82 0f       	add	r24, r18
    1d7c:	93 1f       	adc	r25, r19
    1d7e:	b6 01       	movw	r22, r12
    1d80:	8f 53       	subi	r24, 0x3F	; 63
    1d82:	9e 4f       	sbci	r25, 0xFE	; 254
    1d84:	0e 94 d6 08 	call	0x11ac	; 0x11ac <vListInsertEnd>
    1d88:	0f 90       	pop	r0
    1d8a:	0f be       	out	0x3f, r0	; 63
    1d8c:	80 91 8a 01 	lds	r24, 0x018A	; 0x80018a <xSchedulerRunning>
    1d90:	88 23       	and	r24, r24
    1d92:	61 f0       	breq	.+24     	; 0x1dac <xTaskCreate+0x20e>
    1d94:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1d98:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1d9c:	96 89       	ldd	r25, Z+22	; 0x16
    1d9e:	8e 89       	ldd	r24, Y+22	; 0x16
    1da0:	98 17       	cp	r25, r24
    1da2:	30 f4       	brcc	.+12     	; 0x1db0 <xTaskCreate+0x212>
    1da4:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    1da8:	81 e0       	ldi	r24, 0x01	; 1
    1daa:	05 c0       	rjmp	.+10     	; 0x1db6 <xTaskCreate+0x218>
    1dac:	81 e0       	ldi	r24, 0x01	; 1
    1dae:	03 c0       	rjmp	.+6      	; 0x1db6 <xTaskCreate+0x218>
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	01 c0       	rjmp	.+2      	; 0x1db6 <xTaskCreate+0x218>
    1db4:	8f ef       	ldi	r24, 0xFF	; 255
    1db6:	df 91       	pop	r29
    1db8:	cf 91       	pop	r28
    1dba:	0f 91       	pop	r16
    1dbc:	ff 90       	pop	r15
    1dbe:	ef 90       	pop	r14
    1dc0:	df 90       	pop	r13
    1dc2:	cf 90       	pop	r12
    1dc4:	bf 90       	pop	r11
    1dc6:	af 90       	pop	r10
    1dc8:	9f 90       	pop	r9
    1dca:	8f 90       	pop	r8
    1dcc:	7f 90       	pop	r7
    1dce:	6f 90       	pop	r6
    1dd0:	5f 90       	pop	r5
    1dd2:	4f 90       	pop	r4
    1dd4:	08 95       	ret

00001dd6 <vTaskStartScheduler>:
    1dd6:	ef 92       	push	r14
    1dd8:	ff 92       	push	r15
    1dda:	0f 93       	push	r16
    1ddc:	0f 2e       	mov	r0, r31
    1dde:	f1 e8       	ldi	r31, 0x81	; 129
    1de0:	ef 2e       	mov	r14, r31
    1de2:	f1 e0       	ldi	r31, 0x01	; 1
    1de4:	ff 2e       	mov	r15, r31
    1de6:	f0 2d       	mov	r31, r0
    1de8:	00 e0       	ldi	r16, 0x00	; 0
    1dea:	20 e0       	ldi	r18, 0x00	; 0
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	45 e5       	ldi	r20, 0x55	; 85
    1df0:	50 e0       	ldi	r21, 0x00	; 0
    1df2:	62 e4       	ldi	r22, 0x42	; 66
    1df4:	71 e0       	ldi	r23, 0x01	; 1
    1df6:	85 e9       	ldi	r24, 0x95	; 149
    1df8:	9d e0       	ldi	r25, 0x0D	; 13
    1dfa:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <xTaskCreate>
    1dfe:	81 30       	cpi	r24, 0x01	; 1
    1e00:	a1 f4       	brne	.+40     	; 0x1e2a <vTaskStartScheduler+0x54>
    1e02:	0e 94 9c 12 	call	0x2538	; 0x2538 <xTimerCreateTimerTask>
    1e06:	81 30       	cpi	r24, 0x01	; 1
    1e08:	81 f4       	brne	.+32     	; 0x1e2a <vTaskStartScheduler+0x54>
    1e0a:	f8 94       	cli
    1e0c:	8f ef       	ldi	r24, 0xFF	; 255
    1e0e:	9f ef       	ldi	r25, 0xFF	; 255
    1e10:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <xNextTaskUnblockTime+0x1>
    1e14:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <xNextTaskUnblockTime>
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	80 93 8a 01 	sts	0x018A, r24	; 0x80018a <xSchedulerRunning>
    1e1e:	10 92 8d 01 	sts	0x018D, r1	; 0x80018d <xTickCount+0x1>
    1e22:	10 92 8c 01 	sts	0x018C, r1	; 0x80018c <xTickCount>
    1e26:	0e 94 60 09 	call	0x12c0	; 0x12c0 <xPortStartScheduler>
    1e2a:	0f 91       	pop	r16
    1e2c:	ff 90       	pop	r15
    1e2e:	ef 90       	pop	r14
    1e30:	08 95       	ret

00001e32 <vTaskSuspendAll>:
    1e32:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxSchedulerSuspended>
    1e36:	8f 5f       	subi	r24, 0xFF	; 255
    1e38:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <uxSchedulerSuspended>
    1e3c:	08 95       	ret

00001e3e <xTaskGetTickCount>:
    1e3e:	0f b6       	in	r0, 0x3f	; 63
    1e40:	f8 94       	cli
    1e42:	0f 92       	push	r0
    1e44:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xTickCount>
    1e48:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xTickCount+0x1>
    1e4c:	0f 90       	pop	r0
    1e4e:	0f be       	out	0x3f, r0	; 63
    1e50:	08 95       	ret

00001e52 <xTaskIncrementTick>:
    1e52:	cf 92       	push	r12
    1e54:	df 92       	push	r13
    1e56:	ef 92       	push	r14
    1e58:	ff 92       	push	r15
    1e5a:	0f 93       	push	r16
    1e5c:	1f 93       	push	r17
    1e5e:	cf 93       	push	r28
    1e60:	df 93       	push	r29
    1e62:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxSchedulerSuspended>
    1e66:	81 11       	cpse	r24, r1
    1e68:	9f c0       	rjmp	.+318    	; 0x1fa8 <xTaskIncrementTick+0x156>
    1e6a:	e0 90 8c 01 	lds	r14, 0x018C	; 0x80018c <xTickCount>
    1e6e:	f0 90 8d 01 	lds	r15, 0x018D	; 0x80018d <xTickCount+0x1>
    1e72:	8f ef       	ldi	r24, 0xFF	; 255
    1e74:	e8 1a       	sub	r14, r24
    1e76:	f8 0a       	sbc	r15, r24
    1e78:	f0 92 8d 01 	sts	0x018D, r15	; 0x80018d <xTickCount+0x1>
    1e7c:	e0 92 8c 01 	sts	0x018C, r14	; 0x80018c <xTickCount>
    1e80:	e1 14       	cp	r14, r1
    1e82:	f1 04       	cpc	r15, r1
    1e84:	b9 f4       	brne	.+46     	; 0x1eb4 <xTaskIncrementTick+0x62>
    1e86:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <pxDelayedTaskList>
    1e8a:	90 91 ae 01 	lds	r25, 0x01AE	; 0x8001ae <pxDelayedTaskList+0x1>
    1e8e:	20 91 ab 01 	lds	r18, 0x01AB	; 0x8001ab <pxOverflowDelayedTaskList>
    1e92:	30 91 ac 01 	lds	r19, 0x01AC	; 0x8001ac <pxOverflowDelayedTaskList+0x1>
    1e96:	30 93 ae 01 	sts	0x01AE, r19	; 0x8001ae <pxDelayedTaskList+0x1>
    1e9a:	20 93 ad 01 	sts	0x01AD, r18	; 0x8001ad <pxDelayedTaskList>
    1e9e:	90 93 ac 01 	sts	0x01AC, r25	; 0x8001ac <pxOverflowDelayedTaskList+0x1>
    1ea2:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <pxOverflowDelayedTaskList>
    1ea6:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <xNumOfOverflows>
    1eaa:	8f 5f       	subi	r24, 0xFF	; 255
    1eac:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <xNumOfOverflows>
    1eb0:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <prvResetNextTaskUnblockTime>
    1eb4:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <xNextTaskUnblockTime>
    1eb8:	90 91 84 01 	lds	r25, 0x0184	; 0x800184 <xNextTaskUnblockTime+0x1>
    1ebc:	e8 16       	cp	r14, r24
    1ebe:	f9 06       	cpc	r15, r25
    1ec0:	10 f4       	brcc	.+4      	; 0x1ec6 <xTaskIncrementTick+0x74>
    1ec2:	d1 2c       	mov	r13, r1
    1ec4:	53 c0       	rjmp	.+166    	; 0x1f6c <xTaskIncrementTick+0x11a>
    1ec6:	d1 2c       	mov	r13, r1
    1ec8:	cc 24       	eor	r12, r12
    1eca:	c3 94       	inc	r12
    1ecc:	e0 91 ad 01 	lds	r30, 0x01AD	; 0x8001ad <pxDelayedTaskList>
    1ed0:	f0 91 ae 01 	lds	r31, 0x01AE	; 0x8001ae <pxDelayedTaskList+0x1>
    1ed4:	80 81       	ld	r24, Z
    1ed6:	81 11       	cpse	r24, r1
    1ed8:	07 c0       	rjmp	.+14     	; 0x1ee8 <xTaskIncrementTick+0x96>
    1eda:	8f ef       	ldi	r24, 0xFF	; 255
    1edc:	9f ef       	ldi	r25, 0xFF	; 255
    1ede:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <xNextTaskUnblockTime+0x1>
    1ee2:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <xNextTaskUnblockTime>
    1ee6:	42 c0       	rjmp	.+132    	; 0x1f6c <xTaskIncrementTick+0x11a>
    1ee8:	e0 91 ad 01 	lds	r30, 0x01AD	; 0x8001ad <pxDelayedTaskList>
    1eec:	f0 91 ae 01 	lds	r31, 0x01AE	; 0x8001ae <pxDelayedTaskList+0x1>
    1ef0:	05 80       	ldd	r0, Z+5	; 0x05
    1ef2:	f6 81       	ldd	r31, Z+6	; 0x06
    1ef4:	e0 2d       	mov	r30, r0
    1ef6:	c6 81       	ldd	r28, Z+6	; 0x06
    1ef8:	d7 81       	ldd	r29, Z+7	; 0x07
    1efa:	8a 81       	ldd	r24, Y+2	; 0x02
    1efc:	9b 81       	ldd	r25, Y+3	; 0x03
    1efe:	e8 16       	cp	r14, r24
    1f00:	f9 06       	cpc	r15, r25
    1f02:	28 f4       	brcc	.+10     	; 0x1f0e <xTaskIncrementTick+0xbc>
    1f04:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <xNextTaskUnblockTime+0x1>
    1f08:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <xNextTaskUnblockTime>
    1f0c:	2f c0       	rjmp	.+94     	; 0x1f6c <xTaskIncrementTick+0x11a>
    1f0e:	8e 01       	movw	r16, r28
    1f10:	0e 5f       	subi	r16, 0xFE	; 254
    1f12:	1f 4f       	sbci	r17, 0xFF	; 255
    1f14:	c8 01       	movw	r24, r16
    1f16:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    1f1a:	8c 89       	ldd	r24, Y+20	; 0x14
    1f1c:	9d 89       	ldd	r25, Y+21	; 0x15
    1f1e:	89 2b       	or	r24, r25
    1f20:	21 f0       	breq	.+8      	; 0x1f2a <xTaskIncrementTick+0xd8>
    1f22:	ce 01       	movw	r24, r28
    1f24:	0c 96       	adiw	r24, 0x0c	; 12
    1f26:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    1f2a:	8e 89       	ldd	r24, Y+22	; 0x16
    1f2c:	90 91 8b 01 	lds	r25, 0x018B	; 0x80018b <uxTopReadyPriority>
    1f30:	98 17       	cp	r25, r24
    1f32:	10 f4       	brcc	.+4      	; 0x1f38 <xTaskIncrementTick+0xe6>
    1f34:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <uxTopReadyPriority>
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	9c 01       	movw	r18, r24
    1f3c:	22 0f       	add	r18, r18
    1f3e:	33 1f       	adc	r19, r19
    1f40:	22 0f       	add	r18, r18
    1f42:	33 1f       	adc	r19, r19
    1f44:	22 0f       	add	r18, r18
    1f46:	33 1f       	adc	r19, r19
    1f48:	82 0f       	add	r24, r18
    1f4a:	93 1f       	adc	r25, r19
    1f4c:	b8 01       	movw	r22, r16
    1f4e:	8f 53       	subi	r24, 0x3F	; 63
    1f50:	9e 4f       	sbci	r25, 0xFE	; 254
    1f52:	0e 94 d6 08 	call	0x11ac	; 0x11ac <vListInsertEnd>
    1f56:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1f5a:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1f5e:	9e 89       	ldd	r25, Y+22	; 0x16
    1f60:	86 89       	ldd	r24, Z+22	; 0x16
    1f62:	98 17       	cp	r25, r24
    1f64:	08 f4       	brcc	.+2      	; 0x1f68 <xTaskIncrementTick+0x116>
    1f66:	b2 cf       	rjmp	.-156    	; 0x1ecc <xTaskIncrementTick+0x7a>
    1f68:	dc 2c       	mov	r13, r12
    1f6a:	b0 cf       	rjmp	.-160    	; 0x1ecc <xTaskIncrementTick+0x7a>
    1f6c:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    1f70:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    1f74:	86 89       	ldd	r24, Z+22	; 0x16
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	fc 01       	movw	r30, r24
    1f7a:	ee 0f       	add	r30, r30
    1f7c:	ff 1f       	adc	r31, r31
    1f7e:	ee 0f       	add	r30, r30
    1f80:	ff 1f       	adc	r31, r31
    1f82:	ee 0f       	add	r30, r30
    1f84:	ff 1f       	adc	r31, r31
    1f86:	8e 0f       	add	r24, r30
    1f88:	9f 1f       	adc	r25, r31
    1f8a:	fc 01       	movw	r30, r24
    1f8c:	ef 53       	subi	r30, 0x3F	; 63
    1f8e:	fe 4f       	sbci	r31, 0xFE	; 254
    1f90:	80 81       	ld	r24, Z
    1f92:	82 30       	cpi	r24, 0x02	; 2
    1f94:	10 f0       	brcs	.+4      	; 0x1f9a <xTaskIncrementTick+0x148>
    1f96:	dd 24       	eor	r13, r13
    1f98:	d3 94       	inc	r13
    1f9a:	80 91 87 01 	lds	r24, 0x0187	; 0x800187 <xYieldPending>
    1f9e:	88 23       	and	r24, r24
    1fa0:	69 f0       	breq	.+26     	; 0x1fbc <xTaskIncrementTick+0x16a>
    1fa2:	dd 24       	eor	r13, r13
    1fa4:	d3 94       	inc	r13
    1fa6:	0a c0       	rjmp	.+20     	; 0x1fbc <xTaskIncrementTick+0x16a>
    1fa8:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <xPendedTicks>
    1fac:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <xPendedTicks+0x1>
    1fb0:	01 96       	adiw	r24, 0x01	; 1
    1fb2:	90 93 89 01 	sts	0x0189, r25	; 0x800189 <xPendedTicks+0x1>
    1fb6:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <xPendedTicks>
    1fba:	d1 2c       	mov	r13, r1
    1fbc:	8d 2d       	mov	r24, r13
    1fbe:	df 91       	pop	r29
    1fc0:	cf 91       	pop	r28
    1fc2:	1f 91       	pop	r17
    1fc4:	0f 91       	pop	r16
    1fc6:	ff 90       	pop	r15
    1fc8:	ef 90       	pop	r14
    1fca:	df 90       	pop	r13
    1fcc:	cf 90       	pop	r12
    1fce:	08 95       	ret

00001fd0 <xTaskResumeAll>:
    1fd0:	df 92       	push	r13
    1fd2:	ef 92       	push	r14
    1fd4:	ff 92       	push	r15
    1fd6:	0f 93       	push	r16
    1fd8:	1f 93       	push	r17
    1fda:	cf 93       	push	r28
    1fdc:	df 93       	push	r29
    1fde:	0f b6       	in	r0, 0x3f	; 63
    1fe0:	f8 94       	cli
    1fe2:	0f 92       	push	r0
    1fe4:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxSchedulerSuspended>
    1fe8:	81 50       	subi	r24, 0x01	; 1
    1fea:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <uxSchedulerSuspended>
    1fee:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxSchedulerSuspended>
    1ff2:	81 11       	cpse	r24, r1
    1ff4:	63 c0       	rjmp	.+198    	; 0x20bc <xTaskResumeAll+0xec>
    1ff6:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <uxCurrentNumberOfTasks>
    1ffa:	81 11       	cpse	r24, r1
    1ffc:	33 c0       	rjmp	.+102    	; 0x2064 <xTaskResumeAll+0x94>
    1ffe:	61 c0       	rjmp	.+194    	; 0x20c2 <xTaskResumeAll+0xf2>
    2000:	d7 01       	movw	r26, r14
    2002:	15 96       	adiw	r26, 0x05	; 5
    2004:	ed 91       	ld	r30, X+
    2006:	fc 91       	ld	r31, X
    2008:	16 97       	sbiw	r26, 0x06	; 6
    200a:	c6 81       	ldd	r28, Z+6	; 0x06
    200c:	d7 81       	ldd	r29, Z+7	; 0x07
    200e:	ce 01       	movw	r24, r28
    2010:	0c 96       	adiw	r24, 0x0c	; 12
    2012:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    2016:	8e 01       	movw	r16, r28
    2018:	0e 5f       	subi	r16, 0xFE	; 254
    201a:	1f 4f       	sbci	r17, 0xFF	; 255
    201c:	c8 01       	movw	r24, r16
    201e:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    2022:	8e 89       	ldd	r24, Y+22	; 0x16
    2024:	90 91 8b 01 	lds	r25, 0x018B	; 0x80018b <uxTopReadyPriority>
    2028:	98 17       	cp	r25, r24
    202a:	10 f4       	brcc	.+4      	; 0x2030 <xTaskResumeAll+0x60>
    202c:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <uxTopReadyPriority>
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	9c 01       	movw	r18, r24
    2034:	22 0f       	add	r18, r18
    2036:	33 1f       	adc	r19, r19
    2038:	22 0f       	add	r18, r18
    203a:	33 1f       	adc	r19, r19
    203c:	22 0f       	add	r18, r18
    203e:	33 1f       	adc	r19, r19
    2040:	82 0f       	add	r24, r18
    2042:	93 1f       	adc	r25, r19
    2044:	b8 01       	movw	r22, r16
    2046:	8f 53       	subi	r24, 0x3F	; 63
    2048:	9e 4f       	sbci	r25, 0xFE	; 254
    204a:	0e 94 d6 08 	call	0x11ac	; 0x11ac <vListInsertEnd>
    204e:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    2052:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    2056:	9e 89       	ldd	r25, Y+22	; 0x16
    2058:	86 89       	ldd	r24, Z+22	; 0x16
    205a:	98 17       	cp	r25, r24
    205c:	68 f0       	brcs	.+26     	; 0x2078 <xTaskResumeAll+0xa8>
    205e:	d0 92 87 01 	sts	0x0187, r13	; 0x800187 <xYieldPending>
    2062:	0a c0       	rjmp	.+20     	; 0x2078 <xTaskResumeAll+0xa8>
    2064:	c0 e0       	ldi	r28, 0x00	; 0
    2066:	d0 e0       	ldi	r29, 0x00	; 0
    2068:	0f 2e       	mov	r0, r31
    206a:	f2 ea       	ldi	r31, 0xA2	; 162
    206c:	ef 2e       	mov	r14, r31
    206e:	f1 e0       	ldi	r31, 0x01	; 1
    2070:	ff 2e       	mov	r15, r31
    2072:	f0 2d       	mov	r31, r0
    2074:	dd 24       	eor	r13, r13
    2076:	d3 94       	inc	r13
    2078:	f7 01       	movw	r30, r14
    207a:	80 81       	ld	r24, Z
    207c:	81 11       	cpse	r24, r1
    207e:	c0 cf       	rjmp	.-128    	; 0x2000 <xTaskResumeAll+0x30>
    2080:	cd 2b       	or	r28, r29
    2082:	11 f0       	breq	.+4      	; 0x2088 <xTaskResumeAll+0xb8>
    2084:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <prvResetNextTaskUnblockTime>
    2088:	c0 91 88 01 	lds	r28, 0x0188	; 0x800188 <xPendedTicks>
    208c:	d0 91 89 01 	lds	r29, 0x0189	; 0x800189 <xPendedTicks+0x1>
    2090:	20 97       	sbiw	r28, 0x00	; 0
    2092:	61 f0       	breq	.+24     	; 0x20ac <xTaskResumeAll+0xdc>
    2094:	11 e0       	ldi	r17, 0x01	; 1
    2096:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xTaskIncrementTick>
    209a:	81 11       	cpse	r24, r1
    209c:	10 93 87 01 	sts	0x0187, r17	; 0x800187 <xYieldPending>
    20a0:	21 97       	sbiw	r28, 0x01	; 1
    20a2:	c9 f7       	brne	.-14     	; 0x2096 <xTaskResumeAll+0xc6>
    20a4:	10 92 89 01 	sts	0x0189, r1	; 0x800189 <xPendedTicks+0x1>
    20a8:	10 92 88 01 	sts	0x0188, r1	; 0x800188 <xPendedTicks>
    20ac:	80 91 87 01 	lds	r24, 0x0187	; 0x800187 <xYieldPending>
    20b0:	88 23       	and	r24, r24
    20b2:	31 f0       	breq	.+12     	; 0x20c0 <xTaskResumeAll+0xf0>
    20b4:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    20b8:	81 e0       	ldi	r24, 0x01	; 1
    20ba:	03 c0       	rjmp	.+6      	; 0x20c2 <xTaskResumeAll+0xf2>
    20bc:	80 e0       	ldi	r24, 0x00	; 0
    20be:	01 c0       	rjmp	.+2      	; 0x20c2 <xTaskResumeAll+0xf2>
    20c0:	80 e0       	ldi	r24, 0x00	; 0
    20c2:	0f 90       	pop	r0
    20c4:	0f be       	out	0x3f, r0	; 63
    20c6:	df 91       	pop	r29
    20c8:	cf 91       	pop	r28
    20ca:	1f 91       	pop	r17
    20cc:	0f 91       	pop	r16
    20ce:	ff 90       	pop	r15
    20d0:	ef 90       	pop	r14
    20d2:	df 90       	pop	r13
    20d4:	08 95       	ret

000020d6 <vTaskDelayUntil>:
    20d6:	0f 93       	push	r16
    20d8:	1f 93       	push	r17
    20da:	cf 93       	push	r28
    20dc:	df 93       	push	r29
    20de:	8c 01       	movw	r16, r24
    20e0:	eb 01       	movw	r28, r22
    20e2:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspendAll>
    20e6:	40 91 8c 01 	lds	r20, 0x018C	; 0x80018c <xTickCount>
    20ea:	50 91 8d 01 	lds	r21, 0x018D	; 0x80018d <xTickCount+0x1>
    20ee:	f8 01       	movw	r30, r16
    20f0:	20 81       	ld	r18, Z
    20f2:	31 81       	ldd	r19, Z+1	; 0x01
    20f4:	c9 01       	movw	r24, r18
    20f6:	8c 0f       	add	r24, r28
    20f8:	9d 1f       	adc	r25, r29
    20fa:	42 17       	cp	r20, r18
    20fc:	53 07       	cpc	r21, r19
    20fe:	48 f4       	brcc	.+18     	; 0x2112 <vTaskDelayUntil+0x3c>
    2100:	82 17       	cp	r24, r18
    2102:	93 07       	cpc	r25, r19
    2104:	e8 f4       	brcc	.+58     	; 0x2140 <vTaskDelayUntil+0x6a>
    2106:	91 83       	std	Z+1, r25	; 0x01
    2108:	80 83       	st	Z, r24
    210a:	48 17       	cp	r20, r24
    210c:	59 07       	cpc	r21, r25
    210e:	68 f4       	brcc	.+26     	; 0x212a <vTaskDelayUntil+0x54>
    2110:	07 c0       	rjmp	.+14     	; 0x2120 <vTaskDelayUntil+0x4a>
    2112:	82 17       	cp	r24, r18
    2114:	93 07       	cpc	r25, r19
    2116:	80 f0       	brcs	.+32     	; 0x2138 <vTaskDelayUntil+0x62>
    2118:	48 17       	cp	r20, r24
    211a:	59 07       	cpc	r21, r25
    211c:	68 f0       	brcs	.+26     	; 0x2138 <vTaskDelayUntil+0x62>
    211e:	10 c0       	rjmp	.+32     	; 0x2140 <vTaskDelayUntil+0x6a>
    2120:	60 e0       	ldi	r22, 0x00	; 0
    2122:	84 1b       	sub	r24, r20
    2124:	95 0b       	sbc	r25, r21
    2126:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <prvAddCurrentTaskToDelayedList>
    212a:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    212e:	81 11       	cpse	r24, r1
    2130:	0b c0       	rjmp	.+22     	; 0x2148 <vTaskDelayUntil+0x72>
    2132:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    2136:	08 c0       	rjmp	.+16     	; 0x2148 <vTaskDelayUntil+0x72>
    2138:	f8 01       	movw	r30, r16
    213a:	91 83       	std	Z+1, r25	; 0x01
    213c:	80 83       	st	Z, r24
    213e:	f0 cf       	rjmp	.-32     	; 0x2120 <vTaskDelayUntil+0x4a>
    2140:	f8 01       	movw	r30, r16
    2142:	91 83       	std	Z+1, r25	; 0x01
    2144:	80 83       	st	Z, r24
    2146:	f1 cf       	rjmp	.-30     	; 0x212a <vTaskDelayUntil+0x54>
    2148:	df 91       	pop	r29
    214a:	cf 91       	pop	r28
    214c:	1f 91       	pop	r17
    214e:	0f 91       	pop	r16
    2150:	08 95       	ret

00002152 <vTaskDelay>:
    2152:	cf 93       	push	r28
    2154:	df 93       	push	r29
    2156:	ec 01       	movw	r28, r24
    2158:	89 2b       	or	r24, r25
    215a:	51 f0       	breq	.+20     	; 0x2170 <vTaskDelay+0x1e>
    215c:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspendAll>
    2160:	60 e0       	ldi	r22, 0x00	; 0
    2162:	ce 01       	movw	r24, r28
    2164:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <prvAddCurrentTaskToDelayedList>
    2168:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    216c:	81 11       	cpse	r24, r1
    216e:	02 c0       	rjmp	.+4      	; 0x2174 <vTaskDelay+0x22>
    2170:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    2174:	df 91       	pop	r29
    2176:	cf 91       	pop	r28
    2178:	08 95       	ret

0000217a <vTaskSwitchContext>:
    217a:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxSchedulerSuspended>
    217e:	88 23       	and	r24, r24
    2180:	21 f0       	breq	.+8      	; 0x218a <vTaskSwitchContext+0x10>
    2182:	81 e0       	ldi	r24, 0x01	; 1
    2184:	80 93 87 01 	sts	0x0187, r24	; 0x800187 <xYieldPending>
    2188:	08 95       	ret
    218a:	10 92 87 01 	sts	0x0187, r1	; 0x800187 <xYieldPending>
    218e:	a0 91 e5 01 	lds	r26, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    2192:	b0 91 e6 01 	lds	r27, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    2196:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    219a:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    219e:	2d 91       	ld	r18, X+
    21a0:	3c 91       	ld	r19, X
    21a2:	87 89       	ldd	r24, Z+23	; 0x17
    21a4:	90 8d       	ldd	r25, Z+24	; 0x18
    21a6:	82 17       	cp	r24, r18
    21a8:	93 07       	cpc	r25, r19
    21aa:	60 f0       	brcs	.+24     	; 0x21c4 <vTaskSwitchContext+0x4a>
    21ac:	60 91 e5 01 	lds	r22, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    21b0:	70 91 e6 01 	lds	r23, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    21b4:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    21b8:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    21bc:	67 5e       	subi	r22, 0xE7	; 231
    21be:	7f 4f       	sbci	r23, 0xFF	; 255
    21c0:	0e 94 b7 08 	call	0x116e	; 0x116e <vApplicationStackOverflowHook>
    21c4:	20 91 8b 01 	lds	r18, 0x018B	; 0x80018b <uxTopReadyPriority>
    21c8:	82 2f       	mov	r24, r18
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	fc 01       	movw	r30, r24
    21ce:	ee 0f       	add	r30, r30
    21d0:	ff 1f       	adc	r31, r31
    21d2:	ee 0f       	add	r30, r30
    21d4:	ff 1f       	adc	r31, r31
    21d6:	ee 0f       	add	r30, r30
    21d8:	ff 1f       	adc	r31, r31
    21da:	e8 0f       	add	r30, r24
    21dc:	f9 1f       	adc	r31, r25
    21de:	ef 53       	subi	r30, 0x3F	; 63
    21e0:	fe 4f       	sbci	r31, 0xFE	; 254
    21e2:	30 81       	ld	r19, Z
    21e4:	31 11       	cpse	r19, r1
    21e6:	11 c0       	rjmp	.+34     	; 0x220a <vTaskSwitchContext+0x90>
    21e8:	21 50       	subi	r18, 0x01	; 1
    21ea:	82 2f       	mov	r24, r18
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	fc 01       	movw	r30, r24
    21f0:	ee 0f       	add	r30, r30
    21f2:	ff 1f       	adc	r31, r31
    21f4:	ee 0f       	add	r30, r30
    21f6:	ff 1f       	adc	r31, r31
    21f8:	ee 0f       	add	r30, r30
    21fa:	ff 1f       	adc	r31, r31
    21fc:	e8 0f       	add	r30, r24
    21fe:	f9 1f       	adc	r31, r25
    2200:	ef 53       	subi	r30, 0x3F	; 63
    2202:	fe 4f       	sbci	r31, 0xFE	; 254
    2204:	30 81       	ld	r19, Z
    2206:	33 23       	and	r19, r19
    2208:	79 f3       	breq	.-34     	; 0x21e8 <vTaskSwitchContext+0x6e>
    220a:	ac 01       	movw	r20, r24
    220c:	44 0f       	add	r20, r20
    220e:	55 1f       	adc	r21, r21
    2210:	44 0f       	add	r20, r20
    2212:	55 1f       	adc	r21, r21
    2214:	44 0f       	add	r20, r20
    2216:	55 1f       	adc	r21, r21
    2218:	48 0f       	add	r20, r24
    221a:	59 1f       	adc	r21, r25
    221c:	da 01       	movw	r26, r20
    221e:	af 53       	subi	r26, 0x3F	; 63
    2220:	be 4f       	sbci	r27, 0xFE	; 254
    2222:	11 96       	adiw	r26, 0x01	; 1
    2224:	ed 91       	ld	r30, X+
    2226:	fc 91       	ld	r31, X
    2228:	12 97       	sbiw	r26, 0x02	; 2
    222a:	02 80       	ldd	r0, Z+2	; 0x02
    222c:	f3 81       	ldd	r31, Z+3	; 0x03
    222e:	e0 2d       	mov	r30, r0
    2230:	12 96       	adiw	r26, 0x02	; 2
    2232:	fc 93       	st	X, r31
    2234:	ee 93       	st	-X, r30
    2236:	11 97       	sbiw	r26, 0x01	; 1
    2238:	4c 53       	subi	r20, 0x3C	; 60
    223a:	5e 4f       	sbci	r21, 0xFE	; 254
    223c:	e4 17       	cp	r30, r20
    223e:	f5 07       	cpc	r31, r21
    2240:	29 f4       	brne	.+10     	; 0x224c <vTaskSwitchContext+0xd2>
    2242:	42 81       	ldd	r20, Z+2	; 0x02
    2244:	53 81       	ldd	r21, Z+3	; 0x03
    2246:	fd 01       	movw	r30, r26
    2248:	52 83       	std	Z+2, r21	; 0x02
    224a:	41 83       	std	Z+1, r20	; 0x01
    224c:	fc 01       	movw	r30, r24
    224e:	ee 0f       	add	r30, r30
    2250:	ff 1f       	adc	r31, r31
    2252:	ee 0f       	add	r30, r30
    2254:	ff 1f       	adc	r31, r31
    2256:	ee 0f       	add	r30, r30
    2258:	ff 1f       	adc	r31, r31
    225a:	8e 0f       	add	r24, r30
    225c:	9f 1f       	adc	r25, r31
    225e:	fc 01       	movw	r30, r24
    2260:	ef 53       	subi	r30, 0x3F	; 63
    2262:	fe 4f       	sbci	r31, 0xFE	; 254
    2264:	01 80       	ldd	r0, Z+1	; 0x01
    2266:	f2 81       	ldd	r31, Z+2	; 0x02
    2268:	e0 2d       	mov	r30, r0
    226a:	86 81       	ldd	r24, Z+6	; 0x06
    226c:	97 81       	ldd	r25, Z+7	; 0x07
    226e:	90 93 e6 01 	sts	0x01E6, r25	; 0x8001e6 <pxCurrentTCB+0x1>
    2272:	80 93 e5 01 	sts	0x01E5, r24	; 0x8001e5 <pxCurrentTCB>
    2276:	20 93 8b 01 	sts	0x018B, r18	; 0x80018b <uxTopReadyPriority>
    227a:	08 95       	ret

0000227c <vTaskPlaceOnEventList>:
    227c:	cf 93       	push	r28
    227e:	df 93       	push	r29
    2280:	eb 01       	movw	r28, r22
    2282:	60 91 e5 01 	lds	r22, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    2286:	70 91 e6 01 	lds	r23, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    228a:	64 5f       	subi	r22, 0xF4	; 244
    228c:	7f 4f       	sbci	r23, 0xFF	; 255
    228e:	0e 94 f7 08 	call	0x11ee	; 0x11ee <vListInsert>
    2292:	61 e0       	ldi	r22, 0x01	; 1
    2294:	ce 01       	movw	r24, r28
    2296:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <prvAddCurrentTaskToDelayedList>
    229a:	df 91       	pop	r29
    229c:	cf 91       	pop	r28
    229e:	08 95       	ret

000022a0 <vTaskPlaceOnEventListRestricted>:
    22a0:	0f 93       	push	r16
    22a2:	1f 93       	push	r17
    22a4:	cf 93       	push	r28
    22a6:	8b 01       	movw	r16, r22
    22a8:	c4 2f       	mov	r28, r20
    22aa:	60 91 e5 01 	lds	r22, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    22ae:	70 91 e6 01 	lds	r23, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    22b2:	64 5f       	subi	r22, 0xF4	; 244
    22b4:	7f 4f       	sbci	r23, 0xFF	; 255
    22b6:	0e 94 d6 08 	call	0x11ac	; 0x11ac <vListInsertEnd>
    22ba:	cc 23       	and	r28, r28
    22bc:	11 f0       	breq	.+4      	; 0x22c2 <vTaskPlaceOnEventListRestricted+0x22>
    22be:	0f ef       	ldi	r16, 0xFF	; 255
    22c0:	1f ef       	ldi	r17, 0xFF	; 255
    22c2:	6c 2f       	mov	r22, r28
    22c4:	c8 01       	movw	r24, r16
    22c6:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <prvAddCurrentTaskToDelayedList>
    22ca:	cf 91       	pop	r28
    22cc:	1f 91       	pop	r17
    22ce:	0f 91       	pop	r16
    22d0:	08 95       	ret

000022d2 <xTaskRemoveFromEventList>:
    22d2:	0f 93       	push	r16
    22d4:	1f 93       	push	r17
    22d6:	cf 93       	push	r28
    22d8:	df 93       	push	r29
    22da:	dc 01       	movw	r26, r24
    22dc:	15 96       	adiw	r26, 0x05	; 5
    22de:	ed 91       	ld	r30, X+
    22e0:	fc 91       	ld	r31, X
    22e2:	16 97       	sbiw	r26, 0x06	; 6
    22e4:	c6 81       	ldd	r28, Z+6	; 0x06
    22e6:	d7 81       	ldd	r29, Z+7	; 0x07
    22e8:	8e 01       	movw	r16, r28
    22ea:	04 5f       	subi	r16, 0xF4	; 244
    22ec:	1f 4f       	sbci	r17, 0xFF	; 255
    22ee:	c8 01       	movw	r24, r16
    22f0:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    22f4:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxSchedulerSuspended>
    22f8:	81 11       	cpse	r24, r1
    22fa:	1c c0       	rjmp	.+56     	; 0x2334 <xTaskRemoveFromEventList+0x62>
    22fc:	0a 50       	subi	r16, 0x0A	; 10
    22fe:	11 09       	sbc	r17, r1
    2300:	c8 01       	movw	r24, r16
    2302:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    2306:	8e 89       	ldd	r24, Y+22	; 0x16
    2308:	90 91 8b 01 	lds	r25, 0x018B	; 0x80018b <uxTopReadyPriority>
    230c:	98 17       	cp	r25, r24
    230e:	10 f4       	brcc	.+4      	; 0x2314 <xTaskRemoveFromEventList+0x42>
    2310:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <uxTopReadyPriority>
    2314:	90 e0       	ldi	r25, 0x00	; 0
    2316:	9c 01       	movw	r18, r24
    2318:	22 0f       	add	r18, r18
    231a:	33 1f       	adc	r19, r19
    231c:	22 0f       	add	r18, r18
    231e:	33 1f       	adc	r19, r19
    2320:	22 0f       	add	r18, r18
    2322:	33 1f       	adc	r19, r19
    2324:	82 0f       	add	r24, r18
    2326:	93 1f       	adc	r25, r19
    2328:	b8 01       	movw	r22, r16
    232a:	8f 53       	subi	r24, 0x3F	; 63
    232c:	9e 4f       	sbci	r25, 0xFE	; 254
    232e:	0e 94 d6 08 	call	0x11ac	; 0x11ac <vListInsertEnd>
    2332:	05 c0       	rjmp	.+10     	; 0x233e <xTaskRemoveFromEventList+0x6c>
    2334:	b8 01       	movw	r22, r16
    2336:	82 ea       	ldi	r24, 0xA2	; 162
    2338:	91 e0       	ldi	r25, 0x01	; 1
    233a:	0e 94 d6 08 	call	0x11ac	; 0x11ac <vListInsertEnd>
    233e:	e0 91 e5 01 	lds	r30, 0x01E5	; 0x8001e5 <pxCurrentTCB>
    2342:	f0 91 e6 01 	lds	r31, 0x01E6	; 0x8001e6 <pxCurrentTCB+0x1>
    2346:	9e 89       	ldd	r25, Y+22	; 0x16
    2348:	86 89       	ldd	r24, Z+22	; 0x16
    234a:	89 17       	cp	r24, r25
    234c:	20 f4       	brcc	.+8      	; 0x2356 <xTaskRemoveFromEventList+0x84>
    234e:	81 e0       	ldi	r24, 0x01	; 1
    2350:	80 93 87 01 	sts	0x0187, r24	; 0x800187 <xYieldPending>
    2354:	01 c0       	rjmp	.+2      	; 0x2358 <xTaskRemoveFromEventList+0x86>
    2356:	80 e0       	ldi	r24, 0x00	; 0
    2358:	df 91       	pop	r29
    235a:	cf 91       	pop	r28
    235c:	1f 91       	pop	r17
    235e:	0f 91       	pop	r16
    2360:	08 95       	ret

00002362 <vTaskInternalSetTimeOutState>:
    2362:	20 91 86 01 	lds	r18, 0x0186	; 0x800186 <xNumOfOverflows>
    2366:	fc 01       	movw	r30, r24
    2368:	20 83       	st	Z, r18
    236a:	20 91 8c 01 	lds	r18, 0x018C	; 0x80018c <xTickCount>
    236e:	30 91 8d 01 	lds	r19, 0x018D	; 0x80018d <xTickCount+0x1>
    2372:	32 83       	std	Z+2, r19	; 0x02
    2374:	21 83       	std	Z+1, r18	; 0x01
    2376:	08 95       	ret

00002378 <xTaskCheckForTimeOut>:
    2378:	cf 93       	push	r28
    237a:	df 93       	push	r29
    237c:	0f b6       	in	r0, 0x3f	; 63
    237e:	f8 94       	cli
    2380:	0f 92       	push	r0
    2382:	20 91 8c 01 	lds	r18, 0x018C	; 0x80018c <xTickCount>
    2386:	30 91 8d 01 	lds	r19, 0x018D	; 0x80018d <xTickCount+0x1>
    238a:	db 01       	movw	r26, r22
    238c:	4d 91       	ld	r20, X+
    238e:	5c 91       	ld	r21, X
    2390:	4f 3f       	cpi	r20, 0xFF	; 255
    2392:	bf ef       	ldi	r27, 0xFF	; 255
    2394:	5b 07       	cpc	r21, r27
    2396:	f1 f0       	breq	.+60     	; 0x23d4 <xTaskCheckForTimeOut+0x5c>
    2398:	ec 01       	movw	r28, r24
    239a:	e9 81       	ldd	r30, Y+1	; 0x01
    239c:	fa 81       	ldd	r31, Y+2	; 0x02
    239e:	a0 91 86 01 	lds	r26, 0x0186	; 0x800186 <xNumOfOverflows>
    23a2:	b8 81       	ld	r27, Y
    23a4:	ba 17       	cp	r27, r26
    23a6:	19 f0       	breq	.+6      	; 0x23ae <xTaskCheckForTimeOut+0x36>
    23a8:	2e 17       	cp	r18, r30
    23aa:	3f 07       	cpc	r19, r31
    23ac:	a8 f4       	brcc	.+42     	; 0x23d8 <xTaskCheckForTimeOut+0x60>
    23ae:	2e 1b       	sub	r18, r30
    23b0:	3f 0b       	sbc	r19, r31
    23b2:	24 17       	cp	r18, r20
    23b4:	35 07       	cpc	r19, r21
    23b6:	48 f4       	brcc	.+18     	; 0x23ca <xTaskCheckForTimeOut+0x52>
    23b8:	fb 01       	movw	r30, r22
    23ba:	42 1b       	sub	r20, r18
    23bc:	53 0b       	sbc	r21, r19
    23be:	51 83       	std	Z+1, r21	; 0x01
    23c0:	40 83       	st	Z, r20
    23c2:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskInternalSetTimeOutState>
    23c6:	80 e0       	ldi	r24, 0x00	; 0
    23c8:	08 c0       	rjmp	.+16     	; 0x23da <xTaskCheckForTimeOut+0x62>
    23ca:	fb 01       	movw	r30, r22
    23cc:	11 82       	std	Z+1, r1	; 0x01
    23ce:	10 82       	st	Z, r1
    23d0:	81 e0       	ldi	r24, 0x01	; 1
    23d2:	03 c0       	rjmp	.+6      	; 0x23da <xTaskCheckForTimeOut+0x62>
    23d4:	80 e0       	ldi	r24, 0x00	; 0
    23d6:	01 c0       	rjmp	.+2      	; 0x23da <xTaskCheckForTimeOut+0x62>
    23d8:	81 e0       	ldi	r24, 0x01	; 1
    23da:	0f 90       	pop	r0
    23dc:	0f be       	out	0x3f, r0	; 63
    23de:	df 91       	pop	r29
    23e0:	cf 91       	pop	r28
    23e2:	08 95       	ret

000023e4 <vTaskMissedYield>:
    23e4:	81 e0       	ldi	r24, 0x01	; 1
    23e6:	80 93 87 01 	sts	0x0187, r24	; 0x800187 <xYieldPending>
    23ea:	08 95       	ret

000023ec <xTaskGetSchedulerState>:
    23ec:	80 91 8a 01 	lds	r24, 0x018A	; 0x80018a <xSchedulerRunning>
    23f0:	88 23       	and	r24, r24
    23f2:	31 f0       	breq	.+12     	; 0x2400 <xTaskGetSchedulerState+0x14>
    23f4:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxSchedulerSuspended>
    23f8:	88 23       	and	r24, r24
    23fa:	21 f0       	breq	.+8      	; 0x2404 <xTaskGetSchedulerState+0x18>
    23fc:	80 e0       	ldi	r24, 0x00	; 0
    23fe:	08 95       	ret
    2400:	81 e0       	ldi	r24, 0x01	; 1
    2402:	08 95       	ret
    2404:	82 e0       	ldi	r24, 0x02	; 2
    2406:	08 95       	ret

00002408 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    2408:	0f 93       	push	r16
    240a:	1f 93       	push	r17
    240c:	cf 93       	push	r28
    240e:	df 93       	push	r29
    2410:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    2412:	89 2b       	or	r24, r25
    2414:	79 f1       	breq	.+94     	; 0x2474 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    2416:	82 a1       	ldd	r24, Z+34	; 0x22
    2418:	81 50       	subi	r24, 0x01	; 1
    241a:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    241c:	26 89       	ldd	r18, Z+22	; 0x16
    241e:	91 a1       	ldd	r25, Z+33	; 0x21
    2420:	29 17       	cp	r18, r25
    2422:	51 f1       	breq	.+84     	; 0x2478 <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2424:	81 11       	cpse	r24, r1
    2426:	2a c0       	rjmp	.+84     	; 0x247c <xTaskPriorityDisinherit+0x74>
    2428:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready/delayed list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    242a:	8f 01       	movw	r16, r30
    242c:	0e 5f       	subi	r16, 0xFE	; 254
    242e:	1f 4f       	sbci	r17, 0xFF	; 255
    2430:	c8 01       	movw	r24, r16
    2432:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    2436:	89 a1       	ldd	r24, Y+33	; 0x21
    2438:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only Yellowundant for some ports. */
    243a:	24 e0       	ldi	r18, 0x04	; 4
    243c:	30 e0       	ldi	r19, 0x00	; 0
    243e:	28 1b       	sub	r18, r24
    2440:	31 09       	sbc	r19, r1
    2442:	3d 87       	std	Y+13, r19	; 0x0d
    2444:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    2446:	90 91 8b 01 	lds	r25, 0x018B	; 0x80018b <uxTopReadyPriority>
    244a:	98 17       	cp	r25, r24
    244c:	10 f4       	brcc	.+4      	; 0x2452 <xTaskPriorityDisinherit+0x4a>
    244e:	80 93 8b 01 	sts	0x018B, r24	; 0x80018b <uxTopReadyPriority>
    2452:	90 e0       	ldi	r25, 0x00	; 0
    2454:	9c 01       	movw	r18, r24
    2456:	22 0f       	add	r18, r18
    2458:	33 1f       	adc	r19, r19
    245a:	22 0f       	add	r18, r18
    245c:	33 1f       	adc	r19, r19
    245e:	22 0f       	add	r18, r18
    2460:	33 1f       	adc	r19, r19
    2462:	82 0f       	add	r24, r18
    2464:	93 1f       	adc	r25, r19
    2466:	b8 01       	movw	r22, r16
    2468:	8f 53       	subi	r24, 0x3F	; 63
    246a:	9e 4f       	sbci	r25, 0xFE	; 254
    246c:	0e 94 d6 08 	call	0x11ac	; 0x11ac <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    2470:	81 e0       	ldi	r24, 0x01	; 1
    2472:	05 c0       	rjmp	.+10     	; 0x247e <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	03 c0       	rjmp	.+6      	; 0x247e <xTaskPriorityDisinherit+0x76>
    2478:	80 e0       	ldi	r24, 0x00	; 0
    247a:	01 c0       	rjmp	.+2      	; 0x247e <xTaskPriorityDisinherit+0x76>
    247c:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    247e:	df 91       	pop	r29
    2480:	cf 91       	pop	r28
    2482:	1f 91       	pop	r17
    2484:	0f 91       	pop	r16
    2486:	08 95       	ret

00002488 <prvInsertTimerInActiveList>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    2488:	fc 01       	movw	r30, r24
    248a:	73 83       	std	Z+3, r23	; 0x03
    248c:	62 83       	std	Z+2, r22	; 0x02
    248e:	91 87       	std	Z+9, r25	; 0x09
    2490:	80 87       	std	Z+8, r24	; 0x08
    2492:	46 17       	cp	r20, r22
    2494:	57 07       	cpc	r21, r23
    2496:	90 f0       	brcs	.+36     	; 0x24bc <prvInsertTimerInActiveList+0x34>
    2498:	42 1b       	sub	r20, r18
    249a:	53 0b       	sbc	r21, r19
    249c:	84 85       	ldd	r24, Z+12	; 0x0c
    249e:	95 85       	ldd	r25, Z+13	; 0x0d
    24a0:	48 17       	cp	r20, r24
    24a2:	59 07       	cpc	r21, r25
    24a4:	e0 f4       	brcc	.+56     	; 0x24de <prvInsertTimerInActiveList+0x56>
    24a6:	bf 01       	movw	r22, r30
    24a8:	6e 5f       	subi	r22, 0xFE	; 254
    24aa:	7f 4f       	sbci	r23, 0xFF	; 255
    24ac:	80 91 ed 01 	lds	r24, 0x01ED	; 0x8001ed <pxOverflowTimerList>
    24b0:	90 91 ee 01 	lds	r25, 0x01EE	; 0x8001ee <pxOverflowTimerList+0x1>
    24b4:	0e 94 f7 08 	call	0x11ee	; 0x11ee <vListInsert>
    24b8:	80 e0       	ldi	r24, 0x00	; 0
    24ba:	08 95       	ret
    24bc:	42 17       	cp	r20, r18
    24be:	53 07       	cpc	r21, r19
    24c0:	18 f4       	brcc	.+6      	; 0x24c8 <prvInsertTimerInActiveList+0x40>
    24c2:	62 17       	cp	r22, r18
    24c4:	73 07       	cpc	r23, r19
    24c6:	68 f4       	brcc	.+26     	; 0x24e2 <prvInsertTimerInActiveList+0x5a>
    24c8:	bf 01       	movw	r22, r30
    24ca:	6e 5f       	subi	r22, 0xFE	; 254
    24cc:	7f 4f       	sbci	r23, 0xFF	; 255
    24ce:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <pxCurrentTimerList>
    24d2:	90 91 f0 01 	lds	r25, 0x01F0	; 0x8001f0 <pxCurrentTimerList+0x1>
    24d6:	0e 94 f7 08 	call	0x11ee	; 0x11ee <vListInsert>
    24da:	80 e0       	ldi	r24, 0x00	; 0
    24dc:	08 95       	ret
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	08 95       	ret
    24e2:	81 e0       	ldi	r24, 0x01	; 1
    24e4:	08 95       	ret

000024e6 <prvCheckForValidListAndQueue>:
    24e6:	0f b6       	in	r0, 0x3f	; 63
    24e8:	f8 94       	cli
    24ea:	0f 92       	push	r0
    24ec:	80 91 eb 01 	lds	r24, 0x01EB	; 0x8001eb <xTimerQueue>
    24f0:	90 91 ec 01 	lds	r25, 0x01EC	; 0x8001ec <xTimerQueue+0x1>
    24f4:	89 2b       	or	r24, r25
    24f6:	e9 f4       	brne	.+58     	; 0x2532 <prvCheckForValidListAndQueue+0x4c>
    24f8:	8a ef       	ldi	r24, 0xFA	; 250
    24fa:	91 e0       	ldi	r25, 0x01	; 1
    24fc:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    2500:	81 ef       	ldi	r24, 0xF1	; 241
    2502:	91 e0       	ldi	r25, 0x01	; 1
    2504:	0e 94 c4 08 	call	0x1188	; 0x1188 <vListInitialise>
    2508:	8a ef       	ldi	r24, 0xFA	; 250
    250a:	91 e0       	ldi	r25, 0x01	; 1
    250c:	90 93 f0 01 	sts	0x01F0, r25	; 0x8001f0 <pxCurrentTimerList+0x1>
    2510:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <pxCurrentTimerList>
    2514:	81 ef       	ldi	r24, 0xF1	; 241
    2516:	91 e0       	ldi	r25, 0x01	; 1
    2518:	90 93 ee 01 	sts	0x01EE, r25	; 0x8001ee <pxOverflowTimerList+0x1>
    251c:	80 93 ed 01 	sts	0x01ED, r24	; 0x8001ed <pxOverflowTimerList>
    2520:	40 e0       	ldi	r20, 0x00	; 0
    2522:	65 e0       	ldi	r22, 0x05	; 5
    2524:	8a e0       	ldi	r24, 0x0A	; 10
    2526:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <xQueueGenericCreate>
    252a:	90 93 ec 01 	sts	0x01EC, r25	; 0x8001ec <xTimerQueue+0x1>
    252e:	80 93 eb 01 	sts	0x01EB, r24	; 0x8001eb <xTimerQueue>
    2532:	0f 90       	pop	r0
    2534:	0f be       	out	0x3f, r0	; 63
    2536:	08 95       	ret

00002538 <xTimerCreateTimerTask>:
    2538:	ef 92       	push	r14
    253a:	ff 92       	push	r15
    253c:	0f 93       	push	r16
    253e:	0e 94 73 12 	call	0x24e6	; 0x24e6 <prvCheckForValidListAndQueue>
    2542:	80 91 eb 01 	lds	r24, 0x01EB	; 0x8001eb <xTimerQueue>
    2546:	90 91 ec 01 	lds	r25, 0x01EC	; 0x8001ec <xTimerQueue+0x1>
    254a:	89 2b       	or	r24, r25
    254c:	91 f0       	breq	.+36     	; 0x2572 <xTimerCreateTimerTask+0x3a>
    254e:	0f 2e       	mov	r0, r31
    2550:	f9 ee       	ldi	r31, 0xE9	; 233
    2552:	ef 2e       	mov	r14, r31
    2554:	f1 e0       	ldi	r31, 0x01	; 1
    2556:	ff 2e       	mov	r15, r31
    2558:	f0 2d       	mov	r31, r0
    255a:	03 e0       	ldi	r16, 0x03	; 3
    255c:	20 e0       	ldi	r18, 0x00	; 0
    255e:	30 e0       	ldi	r19, 0x00	; 0
    2560:	45 e5       	ldi	r20, 0x55	; 85
    2562:	50 e0       	ldi	r21, 0x00	; 0
    2564:	67 e4       	ldi	r22, 0x47	; 71
    2566:	71 e0       	ldi	r23, 0x01	; 1
    2568:	86 e7       	ldi	r24, 0x76	; 118
    256a:	93 e1       	ldi	r25, 0x13	; 19
    256c:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <xTaskCreate>
    2570:	01 c0       	rjmp	.+2      	; 0x2574 <xTimerCreateTimerTask+0x3c>
    2572:	80 e0       	ldi	r24, 0x00	; 0
    2574:	0f 91       	pop	r16
    2576:	ff 90       	pop	r15
    2578:	ef 90       	pop	r14
    257a:	08 95       	ret

0000257c <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    257c:	0f 93       	push	r16
    257e:	1f 93       	push	r17
    2580:	cf 93       	push	r28
    2582:	df 93       	push	r29
    2584:	00 d0       	rcall	.+0      	; 0x2586 <xTimerGenericCommand+0xa>
    2586:	00 d0       	rcall	.+0      	; 0x2588 <xTimerGenericCommand+0xc>
    2588:	1f 92       	push	r1
    258a:	cd b7       	in	r28, 0x3d	; 61
    258c:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    258e:	e0 91 eb 01 	lds	r30, 0x01EB	; 0x8001eb <xTimerQueue>
    2592:	f0 91 ec 01 	lds	r31, 0x01EC	; 0x8001ec <xTimerQueue+0x1>
    2596:	30 97       	sbiw	r30, 0x00	; 0
    2598:	71 f1       	breq	.+92     	; 0x25f6 <xTimerGenericCommand+0x7a>
    259a:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    259c:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    259e:	5b 83       	std	Y+3, r21	; 0x03
    25a0:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    25a2:	9d 83       	std	Y+5, r25	; 0x05
    25a4:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    25a6:	66 30       	cpi	r22, 0x06	; 6
    25a8:	ec f4       	brge	.+58     	; 0x25e4 <xTimerGenericCommand+0x68>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    25aa:	0e 94 f6 11 	call	0x23ec	; 0x23ec <xTaskGetSchedulerState>
    25ae:	82 30       	cpi	r24, 0x02	; 2
    25b0:	61 f4       	brne	.+24     	; 0x25ca <xTimerGenericCommand+0x4e>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    25b2:	20 e0       	ldi	r18, 0x00	; 0
    25b4:	a8 01       	movw	r20, r16
    25b6:	be 01       	movw	r22, r28
    25b8:	6f 5f       	subi	r22, 0xFF	; 255
    25ba:	7f 4f       	sbci	r23, 0xFF	; 255
    25bc:	80 91 eb 01 	lds	r24, 0x01EB	; 0x8001eb <xTimerQueue>
    25c0:	90 91 ec 01 	lds	r25, 0x01EC	; 0x8001ec <xTimerQueue+0x1>
    25c4:	0e 94 8b 0b 	call	0x1716	; 0x1716 <xQueueGenericSend>
    25c8:	17 c0       	rjmp	.+46     	; 0x25f8 <xTimerGenericCommand+0x7c>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    25ca:	20 e0       	ldi	r18, 0x00	; 0
    25cc:	40 e0       	ldi	r20, 0x00	; 0
    25ce:	50 e0       	ldi	r21, 0x00	; 0
    25d0:	be 01       	movw	r22, r28
    25d2:	6f 5f       	subi	r22, 0xFF	; 255
    25d4:	7f 4f       	sbci	r23, 0xFF	; 255
    25d6:	80 91 eb 01 	lds	r24, 0x01EB	; 0x8001eb <xTimerQueue>
    25da:	90 91 ec 01 	lds	r25, 0x01EC	; 0x8001ec <xTimerQueue+0x1>
    25de:	0e 94 8b 0b 	call	0x1716	; 0x1716 <xQueueGenericSend>
    25e2:	0a c0       	rjmp	.+20     	; 0x25f8 <xTimerGenericCommand+0x7c>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    25e4:	20 e0       	ldi	r18, 0x00	; 0
    25e6:	ad 01       	movw	r20, r26
    25e8:	be 01       	movw	r22, r28
    25ea:	6f 5f       	subi	r22, 0xFF	; 255
    25ec:	7f 4f       	sbci	r23, 0xFF	; 255
    25ee:	cf 01       	movw	r24, r30
    25f0:	0e 94 2c 0c 	call	0x1858	; 0x1858 <xQueueGenericSendFromISR>
    25f4:	01 c0       	rjmp	.+2      	; 0x25f8 <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    25f6:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    25f8:	0f 90       	pop	r0
    25fa:	0f 90       	pop	r0
    25fc:	0f 90       	pop	r0
    25fe:	0f 90       	pop	r0
    2600:	0f 90       	pop	r0
    2602:	df 91       	pop	r29
    2604:	cf 91       	pop	r28
    2606:	1f 91       	pop	r17
    2608:	0f 91       	pop	r16
    260a:	08 95       	ret

0000260c <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    260c:	af 92       	push	r10
    260e:	bf 92       	push	r11
    2610:	cf 92       	push	r12
    2612:	df 92       	push	r13
    2614:	ef 92       	push	r14
    2616:	ff 92       	push	r15
    2618:	0f 93       	push	r16
    261a:	1f 93       	push	r17
    261c:	cf 93       	push	r28
    261e:	df 93       	push	r29
    2620:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2622:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <xTaskGetTickCount>
    2626:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    2628:	80 91 e7 01 	lds	r24, 0x01E7	; 0x8001e7 <xLastTime.2416>
    262c:	90 91 e8 01 	lds	r25, 0x01E8	; 0x8001e8 <xLastTime.2416+0x1>
    2630:	e8 16       	cp	r14, r24
    2632:	f9 06       	cpc	r15, r25
    2634:	08 f0       	brcs	.+2      	; 0x2638 <prvSampleTimeNow+0x2c>
    2636:	48 c0       	rjmp	.+144    	; 0x26c8 <prvSampleTimeNow+0xbc>
    2638:	30 c0       	rjmp	.+96     	; 0x269a <prvSampleTimeNow+0x8e>
    If there are any timers still referenced from the current timer list
    then they must have expiYellow and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    263a:	05 80       	ldd	r0, Z+5	; 0x05
    263c:	f6 81       	ldd	r31, Z+6	; 0x06
    263e:	e0 2d       	mov	r30, r0
    2640:	a0 80       	ld	r10, Z
    2642:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stoYellow and retrieved is the same. */
    2644:	c6 81       	ldd	r28, Z+6	; 0x06
    2646:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2648:	8e 01       	movw	r16, r28
    264a:	0e 5f       	subi	r16, 0xFE	; 254
    264c:	1f 4f       	sbci	r17, 0xFF	; 255
    264e:	c8 01       	movw	r24, r16
    2650:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
        traceTIMER_EXPIYellow( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2654:	e8 89       	ldd	r30, Y+16	; 0x10
    2656:	f9 89       	ldd	r31, Y+17	; 0x11
    2658:	ce 01       	movw	r24, r28
    265a:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    265c:	8a 89       	ldd	r24, Y+18	; 0x12
    265e:	82 ff       	sbrs	r24, 2
    2660:	1c c0       	rjmp	.+56     	; 0x269a <prvSampleTimeNow+0x8e>
            the timer going into the same timer list then it has already expiYellow
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2662:	8c 85       	ldd	r24, Y+12	; 0x0c
    2664:	9d 85       	ldd	r25, Y+13	; 0x0d
    2666:	8a 0d       	add	r24, r10
    2668:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    266a:	a8 16       	cp	r10, r24
    266c:	b9 06       	cpc	r11, r25
    266e:	60 f4       	brcc	.+24     	; 0x2688 <prvSampleTimeNow+0x7c>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2670:	9b 83       	std	Y+3, r25	; 0x03
    2672:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2674:	d9 87       	std	Y+9, r29	; 0x09
    2676:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2678:	b8 01       	movw	r22, r16
    267a:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <pxCurrentTimerList>
    267e:	90 91 f0 01 	lds	r25, 0x01F0	; 0x8001f0 <pxCurrentTimerList+0x1>
    2682:	0e 94 f7 08 	call	0x11ee	; 0x11ee <vListInsert>
    2686:	09 c0       	rjmp	.+18     	; 0x269a <prvSampleTimeNow+0x8e>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2688:	00 e0       	ldi	r16, 0x00	; 0
    268a:	10 e0       	ldi	r17, 0x00	; 0
    268c:	20 e0       	ldi	r18, 0x00	; 0
    268e:	30 e0       	ldi	r19, 0x00	; 0
    2690:	a5 01       	movw	r20, r10
    2692:	60 e0       	ldi	r22, 0x00	; 0
    2694:	ce 01       	movw	r24, r28
    2696:	0e 94 be 12 	call	0x257c	; 0x257c <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expiYellow and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    269a:	e0 91 ef 01 	lds	r30, 0x01EF	; 0x8001ef <pxCurrentTimerList>
    269e:	f0 91 f0 01 	lds	r31, 0x01F0	; 0x8001f0 <pxCurrentTimerList+0x1>
    26a2:	80 81       	ld	r24, Z
    26a4:	81 11       	cpse	r24, r1
    26a6:	c9 cf       	rjmp	.-110    	; 0x263a <prvSampleTimeNow+0x2e>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    26a8:	80 91 ed 01 	lds	r24, 0x01ED	; 0x8001ed <pxOverflowTimerList>
    26ac:	90 91 ee 01 	lds	r25, 0x01EE	; 0x8001ee <pxOverflowTimerList+0x1>
    26b0:	90 93 f0 01 	sts	0x01F0, r25	; 0x8001f0 <pxCurrentTimerList+0x1>
    26b4:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    26b8:	f0 93 ee 01 	sts	0x01EE, r31	; 0x8001ee <pxOverflowTimerList+0x1>
    26bc:	e0 93 ed 01 	sts	0x01ED, r30	; 0x8001ed <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    26c0:	81 e0       	ldi	r24, 0x01	; 1
    26c2:	f6 01       	movw	r30, r12
    26c4:	80 83       	st	Z, r24
    26c6:	02 c0       	rjmp	.+4      	; 0x26cc <prvSampleTimeNow+0xc0>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    26c8:	f6 01       	movw	r30, r12
    26ca:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    26cc:	f0 92 e8 01 	sts	0x01E8, r15	; 0x8001e8 <xLastTime.2416+0x1>
    26d0:	e0 92 e7 01 	sts	0x01E7, r14	; 0x8001e7 <xLastTime.2416>

    return xTimeNow;
}
    26d4:	c7 01       	movw	r24, r14
    26d6:	df 91       	pop	r29
    26d8:	cf 91       	pop	r28
    26da:	1f 91       	pop	r17
    26dc:	0f 91       	pop	r16
    26de:	ff 90       	pop	r15
    26e0:	ef 90       	pop	r14
    26e2:	df 90       	pop	r13
    26e4:	cf 90       	pop	r12
    26e6:	bf 90       	pop	r11
    26e8:	af 90       	pop	r10
    26ea:	08 95       	ret

000026ec <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    26ec:	cf 93       	push	r28
    26ee:	df 93       	push	r29
    26f0:	00 d0       	rcall	.+0      	; 0x26f2 <prvTimerTask+0x6>
    26f2:	00 d0       	rcall	.+0      	; 0x26f4 <prvTimerTask+0x8>
    26f4:	00 d0       	rcall	.+0      	; 0x26f6 <prvTimerTask+0xa>
    26f6:	cd b7       	in	r28, 0x3d	; 61
    26f8:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expiYellow or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    26fa:	ce 01       	movw	r24, r28
    26fc:	01 96       	adiw	r24, 0x01	; 1
    26fe:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2700:	44 24       	eor	r4, r4
    2702:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2704:	e1 2c       	mov	r14, r1
    2706:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2708:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    270a:	c8 2e       	mov	r12, r24
    270c:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    270e:	e0 91 ef 01 	lds	r30, 0x01EF	; 0x8001ef <pxCurrentTimerList>
    2712:	f0 91 f0 01 	lds	r31, 0x01F0	; 0x8001f0 <pxCurrentTimerList+0x1>
    2716:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    2718:	88 23       	and	r24, r24
    271a:	09 f4       	brne	.+2      	; 0x271e <prvTimerTask+0x32>
    271c:	dc c0       	rjmp	.+440    	; 0x28d6 <prvTimerTask+0x1ea>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    271e:	05 80       	ldd	r0, Z+5	; 0x05
    2720:	f6 81       	ldd	r31, Z+6	; 0x06
    2722:	e0 2d       	mov	r30, r0
    2724:	a0 80       	ld	r10, Z
    2726:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2728:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expiYellow or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    272c:	c4 01       	movw	r24, r8
    272e:	0e 94 06 13 	call	0x260c	; 0x260c <prvSampleTimeNow>
    2732:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2734:	89 81       	ldd	r24, Y+1	; 0x01
    2736:	81 11       	cpse	r24, r1
    2738:	4b c0       	rjmp	.+150    	; 0x27d0 <prvTimerTask+0xe4>
        {
            /* The tick count has not overflowed, has the timer expiYellow? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    273a:	0a 15       	cp	r16, r10
    273c:	1b 05       	cpc	r17, r11
    273e:	b8 f1       	brcs	.+110    	; 0x27ae <prvTimerTask+0xc2>
            {
                ( void ) xTaskResumeAll();
    2740:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiYellowTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stoYellow and retrieved is the same. */
    2744:	e0 91 ef 01 	lds	r30, 0x01EF	; 0x8001ef <pxCurrentTimerList>
    2748:	f0 91 f0 01 	lds	r31, 0x01F0	; 0x8001f0 <pxCurrentTimerList+0x1>
    274c:	05 80       	ldd	r0, Z+5	; 0x05
    274e:	f6 81       	ldd	r31, Z+6	; 0x06
    2750:	e0 2d       	mov	r30, r0
    2752:	66 80       	ldd	r6, Z+6	; 0x06
    2754:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2756:	c3 01       	movw	r24, r6
    2758:	02 96       	adiw	r24, 0x02	; 2
    275a:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
    traceTIMER_EXPIYellow( pxTimer );

    /* If the timer is an auto-reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    275e:	d3 01       	movw	r26, r6
    2760:	52 96       	adiw	r26, 0x12	; 18
    2762:	8c 91       	ld	r24, X
    2764:	52 97       	sbiw	r26, 0x12	; 18
    2766:	82 ff       	sbrs	r24, 2
    2768:	17 c0       	rjmp	.+46     	; 0x2798 <prvTimerTask+0xac>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    276a:	1c 96       	adiw	r26, 0x0c	; 12
    276c:	6d 91       	ld	r22, X+
    276e:	7c 91       	ld	r23, X
    2770:	1d 97       	sbiw	r26, 0x0d	; 13
    2772:	6a 0d       	add	r22, r10
    2774:	7b 1d       	adc	r23, r11
    2776:	95 01       	movw	r18, r10
    2778:	a8 01       	movw	r20, r16
    277a:	c3 01       	movw	r24, r6
    277c:	0e 94 44 12 	call	0x2488	; 0x2488 <prvInsertTimerInActiveList>
    2780:	88 23       	and	r24, r24
    2782:	69 f0       	breq	.+26     	; 0x279e <prvTimerTask+0xb2>
        {
            /* The timer expiYellow before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2784:	0e 2d       	mov	r16, r14
    2786:	1f 2d       	mov	r17, r15
    2788:	2e 2d       	mov	r18, r14
    278a:	3f 2d       	mov	r19, r15
    278c:	a5 01       	movw	r20, r10
    278e:	65 2d       	mov	r22, r5
    2790:	c3 01       	movw	r24, r6
    2792:	0e 94 be 12 	call	0x257c	; 0x257c <xTimerGenericCommand>
    2796:	03 c0       	rjmp	.+6      	; 0x279e <prvTimerTask+0xb2>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2798:	8e 7f       	andi	r24, 0xFE	; 254
    279a:	f3 01       	movw	r30, r6
    279c:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    279e:	d3 01       	movw	r26, r6
    27a0:	50 96       	adiw	r26, 0x10	; 16
    27a2:	ed 91       	ld	r30, X+
    27a4:	fc 91       	ld	r31, X
    27a6:	51 97       	sbiw	r26, 0x11	; 17
    27a8:	c3 01       	movw	r24, r6
    27aa:	09 95       	icall
    27ac:	87 c0       	rjmp	.+270    	; 0x28bc <prvTimerTask+0x1d0>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expiYellow? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    27ae:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    27b0:	b5 01       	movw	r22, r10
    27b2:	60 1b       	sub	r22, r16
    27b4:	71 0b       	sbc	r23, r17
    27b6:	80 91 eb 01 	lds	r24, 0x01EB	; 0x8001eb <xTimerQueue>
    27ba:	90 91 ec 01 	lds	r25, 0x01EC	; 0x8001ec <xTimerQueue+0x1>
    27be:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    27c2:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    27c6:	81 11       	cpse	r24, r1
    27c8:	79 c0       	rjmp	.+242    	; 0x28bc <prvTimerTask+0x1d0>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    27ca:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    27ce:	76 c0       	rjmp	.+236    	; 0x28bc <prvTimerTask+0x1d0>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    27d0:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <xTaskResumeAll>
    27d4:	73 c0       	rjmp	.+230    	; 0x28bc <prvTimerTask+0x1d0>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    27d6:	89 81       	ldd	r24, Y+1	; 0x01
    27d8:	88 23       	and	r24, r24
    27da:	0c f4       	brge	.+2      	; 0x27de <prvTimerTask+0xf2>
    27dc:	6f c0       	rjmp	.+222    	; 0x28bc <prvTimerTask+0x1d0>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    27de:	ac 80       	ldd	r10, Y+4	; 0x04
    27e0:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only Yellowundant when NULL is passed into the macro. */
    27e2:	f5 01       	movw	r30, r10
    27e4:	82 85       	ldd	r24, Z+10	; 0x0a
    27e6:	93 85       	ldd	r25, Z+11	; 0x0b
    27e8:	89 2b       	or	r24, r25
    27ea:	21 f0       	breq	.+8      	; 0x27f4 <prvTimerTask+0x108>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    27ec:	c5 01       	movw	r24, r10
    27ee:	02 96       	adiw	r24, 0x02	; 2
    27f0:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    27f4:	ce 01       	movw	r24, r28
    27f6:	06 96       	adiw	r24, 0x06	; 6
    27f8:	0e 94 06 13 	call	0x260c	; 0x260c <prvSampleTimeNow>

            switch( xMessage.xMessageID )
    27fc:	e9 81       	ldd	r30, Y+1	; 0x01
    27fe:	0e 2e       	mov	r0, r30
    2800:	00 0c       	add	r0, r0
    2802:	ff 0b       	sbc	r31, r31
    2804:	ea 30       	cpi	r30, 0x0A	; 10
    2806:	f1 05       	cpc	r31, r1
    2808:	08 f0       	brcs	.+2      	; 0x280c <prvTimerTask+0x120>
    280a:	58 c0       	rjmp	.+176    	; 0x28bc <prvTimerTask+0x1d0>
    280c:	ec 5c       	subi	r30, 0xCC	; 204
    280e:	ff 4f       	sbci	r31, 0xFF	; 255
    2810:	0c 94 95 18 	jmp	0x312a	; 0x312a <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2814:	d5 01       	movw	r26, r10
    2816:	52 96       	adiw	r26, 0x12	; 18
    2818:	2c 91       	ld	r18, X
    281a:	52 97       	sbiw	r26, 0x12	; 18
    281c:	21 60       	ori	r18, 0x01	; 1
    281e:	52 96       	adiw	r26, 0x12	; 18
    2820:	2c 93       	st	X, r18
    2822:	52 97       	sbiw	r26, 0x12	; 18
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2824:	2a 81       	ldd	r18, Y+2	; 0x02
    2826:	3b 81       	ldd	r19, Y+3	; 0x03
    2828:	1c 96       	adiw	r26, 0x0c	; 12
    282a:	6d 91       	ld	r22, X+
    282c:	7c 91       	ld	r23, X
    282e:	1d 97       	sbiw	r26, 0x0d	; 13
    2830:	62 0f       	add	r22, r18
    2832:	73 1f       	adc	r23, r19
    2834:	ac 01       	movw	r20, r24
    2836:	c5 01       	movw	r24, r10
    2838:	0e 94 44 12 	call	0x2488	; 0x2488 <prvInsertTimerInActiveList>
    283c:	88 23       	and	r24, r24
    283e:	f1 f1       	breq	.+124    	; 0x28bc <prvTimerTask+0x1d0>
                    {
                        /* The timer expiYellow before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2840:	d5 01       	movw	r26, r10
    2842:	50 96       	adiw	r26, 0x10	; 16
    2844:	ed 91       	ld	r30, X+
    2846:	fc 91       	ld	r31, X
    2848:	51 97       	sbiw	r26, 0x11	; 17
    284a:	c5 01       	movw	r24, r10
    284c:	09 95       	icall
                        traceTIMER_EXPIYellow( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    284e:	f5 01       	movw	r30, r10
    2850:	82 89       	ldd	r24, Z+18	; 0x12
    2852:	82 ff       	sbrs	r24, 2
    2854:	33 c0       	rjmp	.+102    	; 0x28bc <prvTimerTask+0x1d0>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2856:	4a 81       	ldd	r20, Y+2	; 0x02
    2858:	5b 81       	ldd	r21, Y+3	; 0x03
    285a:	84 85       	ldd	r24, Z+12	; 0x0c
    285c:	95 85       	ldd	r25, Z+13	; 0x0d
    285e:	48 0f       	add	r20, r24
    2860:	59 1f       	adc	r21, r25
    2862:	0e 2d       	mov	r16, r14
    2864:	1f 2d       	mov	r17, r15
    2866:	2e 2d       	mov	r18, r14
    2868:	3f 2d       	mov	r19, r15
    286a:	65 2d       	mov	r22, r5
    286c:	c5 01       	movw	r24, r10
    286e:	0e 94 be 12 	call	0x257c	; 0x257c <xTimerGenericCommand>
    2872:	24 c0       	rjmp	.+72     	; 0x28bc <prvTimerTask+0x1d0>
                    break;

                case tmrCOMMAND_STOP :
                case tmrCOMMAND_STOP_FROM_ISR :
                    /* The timer has already been removed from the active list. */
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2874:	d5 01       	movw	r26, r10
    2876:	52 96       	adiw	r26, 0x12	; 18
    2878:	8c 91       	ld	r24, X
    287a:	52 97       	sbiw	r26, 0x12	; 18
    287c:	8e 7f       	andi	r24, 0xFE	; 254
    287e:	52 96       	adiw	r26, 0x12	; 18
    2880:	8c 93       	st	X, r24
    2882:	1c c0       	rjmp	.+56     	; 0x28bc <prvTimerTask+0x1d0>
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2884:	f5 01       	movw	r30, r10
    2886:	22 89       	ldd	r18, Z+18	; 0x12
    2888:	21 60       	ori	r18, 0x01	; 1
    288a:	22 8b       	std	Z+18, r18	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    288c:	6a 81       	ldd	r22, Y+2	; 0x02
    288e:	7b 81       	ldd	r23, Y+3	; 0x03
    2890:	75 87       	std	Z+13, r23	; 0x0d
    2892:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2894:	68 0f       	add	r22, r24
    2896:	79 1f       	adc	r23, r25
    2898:	9c 01       	movw	r18, r24
    289a:	ac 01       	movw	r20, r24
    289c:	c5 01       	movw	r24, r10
    289e:	0e 94 44 12 	call	0x2488	; 0x2488 <prvInsertTimerInActiveList>
    28a2:	0c c0       	rjmp	.+24     	; 0x28bc <prvTimerTask+0x1d0>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    28a4:	d5 01       	movw	r26, r10
    28a6:	52 96       	adiw	r26, 0x12	; 18
    28a8:	8c 91       	ld	r24, X
    28aa:	81 fd       	sbrc	r24, 1
    28ac:	04 c0       	rjmp	.+8      	; 0x28b6 <prvTimerTask+0x1ca>
                        {
                            vPortFree( pxTimer );
    28ae:	c5 01       	movw	r24, r10
    28b0:	0e 94 82 08 	call	0x1104	; 0x1104 <vPortFree>
    28b4:	03 c0       	rjmp	.+6      	; 0x28bc <prvTimerTask+0x1d0>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    28b6:	8e 7f       	andi	r24, 0xFE	; 254
    28b8:	f5 01       	movw	r30, r10
    28ba:	82 8b       	std	Z+18, r24	; 0x12
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    28bc:	4e 2d       	mov	r20, r14
    28be:	5f 2d       	mov	r21, r15
    28c0:	6c 2d       	mov	r22, r12
    28c2:	7d 2d       	mov	r23, r13
    28c4:	80 91 eb 01 	lds	r24, 0x01EB	; 0x8001eb <xTimerQueue>
    28c8:	90 91 ec 01 	lds	r25, 0x01EC	; 0x8001ec <xTimerQueue+0x1>
    28cc:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <xQueueReceive>
    28d0:	81 11       	cpse	r24, r1
    28d2:	81 cf       	rjmp	.-254    	; 0x27d6 <prvTimerTask+0xea>
    28d4:	1c cf       	rjmp	.-456    	; 0x270e <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    28d6:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expiYellow or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    28da:	c4 01       	movw	r24, r8
    28dc:	0e 94 06 13 	call	0x260c	; 0x260c <prvSampleTimeNow>
    28e0:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    28e2:	89 81       	ldd	r24, Y+1	; 0x01
    28e4:	81 11       	cpse	r24, r1
    28e6:	74 cf       	rjmp	.-280    	; 0x27d0 <prvTimerTask+0xe4>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    28e8:	e0 91 ed 01 	lds	r30, 0x01ED	; 0x8001ed <pxOverflowTimerList>
    28ec:	f0 91 ee 01 	lds	r31, 0x01EE	; 0x8001ee <pxOverflowTimerList+0x1>
    28f0:	80 81       	ld	r24, Z
    28f2:	44 2d       	mov	r20, r4
    28f4:	81 11       	cpse	r24, r1
    28f6:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    28f8:	ae 2c       	mov	r10, r14
    28fa:	bf 2c       	mov	r11, r15
    28fc:	59 cf       	rjmp	.-334    	; 0x27b0 <prvTimerTask+0xc4>

000028fe <I2C_Init>:
	return 1;												/* If yes then return 1 to indicate ack received i.e. ready to accept data byte */
	if (status == 0x20)										/* Check weather SLA+W transmitted & nack received or not? */
	return 2;												/* If yes then return 2 to indicate nack received i.e. device is busy */
	else
	return 3;												/* Else return 3 to indicate SLA+W failed */
}
    28fe:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
    2902:	88 e4       	ldi	r24, 0x48	; 72
    2904:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__DATA_REGION_ORIGIN__+0x58>
    2908:	08 95       	ret

0000290a <I2C_Repeated_Start>:

uint8_t I2C_Repeated_Start(char slave_read_address)			/* I2C repeated start function */
{
	uint8_t status;											/* Declare variable */
	TWCR = (1<<TWSTA)|(1<<TWEN)|(1<<TWINT);					/* Enable TWI, generate start condition and clear interrupt flag */
    290a:	94 ea       	ldi	r25, 0xA4	; 164
    290c:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (start condition) */
    2910:	ec eb       	ldi	r30, 0xBC	; 188
    2912:	f0 e0       	ldi	r31, 0x00	; 0
    2914:	90 81       	ld	r25, Z
    2916:	99 23       	and	r25, r25
    2918:	ec f7       	brge	.-6      	; 0x2914 <I2C_Repeated_Start+0xa>
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
    291a:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
	if (status != 0x10)										/* Check weather repeated start condition transmitted successfully or not? */
    291e:	98 7f       	andi	r25, 0xF8	; 248
    2920:	90 31       	cpi	r25, 0x10	; 16
    2922:	99 f4       	brne	.+38     	; 0x294a <I2C_Repeated_Start+0x40>
	return 0;												/* If no then return 0 to indicate repeated start condition fail */
	TWDR = slave_read_address;								/* If yes then write SLA+R in TWI data register */
    2924:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
	TWCR = (1<<TWEN)|(1<<TWINT);							/* Enable TWI and clear interrupt flag */
    2928:	84 e8       	ldi	r24, 0x84	; 132
    292a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (Write operation) */
    292e:	ec eb       	ldi	r30, 0xBC	; 188
    2930:	f0 e0       	ldi	r31, 0x00	; 0
    2932:	80 81       	ld	r24, Z
    2934:	88 23       	and	r24, r24
    2936:	ec f7       	brge	.-6      	; 0x2932 <I2C_Repeated_Start+0x28>
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
    2938:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
    293c:	88 7f       	andi	r24, 0xF8	; 248
	if (status == 0x40)										/* Check weather SLA+R transmitted & ack received or not? */
    293e:	80 34       	cpi	r24, 0x40	; 64
    2940:	31 f0       	breq	.+12     	; 0x294e <I2C_Repeated_Start+0x44>
	return 1;												/* If yes then return 1 to indicate ack received */ 
	if (status == 0x20)										/* Check weather SLA+R transmitted & nack received or not? */
    2942:	80 32       	cpi	r24, 0x20	; 32
    2944:	31 f0       	breq	.+12     	; 0x2952 <I2C_Repeated_Start+0x48>
	return 2;												/* If yes then return 2 to indicate nack received i.e. device is busy */
	else
	return 3;												/* Else return 3 to indicate SLA+W failed */
    2946:	83 e0       	ldi	r24, 0x03	; 3
    2948:	08 95       	ret
	uint8_t status;											/* Declare variable */
	TWCR = (1<<TWSTA)|(1<<TWEN)|(1<<TWINT);					/* Enable TWI, generate start condition and clear interrupt flag */
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (start condition) */
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
	if (status != 0x10)										/* Check weather repeated start condition transmitted successfully or not? */
	return 0;												/* If no then return 0 to indicate repeated start condition fail */
    294a:	80 e0       	ldi	r24, 0x00	; 0
    294c:	08 95       	ret
	TWDR = slave_read_address;								/* If yes then write SLA+R in TWI data register */
	TWCR = (1<<TWEN)|(1<<TWINT);							/* Enable TWI and clear interrupt flag */
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (Write operation) */
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
	if (status == 0x40)										/* Check weather SLA+R transmitted & ack received or not? */
	return 1;												/* If yes then return 1 to indicate ack received */ 
    294e:	81 e0       	ldi	r24, 0x01	; 1
    2950:	08 95       	ret
	if (status == 0x20)										/* Check weather SLA+R transmitted & nack received or not? */
	return 2;												/* If yes then return 2 to indicate nack received i.e. device is busy */
    2952:	82 e0       	ldi	r24, 0x02	; 2
	else
	return 3;												/* Else return 3 to indicate SLA+W failed */
}
    2954:	08 95       	ret

00002956 <I2C_Stop>:

void I2C_Stop()												/* I2C stop function */
{
	TWCR=(1<<TWSTO)|(1<<TWINT)|(1<<TWEN);					/* Enable TWI, generate stop condition and clear interrupt flag */
    2956:	84 e9       	ldi	r24, 0x94	; 148
    2958:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
	while(TWCR & (1<<TWSTO));								/* Wait until stop condition execution */ 
    295c:	ec eb       	ldi	r30, 0xBC	; 188
    295e:	f0 e0       	ldi	r31, 0x00	; 0
    2960:	80 81       	ld	r24, Z
    2962:	84 fd       	sbrc	r24, 4
    2964:	fd cf       	rjmp	.-6      	; 0x2960 <I2C_Stop+0xa>
}
    2966:	08 95       	ret

00002968 <I2C_Start_Wait>:

void I2C_Start_Wait(char slave_write_address)				/* I2C start wait function */
{
    2968:	bf 92       	push	r11
    296a:	cf 92       	push	r12
    296c:	df 92       	push	r13
    296e:	ef 92       	push	r14
    2970:	ff 92       	push	r15
    2972:	0f 93       	push	r16
    2974:	1f 93       	push	r17
    2976:	cf 93       	push	r28
    2978:	df 93       	push	r29
    297a:	b8 2e       	mov	r11, r24
	uint8_t status;											/* Declare variable */
	while (1)
	{
		TWCR = (1<<TWSTA)|(1<<TWEN)|(1<<TWINT);				/* Enable TWI, generate start condition and clear interrupt flag */
    297c:	cc eb       	ldi	r28, 0xBC	; 188
    297e:	d0 e0       	ldi	r29, 0x00	; 0
    2980:	0f 2e       	mov	r0, r31
    2982:	f4 ea       	ldi	r31, 0xA4	; 164
    2984:	df 2e       	mov	r13, r31
    2986:	f0 2d       	mov	r31, r0
		while (!(TWCR & (1<<TWINT)));						/* Wait until TWI finish its current job (start condition) */
		status = TWSR & 0xF8;								/* Read TWI status register with masking lower three bits */
    2988:	09 eb       	ldi	r16, 0xB9	; 185
    298a:	10 e0       	ldi	r17, 0x00	; 0
		if (status != 0x08)									/* Check weather start condition transmitted successfully or not? */
		continue;											/* If no then continue with start loop again */
		TWDR = slave_write_address;							/* If yes then write SLA+W in TWI data register */
    298c:	0f 2e       	mov	r0, r31
    298e:	fb eb       	ldi	r31, 0xBB	; 187
    2990:	ef 2e       	mov	r14, r31
    2992:	f1 2c       	mov	r15, r1
    2994:	f0 2d       	mov	r31, r0
		TWCR = (1<<TWEN)|(1<<TWINT);						/* Enable TWI and clear interrupt flag */
    2996:	0f 2e       	mov	r0, r31
    2998:	f4 e8       	ldi	r31, 0x84	; 132
    299a:	cf 2e       	mov	r12, r31
    299c:	f0 2d       	mov	r31, r0
void I2C_Start_Wait(char slave_write_address)				/* I2C start wait function */
{
	uint8_t status;											/* Declare variable */
	while (1)
	{
		TWCR = (1<<TWSTA)|(1<<TWEN)|(1<<TWINT);				/* Enable TWI, generate start condition and clear interrupt flag */
    299e:	d8 82       	st	Y, r13
		while (!(TWCR & (1<<TWINT)));						/* Wait until TWI finish its current job (start condition) */
    29a0:	88 81       	ld	r24, Y
    29a2:	88 23       	and	r24, r24
    29a4:	ec f7       	brge	.-6      	; 0x29a0 <I2C_Start_Wait+0x38>
		status = TWSR & 0xF8;								/* Read TWI status register with masking lower three bits */
    29a6:	f8 01       	movw	r30, r16
    29a8:	80 81       	ld	r24, Z
		if (status != 0x08)									/* Check weather start condition transmitted successfully or not? */
    29aa:	88 7f       	andi	r24, 0xF8	; 248
    29ac:	88 30       	cpi	r24, 0x08	; 8
    29ae:	b9 f7       	brne	.-18     	; 0x299e <I2C_Start_Wait+0x36>
		continue;											/* If no then continue with start loop again */
		TWDR = slave_write_address;							/* If yes then write SLA+W in TWI data register */
    29b0:	f7 01       	movw	r30, r14
    29b2:	b0 82       	st	Z, r11
		TWCR = (1<<TWEN)|(1<<TWINT);						/* Enable TWI and clear interrupt flag */
    29b4:	c8 82       	st	Y, r12
		while (!(TWCR & (1<<TWINT)));						/* Wait until TWI finish its current job (Write operation) */
    29b6:	88 81       	ld	r24, Y
    29b8:	88 23       	and	r24, r24
    29ba:	ec f7       	brge	.-6      	; 0x29b6 <I2C_Start_Wait+0x4e>
		status = TWSR & 0xF8;								/* Read TWI status register with masking lower three bits */
    29bc:	f8 01       	movw	r30, r16
    29be:	80 81       	ld	r24, Z
		if (status != 0x18 )								/* Check weather SLA+W transmitted & ack received or not? */
    29c0:	88 7f       	andi	r24, 0xF8	; 248
    29c2:	88 31       	cpi	r24, 0x18	; 24
    29c4:	19 f0       	breq	.+6      	; 0x29cc <I2C_Start_Wait+0x64>
		{
			I2C_Stop();										/* If not then generate stop condition */
    29c6:	0e 94 ab 14 	call	0x2956	; 0x2956 <I2C_Stop>
			continue;										/* continue with start loop again */
    29ca:	e9 cf       	rjmp	.-46     	; 0x299e <I2C_Start_Wait+0x36>
		}
		break;												/* If yes then break loop */
	}
}
    29cc:	df 91       	pop	r29
    29ce:	cf 91       	pop	r28
    29d0:	1f 91       	pop	r17
    29d2:	0f 91       	pop	r16
    29d4:	ff 90       	pop	r15
    29d6:	ef 90       	pop	r14
    29d8:	df 90       	pop	r13
    29da:	cf 90       	pop	r12
    29dc:	bf 90       	pop	r11
    29de:	08 95       	ret

000029e0 <I2C_Write>:

uint8_t I2C_Write(char data)								/* I2C write function */
{
	uint8_t status;											/* Declare variable */
	TWDR = data;											/* Copy data in TWI data register */
    29e0:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
	TWCR = (1<<TWEN)|(1<<TWINT);							/* Enable TWI and clear interrupt flag */
    29e4:	84 e8       	ldi	r24, 0x84	; 132
    29e6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (Write operation) */
    29ea:	ec eb       	ldi	r30, 0xBC	; 188
    29ec:	f0 e0       	ldi	r31, 0x00	; 0
    29ee:	80 81       	ld	r24, Z
    29f0:	88 23       	and	r24, r24
    29f2:	ec f7       	brge	.-6      	; 0x29ee <I2C_Write+0xe>
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
    29f4:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
    29f8:	88 7f       	andi	r24, 0xF8	; 248
	if (status == 0x28)										/* Check weather data transmitted & ack received or not? */
    29fa:	88 32       	cpi	r24, 0x28	; 40
    29fc:	21 f0       	breq	.+8      	; 0x2a06 <I2C_Write+0x26>
	return 0;												/* If yes then return 0 to indicate ack received */
	if (status == 0x30)										/* Check weather data transmitted & nack received or not? */
    29fe:	80 33       	cpi	r24, 0x30	; 48
    2a00:	21 f0       	breq	.+8      	; 0x2a0a <I2C_Write+0x2a>
	return 1;												/* If yes then return 1 to indicate nack received */
	else
	return 2;												/* Else return 2 to indicate data transmission failed */
    2a02:	82 e0       	ldi	r24, 0x02	; 2
    2a04:	08 95       	ret
	TWDR = data;											/* Copy data in TWI data register */
	TWCR = (1<<TWEN)|(1<<TWINT);							/* Enable TWI and clear interrupt flag */
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (Write operation) */
	status = TWSR & 0xF8;									/* Read TWI status register with masking lower three bits */
	if (status == 0x28)										/* Check weather data transmitted & ack received or not? */
	return 0;												/* If yes then return 0 to indicate ack received */
    2a06:	80 e0       	ldi	r24, 0x00	; 0
    2a08:	08 95       	ret
	if (status == 0x30)										/* Check weather data transmitted & nack received or not? */
	return 1;												/* If yes then return 1 to indicate nack received */
    2a0a:	81 e0       	ldi	r24, 0x01	; 1
	else
	return 2;												/* Else return 2 to indicate data transmission failed */
}
    2a0c:	08 95       	ret

00002a0e <I2C_Read_Ack>:

char I2C_Read_Ack()										/* I2C read ack function */
{
	TWCR=(1<<TWEN)|(1<<TWINT)|(1<<TWEA);					/* Enable TWI, generation of ack and clear interrupt flag */
    2a0e:	84 ec       	ldi	r24, 0xC4	; 196
    2a10:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (read operation) */
    2a14:	ec eb       	ldi	r30, 0xBC	; 188
    2a16:	f0 e0       	ldi	r31, 0x00	; 0
    2a18:	80 81       	ld	r24, Z
    2a1a:	88 23       	and	r24, r24
    2a1c:	ec f7       	brge	.-6      	; 0x2a18 <I2C_Read_Ack+0xa>
	return TWDR;											/* Return received data */
    2a1e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
}	
    2a22:	08 95       	ret

00002a24 <I2C_Read_Nack>:

char I2C_Read_Nack()										/* I2C read nack function */
{
	TWCR=(1<<TWEN)|(1<<TWINT);								/* Enable TWI and clear interrupt flag */
    2a24:	84 e8       	ldi	r24, 0x84	; 132
    2a26:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
	while (!(TWCR & (1<<TWINT)));							/* Wait until TWI finish its current job (read operation) */
    2a2a:	ec eb       	ldi	r30, 0xBC	; 188
    2a2c:	f0 e0       	ldi	r31, 0x00	; 0
    2a2e:	80 81       	ld	r24, Z
    2a30:	88 23       	and	r24, r24
    2a32:	ec f7       	brge	.-6      	; 0x2a2e <I2C_Read_Nack+0xa>
	return TWDR;											/* Return received data */
    2a34:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
}	
    2a38:	08 95       	ret

00002a3a <UART_init>:

void UART_init(int BAUD_PRESCALER)
{
  
  /*Set baud rate */
  UBRR0H = (unsigned char)(BAUD_PRESCALER>>8);
    2a3a:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
  UBRR0L = (unsigned char)BAUD_PRESCALER;
    2a3e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
  //Enable receiver and transmitter 
  UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    2a42:	88 e1       	ldi	r24, 0x18	; 24
    2a44:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
  /* Set frame format: 2 stop bits, 8 data bits */
  UCSR0C |= (1<<USBS0); // 2 stop bits
    2a48:	e2 ec       	ldi	r30, 0xC2	; 194
    2a4a:	f0 e0       	ldi	r31, 0x00	; 0
    2a4c:	80 81       	ld	r24, Z
    2a4e:	88 60       	ori	r24, 0x08	; 8
    2a50:	80 83       	st	Z, r24
  UCSR0C = (1<<UCSZ01) | (1<<UCSZ00); // 8 data bits
    2a52:	86 e0       	ldi	r24, 0x06	; 6
    2a54:	80 83       	st	Z, r24
    2a56:	08 95       	ret

00002a58 <UART_send>:
}

void UART_send(unsigned char data)
{
  // Wait for empty transmit buffer
  while(!(UCSR0A & (1<<UDRE0)));
    2a58:	e0 ec       	ldi	r30, 0xC0	; 192
    2a5a:	f0 e0       	ldi	r31, 0x00	; 0
    2a5c:	90 81       	ld	r25, Z
    2a5e:	95 ff       	sbrs	r25, 5
    2a60:	fd cf       	rjmp	.-6      	; 0x2a5c <UART_send+0x4>
  // Put data into buffer and send data
  UDR0 = data;
    2a62:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    2a66:	08 95       	ret

00002a68 <UART_putstring>:
  
}

void UART_putstring(char* StringPtr)
{
    2a68:	cf 93       	push	r28
    2a6a:	df 93       	push	r29
    2a6c:	ec 01       	movw	r28, r24
  while(*StringPtr != 0x00)
    2a6e:	88 81       	ld	r24, Y
    2a70:	88 23       	and	r24, r24
    2a72:	31 f0       	breq	.+12     	; 0x2a80 <UART_putstring+0x18>
    2a74:	21 96       	adiw	r28, 0x01	; 1
  {
    UART_send(*StringPtr);
    2a76:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <UART_send>
  
}

void UART_putstring(char* StringPtr)
{
  while(*StringPtr != 0x00)
    2a7a:	89 91       	ld	r24, Y+
    2a7c:	81 11       	cpse	r24, r1
    2a7e:	fb cf       	rjmp	.-10     	; 0x2a76 <UART_putstring+0xe>
  {
    UART_send(*StringPtr);
  StringPtr++;
  }
    2a80:	df 91       	pop	r29
    2a82:	cf 91       	pop	r28
    2a84:	08 95       	ret

00002a86 <__subsf3>:
    2a86:	50 58       	subi	r21, 0x80	; 128

00002a88 <__addsf3>:
    2a88:	bb 27       	eor	r27, r27
    2a8a:	aa 27       	eor	r26, r26
    2a8c:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <__addsf3x>
    2a90:	0c 94 87 17 	jmp	0x2f0e	; 0x2f0e <__fp_round>
    2a94:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <__fp_pscA>
    2a98:	38 f0       	brcs	.+14     	; 0x2aa8 <__addsf3+0x20>
    2a9a:	0e 94 80 17 	call	0x2f00	; 0x2f00 <__fp_pscB>
    2a9e:	20 f0       	brcs	.+8      	; 0x2aa8 <__addsf3+0x20>
    2aa0:	39 f4       	brne	.+14     	; 0x2ab0 <__addsf3+0x28>
    2aa2:	9f 3f       	cpi	r25, 0xFF	; 255
    2aa4:	19 f4       	brne	.+6      	; 0x2aac <__addsf3+0x24>
    2aa6:	26 f4       	brtc	.+8      	; 0x2ab0 <__addsf3+0x28>
    2aa8:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <__fp_nan>
    2aac:	0e f4       	brtc	.+2      	; 0x2ab0 <__addsf3+0x28>
    2aae:	e0 95       	com	r30
    2ab0:	e7 fb       	bst	r30, 7
    2ab2:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <__fp_inf>

00002ab6 <__addsf3x>:
    2ab6:	e9 2f       	mov	r30, r25
    2ab8:	0e 94 98 17 	call	0x2f30	; 0x2f30 <__fp_split3>
    2abc:	58 f3       	brcs	.-42     	; 0x2a94 <__addsf3+0xc>
    2abe:	ba 17       	cp	r27, r26
    2ac0:	62 07       	cpc	r22, r18
    2ac2:	73 07       	cpc	r23, r19
    2ac4:	84 07       	cpc	r24, r20
    2ac6:	95 07       	cpc	r25, r21
    2ac8:	20 f0       	brcs	.+8      	; 0x2ad2 <__addsf3x+0x1c>
    2aca:	79 f4       	brne	.+30     	; 0x2aea <__addsf3x+0x34>
    2acc:	a6 f5       	brtc	.+104    	; 0x2b36 <__addsf3x+0x80>
    2ace:	0c 94 ba 17 	jmp	0x2f74	; 0x2f74 <__fp_zero>
    2ad2:	0e f4       	brtc	.+2      	; 0x2ad6 <__addsf3x+0x20>
    2ad4:	e0 95       	com	r30
    2ad6:	0b 2e       	mov	r0, r27
    2ad8:	ba 2f       	mov	r27, r26
    2ada:	a0 2d       	mov	r26, r0
    2adc:	0b 01       	movw	r0, r22
    2ade:	b9 01       	movw	r22, r18
    2ae0:	90 01       	movw	r18, r0
    2ae2:	0c 01       	movw	r0, r24
    2ae4:	ca 01       	movw	r24, r20
    2ae6:	a0 01       	movw	r20, r0
    2ae8:	11 24       	eor	r1, r1
    2aea:	ff 27       	eor	r31, r31
    2aec:	59 1b       	sub	r21, r25
    2aee:	99 f0       	breq	.+38     	; 0x2b16 <__addsf3x+0x60>
    2af0:	59 3f       	cpi	r21, 0xF9	; 249
    2af2:	50 f4       	brcc	.+20     	; 0x2b08 <__addsf3x+0x52>
    2af4:	50 3e       	cpi	r21, 0xE0	; 224
    2af6:	68 f1       	brcs	.+90     	; 0x2b52 <__addsf3x+0x9c>
    2af8:	1a 16       	cp	r1, r26
    2afa:	f0 40       	sbci	r31, 0x00	; 0
    2afc:	a2 2f       	mov	r26, r18
    2afe:	23 2f       	mov	r18, r19
    2b00:	34 2f       	mov	r19, r20
    2b02:	44 27       	eor	r20, r20
    2b04:	58 5f       	subi	r21, 0xF8	; 248
    2b06:	f3 cf       	rjmp	.-26     	; 0x2aee <__addsf3x+0x38>
    2b08:	46 95       	lsr	r20
    2b0a:	37 95       	ror	r19
    2b0c:	27 95       	ror	r18
    2b0e:	a7 95       	ror	r26
    2b10:	f0 40       	sbci	r31, 0x00	; 0
    2b12:	53 95       	inc	r21
    2b14:	c9 f7       	brne	.-14     	; 0x2b08 <__addsf3x+0x52>
    2b16:	7e f4       	brtc	.+30     	; 0x2b36 <__addsf3x+0x80>
    2b18:	1f 16       	cp	r1, r31
    2b1a:	ba 0b       	sbc	r27, r26
    2b1c:	62 0b       	sbc	r22, r18
    2b1e:	73 0b       	sbc	r23, r19
    2b20:	84 0b       	sbc	r24, r20
    2b22:	ba f0       	brmi	.+46     	; 0x2b52 <__addsf3x+0x9c>
    2b24:	91 50       	subi	r25, 0x01	; 1
    2b26:	a1 f0       	breq	.+40     	; 0x2b50 <__addsf3x+0x9a>
    2b28:	ff 0f       	add	r31, r31
    2b2a:	bb 1f       	adc	r27, r27
    2b2c:	66 1f       	adc	r22, r22
    2b2e:	77 1f       	adc	r23, r23
    2b30:	88 1f       	adc	r24, r24
    2b32:	c2 f7       	brpl	.-16     	; 0x2b24 <__addsf3x+0x6e>
    2b34:	0e c0       	rjmp	.+28     	; 0x2b52 <__addsf3x+0x9c>
    2b36:	ba 0f       	add	r27, r26
    2b38:	62 1f       	adc	r22, r18
    2b3a:	73 1f       	adc	r23, r19
    2b3c:	84 1f       	adc	r24, r20
    2b3e:	48 f4       	brcc	.+18     	; 0x2b52 <__addsf3x+0x9c>
    2b40:	87 95       	ror	r24
    2b42:	77 95       	ror	r23
    2b44:	67 95       	ror	r22
    2b46:	b7 95       	ror	r27
    2b48:	f7 95       	ror	r31
    2b4a:	9e 3f       	cpi	r25, 0xFE	; 254
    2b4c:	08 f0       	brcs	.+2      	; 0x2b50 <__addsf3x+0x9a>
    2b4e:	b0 cf       	rjmp	.-160    	; 0x2ab0 <__addsf3+0x28>
    2b50:	93 95       	inc	r25
    2b52:	88 0f       	add	r24, r24
    2b54:	08 f0       	brcs	.+2      	; 0x2b58 <__addsf3x+0xa2>
    2b56:	99 27       	eor	r25, r25
    2b58:	ee 0f       	add	r30, r30
    2b5a:	97 95       	ror	r25
    2b5c:	87 95       	ror	r24
    2b5e:	08 95       	ret

00002b60 <asin>:
    2b60:	9f 93       	push	r25
    2b62:	9f 77       	andi	r25, 0x7F	; 127
    2b64:	ee e3       	ldi	r30, 0x3E	; 62
    2b66:	89 37       	cpi	r24, 0x79	; 121
    2b68:	9e 07       	cpc	r25, r30
    2b6a:	28 f4       	brcc	.+10     	; 0x2b76 <asin+0x16>
    2b6c:	ec e7       	ldi	r30, 0x7C	; 124
    2b6e:	f0 e0       	ldi	r31, 0x00	; 0
    2b70:	0e 94 65 17 	call	0x2eca	; 0x2eca <__fp_powsodd>
    2b74:	0c c0       	rjmp	.+24     	; 0x2b8e <asin+0x2e>
    2b76:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <__fp_arccos>
    2b7a:	90 58       	subi	r25, 0x80	; 128
    2b7c:	a2 ea       	ldi	r26, 0xA2	; 162
    2b7e:	2a ed       	ldi	r18, 0xDA	; 218
    2b80:	3f e0       	ldi	r19, 0x0F	; 15
    2b82:	49 ec       	ldi	r20, 0xC9	; 201
    2b84:	5f e3       	ldi	r21, 0x3F	; 63
    2b86:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <__addsf3x>
    2b8a:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <__fp_round>
    2b8e:	0f 90       	pop	r0
    2b90:	07 fc       	sbrc	r0, 7
    2b92:	90 58       	subi	r25, 0x80	; 128
    2b94:	08 95       	ret
    2b96:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <__fp_pscA>
    2b9a:	60 f0       	brcs	.+24     	; 0x2bb4 <asin+0x54>
    2b9c:	80 e8       	ldi	r24, 0x80	; 128
    2b9e:	91 e0       	ldi	r25, 0x01	; 1
    2ba0:	09 f4       	brne	.+2      	; 0x2ba4 <asin+0x44>
    2ba2:	9e ef       	ldi	r25, 0xFE	; 254
    2ba4:	0e 94 80 17 	call	0x2f00	; 0x2f00 <__fp_pscB>
    2ba8:	28 f0       	brcs	.+10     	; 0x2bb4 <asin+0x54>
    2baa:	40 e8       	ldi	r20, 0x80	; 128
    2bac:	51 e0       	ldi	r21, 0x01	; 1
    2bae:	71 f4       	brne	.+28     	; 0x2bcc <atan2+0x10>
    2bb0:	5e ef       	ldi	r21, 0xFE	; 254
    2bb2:	0c c0       	rjmp	.+24     	; 0x2bcc <atan2+0x10>
    2bb4:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <__fp_nan>
    2bb8:	0c 94 ba 17 	jmp	0x2f74	; 0x2f74 <__fp_zero>

00002bbc <atan2>:
    2bbc:	e9 2f       	mov	r30, r25
    2bbe:	e0 78       	andi	r30, 0x80	; 128
    2bc0:	0e 94 98 17 	call	0x2f30	; 0x2f30 <__fp_split3>
    2bc4:	40 f3       	brcs	.-48     	; 0x2b96 <asin+0x36>
    2bc6:	09 2e       	mov	r0, r25
    2bc8:	05 2a       	or	r0, r21
    2bca:	b1 f3       	breq	.-20     	; 0x2bb8 <asin+0x58>
    2bcc:	26 17       	cp	r18, r22
    2bce:	37 07       	cpc	r19, r23
    2bd0:	48 07       	cpc	r20, r24
    2bd2:	59 07       	cpc	r21, r25
    2bd4:	38 f0       	brcs	.+14     	; 0x2be4 <atan2+0x28>
    2bd6:	0e 2e       	mov	r0, r30
    2bd8:	07 f8       	bld	r0, 7
    2bda:	e0 25       	eor	r30, r0
    2bdc:	69 f0       	breq	.+26     	; 0x2bf8 <atan2+0x3c>
    2bde:	e0 25       	eor	r30, r0
    2be0:	e0 64       	ori	r30, 0x40	; 64
    2be2:	0a c0       	rjmp	.+20     	; 0x2bf8 <atan2+0x3c>
    2be4:	ef 63       	ori	r30, 0x3F	; 63
    2be6:	07 f8       	bld	r0, 7
    2be8:	00 94       	com	r0
    2bea:	07 fa       	bst	r0, 7
    2bec:	db 01       	movw	r26, r22
    2bee:	b9 01       	movw	r22, r18
    2bf0:	9d 01       	movw	r18, r26
    2bf2:	dc 01       	movw	r26, r24
    2bf4:	ca 01       	movw	r24, r20
    2bf6:	ad 01       	movw	r20, r26
    2bf8:	ef 93       	push	r30
    2bfa:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <__divsf3_pse>
    2bfe:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <__fp_round>
    2c02:	0e 94 0e 16 	call	0x2c1c	; 0x2c1c <atan>
    2c06:	5f 91       	pop	r21
    2c08:	55 23       	and	r21, r21
    2c0a:	39 f0       	breq	.+14     	; 0x2c1a <atan2+0x5e>
    2c0c:	2b ed       	ldi	r18, 0xDB	; 219
    2c0e:	3f e0       	ldi	r19, 0x0F	; 15
    2c10:	49 e4       	ldi	r20, 0x49	; 73
    2c12:	50 fd       	sbrc	r21, 0
    2c14:	49 ec       	ldi	r20, 0xC9	; 201
    2c16:	0c 94 44 15 	jmp	0x2a88	; 0x2a88 <__addsf3>
    2c1a:	08 95       	ret

00002c1c <atan>:
    2c1c:	df 93       	push	r29
    2c1e:	dd 27       	eor	r29, r29
    2c20:	b9 2f       	mov	r27, r25
    2c22:	bf 77       	andi	r27, 0x7F	; 127
    2c24:	40 e8       	ldi	r20, 0x80	; 128
    2c26:	5f e3       	ldi	r21, 0x3F	; 63
    2c28:	16 16       	cp	r1, r22
    2c2a:	17 06       	cpc	r1, r23
    2c2c:	48 07       	cpc	r20, r24
    2c2e:	5b 07       	cpc	r21, r27
    2c30:	18 f4       	brcc	.+6      	; 0x2c38 <atan+0x1c>
    2c32:	d9 2f       	mov	r29, r25
    2c34:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <inverse>
    2c38:	9f 93       	push	r25
    2c3a:	8f 93       	push	r24
    2c3c:	7f 93       	push	r23
    2c3e:	6f 93       	push	r22
    2c40:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <square>
    2c44:	e0 e9       	ldi	r30, 0x90	; 144
    2c46:	f0 e0       	ldi	r31, 0x00	; 0
    2c48:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <__fp_powser>
    2c4c:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <__fp_round>
    2c50:	2f 91       	pop	r18
    2c52:	3f 91       	pop	r19
    2c54:	4f 91       	pop	r20
    2c56:	5f 91       	pop	r21
    2c58:	0e 94 dc 17 	call	0x2fb8	; 0x2fb8 <__mulsf3x>
    2c5c:	dd 23       	and	r29, r29
    2c5e:	51 f0       	breq	.+20     	; 0x2c74 <atan+0x58>
    2c60:	90 58       	subi	r25, 0x80	; 128
    2c62:	a2 ea       	ldi	r26, 0xA2	; 162
    2c64:	2a ed       	ldi	r18, 0xDA	; 218
    2c66:	3f e0       	ldi	r19, 0x0F	; 15
    2c68:	49 ec       	ldi	r20, 0xC9	; 201
    2c6a:	5f e3       	ldi	r21, 0x3F	; 63
    2c6c:	d0 78       	andi	r29, 0x80	; 128
    2c6e:	5d 27       	eor	r21, r29
    2c70:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <__addsf3x>
    2c74:	df 91       	pop	r29
    2c76:	0c 94 87 17 	jmp	0x2f0e	; 0x2f0e <__fp_round>

00002c7a <__cmpsf2>:
    2c7a:	0e 94 11 17 	call	0x2e22	; 0x2e22 <__fp_cmp>
    2c7e:	08 f4       	brcc	.+2      	; 0x2c82 <__cmpsf2+0x8>
    2c80:	81 e0       	ldi	r24, 0x01	; 1
    2c82:	08 95       	ret

00002c84 <__divsf3>:
    2c84:	0e 94 56 16 	call	0x2cac	; 0x2cac <__divsf3x>
    2c88:	0c 94 87 17 	jmp	0x2f0e	; 0x2f0e <__fp_round>
    2c8c:	0e 94 80 17 	call	0x2f00	; 0x2f00 <__fp_pscB>
    2c90:	58 f0       	brcs	.+22     	; 0x2ca8 <__divsf3+0x24>
    2c92:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <__fp_pscA>
    2c96:	40 f0       	brcs	.+16     	; 0x2ca8 <__divsf3+0x24>
    2c98:	29 f4       	brne	.+10     	; 0x2ca4 <__divsf3+0x20>
    2c9a:	5f 3f       	cpi	r21, 0xFF	; 255
    2c9c:	29 f0       	breq	.+10     	; 0x2ca8 <__divsf3+0x24>
    2c9e:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <__fp_inf>
    2ca2:	51 11       	cpse	r21, r1
    2ca4:	0c 94 bb 17 	jmp	0x2f76	; 0x2f76 <__fp_szero>
    2ca8:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <__fp_nan>

00002cac <__divsf3x>:
    2cac:	0e 94 98 17 	call	0x2f30	; 0x2f30 <__fp_split3>
    2cb0:	68 f3       	brcs	.-38     	; 0x2c8c <__divsf3+0x8>

00002cb2 <__divsf3_pse>:
    2cb2:	99 23       	and	r25, r25
    2cb4:	b1 f3       	breq	.-20     	; 0x2ca2 <__divsf3+0x1e>
    2cb6:	55 23       	and	r21, r21
    2cb8:	91 f3       	breq	.-28     	; 0x2c9e <__divsf3+0x1a>
    2cba:	95 1b       	sub	r25, r21
    2cbc:	55 0b       	sbc	r21, r21
    2cbe:	bb 27       	eor	r27, r27
    2cc0:	aa 27       	eor	r26, r26
    2cc2:	62 17       	cp	r22, r18
    2cc4:	73 07       	cpc	r23, r19
    2cc6:	84 07       	cpc	r24, r20
    2cc8:	38 f0       	brcs	.+14     	; 0x2cd8 <__divsf3_pse+0x26>
    2cca:	9f 5f       	subi	r25, 0xFF	; 255
    2ccc:	5f 4f       	sbci	r21, 0xFF	; 255
    2cce:	22 0f       	add	r18, r18
    2cd0:	33 1f       	adc	r19, r19
    2cd2:	44 1f       	adc	r20, r20
    2cd4:	aa 1f       	adc	r26, r26
    2cd6:	a9 f3       	breq	.-22     	; 0x2cc2 <__divsf3_pse+0x10>
    2cd8:	35 d0       	rcall	.+106    	; 0x2d44 <__divsf3_pse+0x92>
    2cda:	0e 2e       	mov	r0, r30
    2cdc:	3a f0       	brmi	.+14     	; 0x2cec <__divsf3_pse+0x3a>
    2cde:	e0 e8       	ldi	r30, 0x80	; 128
    2ce0:	32 d0       	rcall	.+100    	; 0x2d46 <__divsf3_pse+0x94>
    2ce2:	91 50       	subi	r25, 0x01	; 1
    2ce4:	50 40       	sbci	r21, 0x00	; 0
    2ce6:	e6 95       	lsr	r30
    2ce8:	00 1c       	adc	r0, r0
    2cea:	ca f7       	brpl	.-14     	; 0x2cde <__divsf3_pse+0x2c>
    2cec:	2b d0       	rcall	.+86     	; 0x2d44 <__divsf3_pse+0x92>
    2cee:	fe 2f       	mov	r31, r30
    2cf0:	29 d0       	rcall	.+82     	; 0x2d44 <__divsf3_pse+0x92>
    2cf2:	66 0f       	add	r22, r22
    2cf4:	77 1f       	adc	r23, r23
    2cf6:	88 1f       	adc	r24, r24
    2cf8:	bb 1f       	adc	r27, r27
    2cfa:	26 17       	cp	r18, r22
    2cfc:	37 07       	cpc	r19, r23
    2cfe:	48 07       	cpc	r20, r24
    2d00:	ab 07       	cpc	r26, r27
    2d02:	b0 e8       	ldi	r27, 0x80	; 128
    2d04:	09 f0       	breq	.+2      	; 0x2d08 <__divsf3_pse+0x56>
    2d06:	bb 0b       	sbc	r27, r27
    2d08:	80 2d       	mov	r24, r0
    2d0a:	bf 01       	movw	r22, r30
    2d0c:	ff 27       	eor	r31, r31
    2d0e:	93 58       	subi	r25, 0x83	; 131
    2d10:	5f 4f       	sbci	r21, 0xFF	; 255
    2d12:	3a f0       	brmi	.+14     	; 0x2d22 <__divsf3_pse+0x70>
    2d14:	9e 3f       	cpi	r25, 0xFE	; 254
    2d16:	51 05       	cpc	r21, r1
    2d18:	78 f0       	brcs	.+30     	; 0x2d38 <__divsf3_pse+0x86>
    2d1a:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <__fp_inf>
    2d1e:	0c 94 bb 17 	jmp	0x2f76	; 0x2f76 <__fp_szero>
    2d22:	5f 3f       	cpi	r21, 0xFF	; 255
    2d24:	e4 f3       	brlt	.-8      	; 0x2d1e <__divsf3_pse+0x6c>
    2d26:	98 3e       	cpi	r25, 0xE8	; 232
    2d28:	d4 f3       	brlt	.-12     	; 0x2d1e <__divsf3_pse+0x6c>
    2d2a:	86 95       	lsr	r24
    2d2c:	77 95       	ror	r23
    2d2e:	67 95       	ror	r22
    2d30:	b7 95       	ror	r27
    2d32:	f7 95       	ror	r31
    2d34:	9f 5f       	subi	r25, 0xFF	; 255
    2d36:	c9 f7       	brne	.-14     	; 0x2d2a <__divsf3_pse+0x78>
    2d38:	88 0f       	add	r24, r24
    2d3a:	91 1d       	adc	r25, r1
    2d3c:	96 95       	lsr	r25
    2d3e:	87 95       	ror	r24
    2d40:	97 f9       	bld	r25, 7
    2d42:	08 95       	ret
    2d44:	e1 e0       	ldi	r30, 0x01	; 1
    2d46:	66 0f       	add	r22, r22
    2d48:	77 1f       	adc	r23, r23
    2d4a:	88 1f       	adc	r24, r24
    2d4c:	bb 1f       	adc	r27, r27
    2d4e:	62 17       	cp	r22, r18
    2d50:	73 07       	cpc	r23, r19
    2d52:	84 07       	cpc	r24, r20
    2d54:	ba 07       	cpc	r27, r26
    2d56:	20 f0       	brcs	.+8      	; 0x2d60 <__divsf3_pse+0xae>
    2d58:	62 1b       	sub	r22, r18
    2d5a:	73 0b       	sbc	r23, r19
    2d5c:	84 0b       	sbc	r24, r20
    2d5e:	ba 0b       	sbc	r27, r26
    2d60:	ee 1f       	adc	r30, r30
    2d62:	88 f7       	brcc	.-30     	; 0x2d46 <__divsf3_pse+0x94>
    2d64:	e0 95       	com	r30
    2d66:	08 95       	ret

00002d68 <__floatunsisf>:
    2d68:	e8 94       	clt
    2d6a:	09 c0       	rjmp	.+18     	; 0x2d7e <__floatsisf+0x12>

00002d6c <__floatsisf>:
    2d6c:	97 fb       	bst	r25, 7
    2d6e:	3e f4       	brtc	.+14     	; 0x2d7e <__floatsisf+0x12>
    2d70:	90 95       	com	r25
    2d72:	80 95       	com	r24
    2d74:	70 95       	com	r23
    2d76:	61 95       	neg	r22
    2d78:	7f 4f       	sbci	r23, 0xFF	; 255
    2d7a:	8f 4f       	sbci	r24, 0xFF	; 255
    2d7c:	9f 4f       	sbci	r25, 0xFF	; 255
    2d7e:	99 23       	and	r25, r25
    2d80:	a9 f0       	breq	.+42     	; 0x2dac <__floatsisf+0x40>
    2d82:	f9 2f       	mov	r31, r25
    2d84:	96 e9       	ldi	r25, 0x96	; 150
    2d86:	bb 27       	eor	r27, r27
    2d88:	93 95       	inc	r25
    2d8a:	f6 95       	lsr	r31
    2d8c:	87 95       	ror	r24
    2d8e:	77 95       	ror	r23
    2d90:	67 95       	ror	r22
    2d92:	b7 95       	ror	r27
    2d94:	f1 11       	cpse	r31, r1
    2d96:	f8 cf       	rjmp	.-16     	; 0x2d88 <__floatsisf+0x1c>
    2d98:	fa f4       	brpl	.+62     	; 0x2dd8 <__floatsisf+0x6c>
    2d9a:	bb 0f       	add	r27, r27
    2d9c:	11 f4       	brne	.+4      	; 0x2da2 <__floatsisf+0x36>
    2d9e:	60 ff       	sbrs	r22, 0
    2da0:	1b c0       	rjmp	.+54     	; 0x2dd8 <__floatsisf+0x6c>
    2da2:	6f 5f       	subi	r22, 0xFF	; 255
    2da4:	7f 4f       	sbci	r23, 0xFF	; 255
    2da6:	8f 4f       	sbci	r24, 0xFF	; 255
    2da8:	9f 4f       	sbci	r25, 0xFF	; 255
    2daa:	16 c0       	rjmp	.+44     	; 0x2dd8 <__floatsisf+0x6c>
    2dac:	88 23       	and	r24, r24
    2dae:	11 f0       	breq	.+4      	; 0x2db4 <__floatsisf+0x48>
    2db0:	96 e9       	ldi	r25, 0x96	; 150
    2db2:	11 c0       	rjmp	.+34     	; 0x2dd6 <__floatsisf+0x6a>
    2db4:	77 23       	and	r23, r23
    2db6:	21 f0       	breq	.+8      	; 0x2dc0 <__floatsisf+0x54>
    2db8:	9e e8       	ldi	r25, 0x8E	; 142
    2dba:	87 2f       	mov	r24, r23
    2dbc:	76 2f       	mov	r23, r22
    2dbe:	05 c0       	rjmp	.+10     	; 0x2dca <__floatsisf+0x5e>
    2dc0:	66 23       	and	r22, r22
    2dc2:	71 f0       	breq	.+28     	; 0x2de0 <__floatsisf+0x74>
    2dc4:	96 e8       	ldi	r25, 0x86	; 134
    2dc6:	86 2f       	mov	r24, r22
    2dc8:	70 e0       	ldi	r23, 0x00	; 0
    2dca:	60 e0       	ldi	r22, 0x00	; 0
    2dcc:	2a f0       	brmi	.+10     	; 0x2dd8 <__floatsisf+0x6c>
    2dce:	9a 95       	dec	r25
    2dd0:	66 0f       	add	r22, r22
    2dd2:	77 1f       	adc	r23, r23
    2dd4:	88 1f       	adc	r24, r24
    2dd6:	da f7       	brpl	.-10     	; 0x2dce <__floatsisf+0x62>
    2dd8:	88 0f       	add	r24, r24
    2dda:	96 95       	lsr	r25
    2ddc:	87 95       	ror	r24
    2dde:	97 f9       	bld	r25, 7
    2de0:	08 95       	ret

00002de2 <__fp_arccos>:
    2de2:	df 93       	push	r29
    2de4:	cf 93       	push	r28
    2de6:	1f 93       	push	r17
    2de8:	0f 93       	push	r16
    2dea:	8b 01       	movw	r16, r22
    2dec:	ec 01       	movw	r28, r24
    2dee:	ed eb       	ldi	r30, 0xBD	; 189
    2df0:	f0 e0       	ldi	r31, 0x00	; 0
    2df2:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <__fp_powser>
    2df6:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <__fp_round>
    2dfa:	98 01       	movw	r18, r16
    2dfc:	ae 01       	movw	r20, r28
    2dfe:	8b 01       	movw	r16, r22
    2e00:	ec 01       	movw	r28, r24
    2e02:	60 e0       	ldi	r22, 0x00	; 0
    2e04:	70 e0       	ldi	r23, 0x00	; 0
    2e06:	80 e8       	ldi	r24, 0x80	; 128
    2e08:	9f e3       	ldi	r25, 0x3F	; 63
    2e0a:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__subsf3>
    2e0e:	0e 94 3c 18 	call	0x3078	; 0x3078 <sqrt>
    2e12:	98 01       	movw	r18, r16
    2e14:	ae 01       	movw	r20, r28
    2e16:	0f 91       	pop	r16
    2e18:	1f 91       	pop	r17
    2e1a:	cf 91       	pop	r28
    2e1c:	df 91       	pop	r29
    2e1e:	0c 94 dc 17 	jmp	0x2fb8	; 0x2fb8 <__mulsf3x>

00002e22 <__fp_cmp>:
    2e22:	99 0f       	add	r25, r25
    2e24:	00 08       	sbc	r0, r0
    2e26:	55 0f       	add	r21, r21
    2e28:	aa 0b       	sbc	r26, r26
    2e2a:	e0 e8       	ldi	r30, 0x80	; 128
    2e2c:	fe ef       	ldi	r31, 0xFE	; 254
    2e2e:	16 16       	cp	r1, r22
    2e30:	17 06       	cpc	r1, r23
    2e32:	e8 07       	cpc	r30, r24
    2e34:	f9 07       	cpc	r31, r25
    2e36:	c0 f0       	brcs	.+48     	; 0x2e68 <__fp_cmp+0x46>
    2e38:	12 16       	cp	r1, r18
    2e3a:	13 06       	cpc	r1, r19
    2e3c:	e4 07       	cpc	r30, r20
    2e3e:	f5 07       	cpc	r31, r21
    2e40:	98 f0       	brcs	.+38     	; 0x2e68 <__fp_cmp+0x46>
    2e42:	62 1b       	sub	r22, r18
    2e44:	73 0b       	sbc	r23, r19
    2e46:	84 0b       	sbc	r24, r20
    2e48:	95 0b       	sbc	r25, r21
    2e4a:	39 f4       	brne	.+14     	; 0x2e5a <__fp_cmp+0x38>
    2e4c:	0a 26       	eor	r0, r26
    2e4e:	61 f0       	breq	.+24     	; 0x2e68 <__fp_cmp+0x46>
    2e50:	23 2b       	or	r18, r19
    2e52:	24 2b       	or	r18, r20
    2e54:	25 2b       	or	r18, r21
    2e56:	21 f4       	brne	.+8      	; 0x2e60 <__fp_cmp+0x3e>
    2e58:	08 95       	ret
    2e5a:	0a 26       	eor	r0, r26
    2e5c:	09 f4       	brne	.+2      	; 0x2e60 <__fp_cmp+0x3e>
    2e5e:	a1 40       	sbci	r26, 0x01	; 1
    2e60:	a6 95       	lsr	r26
    2e62:	8f ef       	ldi	r24, 0xFF	; 255
    2e64:	81 1d       	adc	r24, r1
    2e66:	81 1d       	adc	r24, r1
    2e68:	08 95       	ret

00002e6a <__fp_inf>:
    2e6a:	97 f9       	bld	r25, 7
    2e6c:	9f 67       	ori	r25, 0x7F	; 127
    2e6e:	80 e8       	ldi	r24, 0x80	; 128
    2e70:	70 e0       	ldi	r23, 0x00	; 0
    2e72:	60 e0       	ldi	r22, 0x00	; 0
    2e74:	08 95       	ret

00002e76 <__fp_nan>:
    2e76:	9f ef       	ldi	r25, 0xFF	; 255
    2e78:	80 ec       	ldi	r24, 0xC0	; 192
    2e7a:	08 95       	ret

00002e7c <__fp_powser>:
    2e7c:	df 93       	push	r29
    2e7e:	cf 93       	push	r28
    2e80:	1f 93       	push	r17
    2e82:	0f 93       	push	r16
    2e84:	ff 92       	push	r15
    2e86:	ef 92       	push	r14
    2e88:	df 92       	push	r13
    2e8a:	7b 01       	movw	r14, r22
    2e8c:	8c 01       	movw	r16, r24
    2e8e:	68 94       	set
    2e90:	06 c0       	rjmp	.+12     	; 0x2e9e <__fp_powser+0x22>
    2e92:	da 2e       	mov	r13, r26
    2e94:	ef 01       	movw	r28, r30
    2e96:	0e 94 dc 17 	call	0x2fb8	; 0x2fb8 <__mulsf3x>
    2e9a:	fe 01       	movw	r30, r28
    2e9c:	e8 94       	clt
    2e9e:	a5 91       	lpm	r26, Z+
    2ea0:	25 91       	lpm	r18, Z+
    2ea2:	35 91       	lpm	r19, Z+
    2ea4:	45 91       	lpm	r20, Z+
    2ea6:	55 91       	lpm	r21, Z+
    2ea8:	a6 f3       	brts	.-24     	; 0x2e92 <__fp_powser+0x16>
    2eaa:	ef 01       	movw	r28, r30
    2eac:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <__addsf3x>
    2eb0:	fe 01       	movw	r30, r28
    2eb2:	97 01       	movw	r18, r14
    2eb4:	a8 01       	movw	r20, r16
    2eb6:	da 94       	dec	r13
    2eb8:	69 f7       	brne	.-38     	; 0x2e94 <__fp_powser+0x18>
    2eba:	df 90       	pop	r13
    2ebc:	ef 90       	pop	r14
    2ebe:	ff 90       	pop	r15
    2ec0:	0f 91       	pop	r16
    2ec2:	1f 91       	pop	r17
    2ec4:	cf 91       	pop	r28
    2ec6:	df 91       	pop	r29
    2ec8:	08 95       	ret

00002eca <__fp_powsodd>:
    2eca:	9f 93       	push	r25
    2ecc:	8f 93       	push	r24
    2ece:	7f 93       	push	r23
    2ed0:	6f 93       	push	r22
    2ed2:	ff 93       	push	r31
    2ed4:	ef 93       	push	r30
    2ed6:	9b 01       	movw	r18, r22
    2ed8:	ac 01       	movw	r20, r24
    2eda:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <__mulsf3>
    2ede:	ef 91       	pop	r30
    2ee0:	ff 91       	pop	r31
    2ee2:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <__fp_powser>
    2ee6:	2f 91       	pop	r18
    2ee8:	3f 91       	pop	r19
    2eea:	4f 91       	pop	r20
    2eec:	5f 91       	pop	r21
    2eee:	0c 94 c9 17 	jmp	0x2f92	; 0x2f92 <__mulsf3>

00002ef2 <__fp_pscA>:
    2ef2:	00 24       	eor	r0, r0
    2ef4:	0a 94       	dec	r0
    2ef6:	16 16       	cp	r1, r22
    2ef8:	17 06       	cpc	r1, r23
    2efa:	18 06       	cpc	r1, r24
    2efc:	09 06       	cpc	r0, r25
    2efe:	08 95       	ret

00002f00 <__fp_pscB>:
    2f00:	00 24       	eor	r0, r0
    2f02:	0a 94       	dec	r0
    2f04:	12 16       	cp	r1, r18
    2f06:	13 06       	cpc	r1, r19
    2f08:	14 06       	cpc	r1, r20
    2f0a:	05 06       	cpc	r0, r21
    2f0c:	08 95       	ret

00002f0e <__fp_round>:
    2f0e:	09 2e       	mov	r0, r25
    2f10:	03 94       	inc	r0
    2f12:	00 0c       	add	r0, r0
    2f14:	11 f4       	brne	.+4      	; 0x2f1a <__fp_round+0xc>
    2f16:	88 23       	and	r24, r24
    2f18:	52 f0       	brmi	.+20     	; 0x2f2e <__fp_round+0x20>
    2f1a:	bb 0f       	add	r27, r27
    2f1c:	40 f4       	brcc	.+16     	; 0x2f2e <__fp_round+0x20>
    2f1e:	bf 2b       	or	r27, r31
    2f20:	11 f4       	brne	.+4      	; 0x2f26 <__fp_round+0x18>
    2f22:	60 ff       	sbrs	r22, 0
    2f24:	04 c0       	rjmp	.+8      	; 0x2f2e <__fp_round+0x20>
    2f26:	6f 5f       	subi	r22, 0xFF	; 255
    2f28:	7f 4f       	sbci	r23, 0xFF	; 255
    2f2a:	8f 4f       	sbci	r24, 0xFF	; 255
    2f2c:	9f 4f       	sbci	r25, 0xFF	; 255
    2f2e:	08 95       	ret

00002f30 <__fp_split3>:
    2f30:	57 fd       	sbrc	r21, 7
    2f32:	90 58       	subi	r25, 0x80	; 128
    2f34:	44 0f       	add	r20, r20
    2f36:	55 1f       	adc	r21, r21
    2f38:	59 f0       	breq	.+22     	; 0x2f50 <__fp_splitA+0x10>
    2f3a:	5f 3f       	cpi	r21, 0xFF	; 255
    2f3c:	71 f0       	breq	.+28     	; 0x2f5a <__fp_splitA+0x1a>
    2f3e:	47 95       	ror	r20

00002f40 <__fp_splitA>:
    2f40:	88 0f       	add	r24, r24
    2f42:	97 fb       	bst	r25, 7
    2f44:	99 1f       	adc	r25, r25
    2f46:	61 f0       	breq	.+24     	; 0x2f60 <__fp_splitA+0x20>
    2f48:	9f 3f       	cpi	r25, 0xFF	; 255
    2f4a:	79 f0       	breq	.+30     	; 0x2f6a <__fp_splitA+0x2a>
    2f4c:	87 95       	ror	r24
    2f4e:	08 95       	ret
    2f50:	12 16       	cp	r1, r18
    2f52:	13 06       	cpc	r1, r19
    2f54:	14 06       	cpc	r1, r20
    2f56:	55 1f       	adc	r21, r21
    2f58:	f2 cf       	rjmp	.-28     	; 0x2f3e <__fp_split3+0xe>
    2f5a:	46 95       	lsr	r20
    2f5c:	f1 df       	rcall	.-30     	; 0x2f40 <__fp_splitA>
    2f5e:	08 c0       	rjmp	.+16     	; 0x2f70 <__fp_splitA+0x30>
    2f60:	16 16       	cp	r1, r22
    2f62:	17 06       	cpc	r1, r23
    2f64:	18 06       	cpc	r1, r24
    2f66:	99 1f       	adc	r25, r25
    2f68:	f1 cf       	rjmp	.-30     	; 0x2f4c <__fp_splitA+0xc>
    2f6a:	86 95       	lsr	r24
    2f6c:	71 05       	cpc	r23, r1
    2f6e:	61 05       	cpc	r22, r1
    2f70:	08 94       	sec
    2f72:	08 95       	ret

00002f74 <__fp_zero>:
    2f74:	e8 94       	clt

00002f76 <__fp_szero>:
    2f76:	bb 27       	eor	r27, r27
    2f78:	66 27       	eor	r22, r22
    2f7a:	77 27       	eor	r23, r23
    2f7c:	cb 01       	movw	r24, r22
    2f7e:	97 f9       	bld	r25, 7
    2f80:	08 95       	ret

00002f82 <inverse>:
    2f82:	9b 01       	movw	r18, r22
    2f84:	ac 01       	movw	r20, r24
    2f86:	60 e0       	ldi	r22, 0x00	; 0
    2f88:	70 e0       	ldi	r23, 0x00	; 0
    2f8a:	80 e8       	ldi	r24, 0x80	; 128
    2f8c:	9f e3       	ldi	r25, 0x3F	; 63
    2f8e:	0c 94 42 16 	jmp	0x2c84	; 0x2c84 <__divsf3>

00002f92 <__mulsf3>:
    2f92:	0e 94 dc 17 	call	0x2fb8	; 0x2fb8 <__mulsf3x>
    2f96:	0c 94 87 17 	jmp	0x2f0e	; 0x2f0e <__fp_round>
    2f9a:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <__fp_pscA>
    2f9e:	38 f0       	brcs	.+14     	; 0x2fae <__mulsf3+0x1c>
    2fa0:	0e 94 80 17 	call	0x2f00	; 0x2f00 <__fp_pscB>
    2fa4:	20 f0       	brcs	.+8      	; 0x2fae <__mulsf3+0x1c>
    2fa6:	95 23       	and	r25, r21
    2fa8:	11 f0       	breq	.+4      	; 0x2fae <__mulsf3+0x1c>
    2faa:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <__fp_inf>
    2fae:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <__fp_nan>
    2fb2:	11 24       	eor	r1, r1
    2fb4:	0c 94 bb 17 	jmp	0x2f76	; 0x2f76 <__fp_szero>

00002fb8 <__mulsf3x>:
    2fb8:	0e 94 98 17 	call	0x2f30	; 0x2f30 <__fp_split3>
    2fbc:	70 f3       	brcs	.-36     	; 0x2f9a <__mulsf3+0x8>

00002fbe <__mulsf3_pse>:
    2fbe:	95 9f       	mul	r25, r21
    2fc0:	c1 f3       	breq	.-16     	; 0x2fb2 <__mulsf3+0x20>
    2fc2:	95 0f       	add	r25, r21
    2fc4:	50 e0       	ldi	r21, 0x00	; 0
    2fc6:	55 1f       	adc	r21, r21
    2fc8:	62 9f       	mul	r22, r18
    2fca:	f0 01       	movw	r30, r0
    2fcc:	72 9f       	mul	r23, r18
    2fce:	bb 27       	eor	r27, r27
    2fd0:	f0 0d       	add	r31, r0
    2fd2:	b1 1d       	adc	r27, r1
    2fd4:	63 9f       	mul	r22, r19
    2fd6:	aa 27       	eor	r26, r26
    2fd8:	f0 0d       	add	r31, r0
    2fda:	b1 1d       	adc	r27, r1
    2fdc:	aa 1f       	adc	r26, r26
    2fde:	64 9f       	mul	r22, r20
    2fe0:	66 27       	eor	r22, r22
    2fe2:	b0 0d       	add	r27, r0
    2fe4:	a1 1d       	adc	r26, r1
    2fe6:	66 1f       	adc	r22, r22
    2fe8:	82 9f       	mul	r24, r18
    2fea:	22 27       	eor	r18, r18
    2fec:	b0 0d       	add	r27, r0
    2fee:	a1 1d       	adc	r26, r1
    2ff0:	62 1f       	adc	r22, r18
    2ff2:	73 9f       	mul	r23, r19
    2ff4:	b0 0d       	add	r27, r0
    2ff6:	a1 1d       	adc	r26, r1
    2ff8:	62 1f       	adc	r22, r18
    2ffa:	83 9f       	mul	r24, r19
    2ffc:	a0 0d       	add	r26, r0
    2ffe:	61 1d       	adc	r22, r1
    3000:	22 1f       	adc	r18, r18
    3002:	74 9f       	mul	r23, r20
    3004:	33 27       	eor	r19, r19
    3006:	a0 0d       	add	r26, r0
    3008:	61 1d       	adc	r22, r1
    300a:	23 1f       	adc	r18, r19
    300c:	84 9f       	mul	r24, r20
    300e:	60 0d       	add	r22, r0
    3010:	21 1d       	adc	r18, r1
    3012:	82 2f       	mov	r24, r18
    3014:	76 2f       	mov	r23, r22
    3016:	6a 2f       	mov	r22, r26
    3018:	11 24       	eor	r1, r1
    301a:	9f 57       	subi	r25, 0x7F	; 127
    301c:	50 40       	sbci	r21, 0x00	; 0
    301e:	9a f0       	brmi	.+38     	; 0x3046 <__mulsf3_pse+0x88>
    3020:	f1 f0       	breq	.+60     	; 0x305e <__mulsf3_pse+0xa0>
    3022:	88 23       	and	r24, r24
    3024:	4a f0       	brmi	.+18     	; 0x3038 <__mulsf3_pse+0x7a>
    3026:	ee 0f       	add	r30, r30
    3028:	ff 1f       	adc	r31, r31
    302a:	bb 1f       	adc	r27, r27
    302c:	66 1f       	adc	r22, r22
    302e:	77 1f       	adc	r23, r23
    3030:	88 1f       	adc	r24, r24
    3032:	91 50       	subi	r25, 0x01	; 1
    3034:	50 40       	sbci	r21, 0x00	; 0
    3036:	a9 f7       	brne	.-22     	; 0x3022 <__mulsf3_pse+0x64>
    3038:	9e 3f       	cpi	r25, 0xFE	; 254
    303a:	51 05       	cpc	r21, r1
    303c:	80 f0       	brcs	.+32     	; 0x305e <__mulsf3_pse+0xa0>
    303e:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <__fp_inf>
    3042:	0c 94 bb 17 	jmp	0x2f76	; 0x2f76 <__fp_szero>
    3046:	5f 3f       	cpi	r21, 0xFF	; 255
    3048:	e4 f3       	brlt	.-8      	; 0x3042 <__mulsf3_pse+0x84>
    304a:	98 3e       	cpi	r25, 0xE8	; 232
    304c:	d4 f3       	brlt	.-12     	; 0x3042 <__mulsf3_pse+0x84>
    304e:	86 95       	lsr	r24
    3050:	77 95       	ror	r23
    3052:	67 95       	ror	r22
    3054:	b7 95       	ror	r27
    3056:	f7 95       	ror	r31
    3058:	e7 95       	ror	r30
    305a:	9f 5f       	subi	r25, 0xFF	; 255
    305c:	c1 f7       	brne	.-16     	; 0x304e <__mulsf3_pse+0x90>
    305e:	fe 2b       	or	r31, r30
    3060:	88 0f       	add	r24, r24
    3062:	91 1d       	adc	r25, r1
    3064:	96 95       	lsr	r25
    3066:	87 95       	ror	r24
    3068:	97 f9       	bld	r25, 7
    306a:	08 95       	ret
    306c:	19 f4       	brne	.+6      	; 0x3074 <__mulsf3_pse+0xb6>
    306e:	16 f4       	brtc	.+4      	; 0x3074 <__mulsf3_pse+0xb6>
    3070:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <__fp_nan>
    3074:	0c 94 80 18 	jmp	0x3100	; 0x3100 <__fp_mpack>

00003078 <sqrt>:
    3078:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <__fp_splitA>
    307c:	b8 f3       	brcs	.-18     	; 0x306c <__mulsf3_pse+0xae>
    307e:	99 23       	and	r25, r25
    3080:	c9 f3       	breq	.-14     	; 0x3074 <__mulsf3_pse+0xb6>
    3082:	b6 f3       	brts	.-20     	; 0x3070 <__mulsf3_pse+0xb2>
    3084:	9f 57       	subi	r25, 0x7F	; 127
    3086:	55 0b       	sbc	r21, r21
    3088:	87 ff       	sbrs	r24, 7
    308a:	0e 94 8e 18 	call	0x311c	; 0x311c <__fp_norm2>
    308e:	00 24       	eor	r0, r0
    3090:	a0 e6       	ldi	r26, 0x60	; 96
    3092:	40 ea       	ldi	r20, 0xA0	; 160
    3094:	90 01       	movw	r18, r0
    3096:	80 58       	subi	r24, 0x80	; 128
    3098:	56 95       	lsr	r21
    309a:	97 95       	ror	r25
    309c:	28 f4       	brcc	.+10     	; 0x30a8 <sqrt+0x30>
    309e:	80 5c       	subi	r24, 0xC0	; 192
    30a0:	66 0f       	add	r22, r22
    30a2:	77 1f       	adc	r23, r23
    30a4:	88 1f       	adc	r24, r24
    30a6:	20 f0       	brcs	.+8      	; 0x30b0 <sqrt+0x38>
    30a8:	26 17       	cp	r18, r22
    30aa:	37 07       	cpc	r19, r23
    30ac:	48 07       	cpc	r20, r24
    30ae:	30 f4       	brcc	.+12     	; 0x30bc <sqrt+0x44>
    30b0:	62 1b       	sub	r22, r18
    30b2:	73 0b       	sbc	r23, r19
    30b4:	84 0b       	sbc	r24, r20
    30b6:	20 29       	or	r18, r0
    30b8:	31 29       	or	r19, r1
    30ba:	4a 2b       	or	r20, r26
    30bc:	a6 95       	lsr	r26
    30be:	17 94       	ror	r1
    30c0:	07 94       	ror	r0
    30c2:	20 25       	eor	r18, r0
    30c4:	31 25       	eor	r19, r1
    30c6:	4a 27       	eor	r20, r26
    30c8:	58 f7       	brcc	.-42     	; 0x30a0 <sqrt+0x28>
    30ca:	66 0f       	add	r22, r22
    30cc:	77 1f       	adc	r23, r23
    30ce:	88 1f       	adc	r24, r24
    30d0:	20 f0       	brcs	.+8      	; 0x30da <sqrt+0x62>
    30d2:	26 17       	cp	r18, r22
    30d4:	37 07       	cpc	r19, r23
    30d6:	48 07       	cpc	r20, r24
    30d8:	30 f4       	brcc	.+12     	; 0x30e6 <sqrt+0x6e>
    30da:	62 0b       	sbc	r22, r18
    30dc:	73 0b       	sbc	r23, r19
    30de:	84 0b       	sbc	r24, r20
    30e0:	20 0d       	add	r18, r0
    30e2:	31 1d       	adc	r19, r1
    30e4:	41 1d       	adc	r20, r1
    30e6:	a0 95       	com	r26
    30e8:	81 f7       	brne	.-32     	; 0x30ca <sqrt+0x52>
    30ea:	b9 01       	movw	r22, r18
    30ec:	84 2f       	mov	r24, r20
    30ee:	91 58       	subi	r25, 0x81	; 129
    30f0:	88 0f       	add	r24, r24
    30f2:	96 95       	lsr	r25
    30f4:	87 95       	ror	r24
    30f6:	08 95       	ret

000030f8 <square>:
    30f8:	9b 01       	movw	r18, r22
    30fa:	ac 01       	movw	r20, r24
    30fc:	0c 94 c9 17 	jmp	0x2f92	; 0x2f92 <__mulsf3>

00003100 <__fp_mpack>:
    3100:	9f 3f       	cpi	r25, 0xFF	; 255
    3102:	31 f0       	breq	.+12     	; 0x3110 <__fp_mpack_finite+0xc>

00003104 <__fp_mpack_finite>:
    3104:	91 50       	subi	r25, 0x01	; 1
    3106:	20 f4       	brcc	.+8      	; 0x3110 <__fp_mpack_finite+0xc>
    3108:	87 95       	ror	r24
    310a:	77 95       	ror	r23
    310c:	67 95       	ror	r22
    310e:	b7 95       	ror	r27
    3110:	88 0f       	add	r24, r24
    3112:	91 1d       	adc	r25, r1
    3114:	96 95       	lsr	r25
    3116:	87 95       	ror	r24
    3118:	97 f9       	bld	r25, 7
    311a:	08 95       	ret

0000311c <__fp_norm2>:
    311c:	91 50       	subi	r25, 0x01	; 1
    311e:	50 40       	sbci	r21, 0x00	; 0
    3120:	66 0f       	add	r22, r22
    3122:	77 1f       	adc	r23, r23
    3124:	88 1f       	adc	r24, r24
    3126:	d2 f7       	brpl	.-12     	; 0x311c <__fp_norm2>
    3128:	08 95       	ret

0000312a <__tablejump2__>:
    312a:	ee 0f       	add	r30, r30
    312c:	ff 1f       	adc	r31, r31
    312e:	05 90       	lpm	r0, Z+
    3130:	f4 91       	lpm	r31, Z
    3132:	e0 2d       	mov	r30, r0
    3134:	09 94       	ijmp

00003136 <malloc>:
    3136:	0f 93       	push	r16
    3138:	1f 93       	push	r17
    313a:	cf 93       	push	r28
    313c:	df 93       	push	r29
    313e:	82 30       	cpi	r24, 0x02	; 2
    3140:	91 05       	cpc	r25, r1
    3142:	10 f4       	brcc	.+4      	; 0x3148 <malloc+0x12>
    3144:	82 e0       	ldi	r24, 0x02	; 2
    3146:	90 e0       	ldi	r25, 0x00	; 0
    3148:	e0 91 37 02 	lds	r30, 0x0237	; 0x800237 <__flp>
    314c:	f0 91 38 02 	lds	r31, 0x0238	; 0x800238 <__flp+0x1>
    3150:	20 e0       	ldi	r18, 0x00	; 0
    3152:	30 e0       	ldi	r19, 0x00	; 0
    3154:	a0 e0       	ldi	r26, 0x00	; 0
    3156:	b0 e0       	ldi	r27, 0x00	; 0
    3158:	30 97       	sbiw	r30, 0x00	; 0
    315a:	19 f1       	breq	.+70     	; 0x31a2 <malloc+0x6c>
    315c:	40 81       	ld	r20, Z
    315e:	51 81       	ldd	r21, Z+1	; 0x01
    3160:	02 81       	ldd	r16, Z+2	; 0x02
    3162:	13 81       	ldd	r17, Z+3	; 0x03
    3164:	48 17       	cp	r20, r24
    3166:	59 07       	cpc	r21, r25
    3168:	c8 f0       	brcs	.+50     	; 0x319c <malloc+0x66>
    316a:	84 17       	cp	r24, r20
    316c:	95 07       	cpc	r25, r21
    316e:	69 f4       	brne	.+26     	; 0x318a <malloc+0x54>
    3170:	10 97       	sbiw	r26, 0x00	; 0
    3172:	31 f0       	breq	.+12     	; 0x3180 <malloc+0x4a>
    3174:	12 96       	adiw	r26, 0x02	; 2
    3176:	0c 93       	st	X, r16
    3178:	12 97       	sbiw	r26, 0x02	; 2
    317a:	13 96       	adiw	r26, 0x03	; 3
    317c:	1c 93       	st	X, r17
    317e:	27 c0       	rjmp	.+78     	; 0x31ce <malloc+0x98>
    3180:	00 93 37 02 	sts	0x0237, r16	; 0x800237 <__flp>
    3184:	10 93 38 02 	sts	0x0238, r17	; 0x800238 <__flp+0x1>
    3188:	22 c0       	rjmp	.+68     	; 0x31ce <malloc+0x98>
    318a:	21 15       	cp	r18, r1
    318c:	31 05       	cpc	r19, r1
    318e:	19 f0       	breq	.+6      	; 0x3196 <malloc+0x60>
    3190:	42 17       	cp	r20, r18
    3192:	53 07       	cpc	r21, r19
    3194:	18 f4       	brcc	.+6      	; 0x319c <malloc+0x66>
    3196:	9a 01       	movw	r18, r20
    3198:	bd 01       	movw	r22, r26
    319a:	ef 01       	movw	r28, r30
    319c:	df 01       	movw	r26, r30
    319e:	f8 01       	movw	r30, r16
    31a0:	db cf       	rjmp	.-74     	; 0x3158 <malloc+0x22>
    31a2:	21 15       	cp	r18, r1
    31a4:	31 05       	cpc	r19, r1
    31a6:	f9 f0       	breq	.+62     	; 0x31e6 <malloc+0xb0>
    31a8:	28 1b       	sub	r18, r24
    31aa:	39 0b       	sbc	r19, r25
    31ac:	24 30       	cpi	r18, 0x04	; 4
    31ae:	31 05       	cpc	r19, r1
    31b0:	80 f4       	brcc	.+32     	; 0x31d2 <malloc+0x9c>
    31b2:	8a 81       	ldd	r24, Y+2	; 0x02
    31b4:	9b 81       	ldd	r25, Y+3	; 0x03
    31b6:	61 15       	cp	r22, r1
    31b8:	71 05       	cpc	r23, r1
    31ba:	21 f0       	breq	.+8      	; 0x31c4 <malloc+0x8e>
    31bc:	fb 01       	movw	r30, r22
    31be:	93 83       	std	Z+3, r25	; 0x03
    31c0:	82 83       	std	Z+2, r24	; 0x02
    31c2:	04 c0       	rjmp	.+8      	; 0x31cc <malloc+0x96>
    31c4:	90 93 38 02 	sts	0x0238, r25	; 0x800238 <__flp+0x1>
    31c8:	80 93 37 02 	sts	0x0237, r24	; 0x800237 <__flp>
    31cc:	fe 01       	movw	r30, r28
    31ce:	32 96       	adiw	r30, 0x02	; 2
    31d0:	44 c0       	rjmp	.+136    	; 0x325a <malloc+0x124>
    31d2:	fe 01       	movw	r30, r28
    31d4:	e2 0f       	add	r30, r18
    31d6:	f3 1f       	adc	r31, r19
    31d8:	81 93       	st	Z+, r24
    31da:	91 93       	st	Z+, r25
    31dc:	22 50       	subi	r18, 0x02	; 2
    31de:	31 09       	sbc	r19, r1
    31e0:	39 83       	std	Y+1, r19	; 0x01
    31e2:	28 83       	st	Y, r18
    31e4:	3a c0       	rjmp	.+116    	; 0x325a <malloc+0x124>
    31e6:	20 91 35 02 	lds	r18, 0x0235	; 0x800235 <__brkval>
    31ea:	30 91 36 02 	lds	r19, 0x0236	; 0x800236 <__brkval+0x1>
    31ee:	23 2b       	or	r18, r19
    31f0:	41 f4       	brne	.+16     	; 0x3202 <malloc+0xcc>
    31f2:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    31f6:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    31fa:	30 93 36 02 	sts	0x0236, r19	; 0x800236 <__brkval+0x1>
    31fe:	20 93 35 02 	sts	0x0235, r18	; 0x800235 <__brkval>
    3202:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    3206:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    320a:	21 15       	cp	r18, r1
    320c:	31 05       	cpc	r19, r1
    320e:	41 f4       	brne	.+16     	; 0x3220 <malloc+0xea>
    3210:	2d b7       	in	r18, 0x3d	; 61
    3212:	3e b7       	in	r19, 0x3e	; 62
    3214:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    3218:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    321c:	24 1b       	sub	r18, r20
    321e:	35 0b       	sbc	r19, r21
    3220:	e0 91 35 02 	lds	r30, 0x0235	; 0x800235 <__brkval>
    3224:	f0 91 36 02 	lds	r31, 0x0236	; 0x800236 <__brkval+0x1>
    3228:	e2 17       	cp	r30, r18
    322a:	f3 07       	cpc	r31, r19
    322c:	a0 f4       	brcc	.+40     	; 0x3256 <malloc+0x120>
    322e:	2e 1b       	sub	r18, r30
    3230:	3f 0b       	sbc	r19, r31
    3232:	28 17       	cp	r18, r24
    3234:	39 07       	cpc	r19, r25
    3236:	78 f0       	brcs	.+30     	; 0x3256 <malloc+0x120>
    3238:	ac 01       	movw	r20, r24
    323a:	4e 5f       	subi	r20, 0xFE	; 254
    323c:	5f 4f       	sbci	r21, 0xFF	; 255
    323e:	24 17       	cp	r18, r20
    3240:	35 07       	cpc	r19, r21
    3242:	48 f0       	brcs	.+18     	; 0x3256 <malloc+0x120>
    3244:	4e 0f       	add	r20, r30
    3246:	5f 1f       	adc	r21, r31
    3248:	50 93 36 02 	sts	0x0236, r21	; 0x800236 <__brkval+0x1>
    324c:	40 93 35 02 	sts	0x0235, r20	; 0x800235 <__brkval>
    3250:	81 93       	st	Z+, r24
    3252:	91 93       	st	Z+, r25
    3254:	02 c0       	rjmp	.+4      	; 0x325a <malloc+0x124>
    3256:	e0 e0       	ldi	r30, 0x00	; 0
    3258:	f0 e0       	ldi	r31, 0x00	; 0
    325a:	cf 01       	movw	r24, r30
    325c:	df 91       	pop	r29
    325e:	cf 91       	pop	r28
    3260:	1f 91       	pop	r17
    3262:	0f 91       	pop	r16
    3264:	08 95       	ret

00003266 <free>:
    3266:	cf 93       	push	r28
    3268:	df 93       	push	r29
    326a:	00 97       	sbiw	r24, 0x00	; 0
    326c:	09 f4       	brne	.+2      	; 0x3270 <free+0xa>
    326e:	81 c0       	rjmp	.+258    	; 0x3372 <free+0x10c>
    3270:	fc 01       	movw	r30, r24
    3272:	32 97       	sbiw	r30, 0x02	; 2
    3274:	13 82       	std	Z+3, r1	; 0x03
    3276:	12 82       	std	Z+2, r1	; 0x02
    3278:	a0 91 37 02 	lds	r26, 0x0237	; 0x800237 <__flp>
    327c:	b0 91 38 02 	lds	r27, 0x0238	; 0x800238 <__flp+0x1>
    3280:	10 97       	sbiw	r26, 0x00	; 0
    3282:	81 f4       	brne	.+32     	; 0x32a4 <free+0x3e>
    3284:	20 81       	ld	r18, Z
    3286:	31 81       	ldd	r19, Z+1	; 0x01
    3288:	82 0f       	add	r24, r18
    328a:	93 1f       	adc	r25, r19
    328c:	20 91 35 02 	lds	r18, 0x0235	; 0x800235 <__brkval>
    3290:	30 91 36 02 	lds	r19, 0x0236	; 0x800236 <__brkval+0x1>
    3294:	28 17       	cp	r18, r24
    3296:	39 07       	cpc	r19, r25
    3298:	51 f5       	brne	.+84     	; 0x32ee <free+0x88>
    329a:	f0 93 36 02 	sts	0x0236, r31	; 0x800236 <__brkval+0x1>
    329e:	e0 93 35 02 	sts	0x0235, r30	; 0x800235 <__brkval>
    32a2:	67 c0       	rjmp	.+206    	; 0x3372 <free+0x10c>
    32a4:	ed 01       	movw	r28, r26
    32a6:	20 e0       	ldi	r18, 0x00	; 0
    32a8:	30 e0       	ldi	r19, 0x00	; 0
    32aa:	ce 17       	cp	r28, r30
    32ac:	df 07       	cpc	r29, r31
    32ae:	40 f4       	brcc	.+16     	; 0x32c0 <free+0x5a>
    32b0:	4a 81       	ldd	r20, Y+2	; 0x02
    32b2:	5b 81       	ldd	r21, Y+3	; 0x03
    32b4:	9e 01       	movw	r18, r28
    32b6:	41 15       	cp	r20, r1
    32b8:	51 05       	cpc	r21, r1
    32ba:	f1 f0       	breq	.+60     	; 0x32f8 <free+0x92>
    32bc:	ea 01       	movw	r28, r20
    32be:	f5 cf       	rjmp	.-22     	; 0x32aa <free+0x44>
    32c0:	d3 83       	std	Z+3, r29	; 0x03
    32c2:	c2 83       	std	Z+2, r28	; 0x02
    32c4:	40 81       	ld	r20, Z
    32c6:	51 81       	ldd	r21, Z+1	; 0x01
    32c8:	84 0f       	add	r24, r20
    32ca:	95 1f       	adc	r25, r21
    32cc:	c8 17       	cp	r28, r24
    32ce:	d9 07       	cpc	r29, r25
    32d0:	59 f4       	brne	.+22     	; 0x32e8 <free+0x82>
    32d2:	88 81       	ld	r24, Y
    32d4:	99 81       	ldd	r25, Y+1	; 0x01
    32d6:	84 0f       	add	r24, r20
    32d8:	95 1f       	adc	r25, r21
    32da:	02 96       	adiw	r24, 0x02	; 2
    32dc:	91 83       	std	Z+1, r25	; 0x01
    32de:	80 83       	st	Z, r24
    32e0:	8a 81       	ldd	r24, Y+2	; 0x02
    32e2:	9b 81       	ldd	r25, Y+3	; 0x03
    32e4:	93 83       	std	Z+3, r25	; 0x03
    32e6:	82 83       	std	Z+2, r24	; 0x02
    32e8:	21 15       	cp	r18, r1
    32ea:	31 05       	cpc	r19, r1
    32ec:	29 f4       	brne	.+10     	; 0x32f8 <free+0x92>
    32ee:	f0 93 38 02 	sts	0x0238, r31	; 0x800238 <__flp+0x1>
    32f2:	e0 93 37 02 	sts	0x0237, r30	; 0x800237 <__flp>
    32f6:	3d c0       	rjmp	.+122    	; 0x3372 <free+0x10c>
    32f8:	e9 01       	movw	r28, r18
    32fa:	fb 83       	std	Y+3, r31	; 0x03
    32fc:	ea 83       	std	Y+2, r30	; 0x02
    32fe:	49 91       	ld	r20, Y+
    3300:	59 91       	ld	r21, Y+
    3302:	c4 0f       	add	r28, r20
    3304:	d5 1f       	adc	r29, r21
    3306:	ec 17       	cp	r30, r28
    3308:	fd 07       	cpc	r31, r29
    330a:	61 f4       	brne	.+24     	; 0x3324 <free+0xbe>
    330c:	80 81       	ld	r24, Z
    330e:	91 81       	ldd	r25, Z+1	; 0x01
    3310:	84 0f       	add	r24, r20
    3312:	95 1f       	adc	r25, r21
    3314:	02 96       	adiw	r24, 0x02	; 2
    3316:	e9 01       	movw	r28, r18
    3318:	99 83       	std	Y+1, r25	; 0x01
    331a:	88 83       	st	Y, r24
    331c:	82 81       	ldd	r24, Z+2	; 0x02
    331e:	93 81       	ldd	r25, Z+3	; 0x03
    3320:	9b 83       	std	Y+3, r25	; 0x03
    3322:	8a 83       	std	Y+2, r24	; 0x02
    3324:	e0 e0       	ldi	r30, 0x00	; 0
    3326:	f0 e0       	ldi	r31, 0x00	; 0
    3328:	12 96       	adiw	r26, 0x02	; 2
    332a:	8d 91       	ld	r24, X+
    332c:	9c 91       	ld	r25, X
    332e:	13 97       	sbiw	r26, 0x03	; 3
    3330:	00 97       	sbiw	r24, 0x00	; 0
    3332:	19 f0       	breq	.+6      	; 0x333a <free+0xd4>
    3334:	fd 01       	movw	r30, r26
    3336:	dc 01       	movw	r26, r24
    3338:	f7 cf       	rjmp	.-18     	; 0x3328 <free+0xc2>
    333a:	8d 91       	ld	r24, X+
    333c:	9c 91       	ld	r25, X
    333e:	11 97       	sbiw	r26, 0x01	; 1
    3340:	9d 01       	movw	r18, r26
    3342:	2e 5f       	subi	r18, 0xFE	; 254
    3344:	3f 4f       	sbci	r19, 0xFF	; 255
    3346:	82 0f       	add	r24, r18
    3348:	93 1f       	adc	r25, r19
    334a:	20 91 35 02 	lds	r18, 0x0235	; 0x800235 <__brkval>
    334e:	30 91 36 02 	lds	r19, 0x0236	; 0x800236 <__brkval+0x1>
    3352:	28 17       	cp	r18, r24
    3354:	39 07       	cpc	r19, r25
    3356:	69 f4       	brne	.+26     	; 0x3372 <free+0x10c>
    3358:	30 97       	sbiw	r30, 0x00	; 0
    335a:	29 f4       	brne	.+10     	; 0x3366 <free+0x100>
    335c:	10 92 38 02 	sts	0x0238, r1	; 0x800238 <__flp+0x1>
    3360:	10 92 37 02 	sts	0x0237, r1	; 0x800237 <__flp>
    3364:	02 c0       	rjmp	.+4      	; 0x336a <free+0x104>
    3366:	13 82       	std	Z+3, r1	; 0x03
    3368:	12 82       	std	Z+2, r1	; 0x02
    336a:	b0 93 36 02 	sts	0x0236, r27	; 0x800236 <__brkval+0x1>
    336e:	a0 93 35 02 	sts	0x0235, r26	; 0x800235 <__brkval>
    3372:	df 91       	pop	r29
    3374:	cf 91       	pop	r28
    3376:	08 95       	ret

00003378 <memcpy>:
    3378:	fb 01       	movw	r30, r22
    337a:	dc 01       	movw	r26, r24
    337c:	02 c0       	rjmp	.+4      	; 0x3382 <memcpy+0xa>
    337e:	01 90       	ld	r0, Z+
    3380:	0d 92       	st	X+, r0
    3382:	41 50       	subi	r20, 0x01	; 1
    3384:	50 40       	sbci	r21, 0x00	; 0
    3386:	d8 f7       	brcc	.-10     	; 0x337e <memcpy+0x6>
    3388:	08 95       	ret

0000338a <memset>:
    338a:	dc 01       	movw	r26, r24
    338c:	01 c0       	rjmp	.+2      	; 0x3390 <memset+0x6>
    338e:	6d 93       	st	X+, r22
    3390:	41 50       	subi	r20, 0x01	; 1
    3392:	50 40       	sbci	r21, 0x00	; 0
    3394:	e0 f7       	brcc	.-8      	; 0x338e <memset+0x4>
    3396:	08 95       	ret

00003398 <sprintf>:
    3398:	ae e0       	ldi	r26, 0x0E	; 14
    339a:	b0 e0       	ldi	r27, 0x00	; 0
    339c:	e2 ed       	ldi	r30, 0xD2	; 210
    339e:	f9 e1       	ldi	r31, 0x19	; 25
    33a0:	0c 94 8d 1c 	jmp	0x391a	; 0x391a <__prologue_saves__+0x1c>
    33a4:	0d 89       	ldd	r16, Y+21	; 0x15
    33a6:	1e 89       	ldd	r17, Y+22	; 0x16
    33a8:	86 e0       	ldi	r24, 0x06	; 6
    33aa:	8c 83       	std	Y+4, r24	; 0x04
    33ac:	1a 83       	std	Y+2, r17	; 0x02
    33ae:	09 83       	std	Y+1, r16	; 0x01
    33b0:	8f ef       	ldi	r24, 0xFF	; 255
    33b2:	9f e7       	ldi	r25, 0x7F	; 127
    33b4:	9e 83       	std	Y+6, r25	; 0x06
    33b6:	8d 83       	std	Y+5, r24	; 0x05
    33b8:	ae 01       	movw	r20, r28
    33ba:	47 5e       	subi	r20, 0xE7	; 231
    33bc:	5f 4f       	sbci	r21, 0xFF	; 255
    33be:	6f 89       	ldd	r22, Y+23	; 0x17
    33c0:	78 8d       	ldd	r23, Y+24	; 0x18
    33c2:	ce 01       	movw	r24, r28
    33c4:	01 96       	adiw	r24, 0x01	; 1
    33c6:	0e 94 ee 19 	call	0x33dc	; 0x33dc <vfprintf>
    33ca:	ef 81       	ldd	r30, Y+7	; 0x07
    33cc:	f8 85       	ldd	r31, Y+8	; 0x08
    33ce:	e0 0f       	add	r30, r16
    33d0:	f1 1f       	adc	r31, r17
    33d2:	10 82       	st	Z, r1
    33d4:	2e 96       	adiw	r28, 0x0e	; 14
    33d6:	e4 e0       	ldi	r30, 0x04	; 4
    33d8:	0c 94 a9 1c 	jmp	0x3952	; 0x3952 <__epilogue_restores__+0x1c>

000033dc <vfprintf>:
    33dc:	ab e0       	ldi	r26, 0x0B	; 11
    33de:	b0 e0       	ldi	r27, 0x00	; 0
    33e0:	e4 ef       	ldi	r30, 0xF4	; 244
    33e2:	f9 e1       	ldi	r31, 0x19	; 25
    33e4:	0c 94 7f 1c 	jmp	0x38fe	; 0x38fe <__prologue_saves__>
    33e8:	6c 01       	movw	r12, r24
    33ea:	7b 01       	movw	r14, r22
    33ec:	8a 01       	movw	r16, r20
    33ee:	fc 01       	movw	r30, r24
    33f0:	17 82       	std	Z+7, r1	; 0x07
    33f2:	16 82       	std	Z+6, r1	; 0x06
    33f4:	83 81       	ldd	r24, Z+3	; 0x03
    33f6:	81 ff       	sbrs	r24, 1
    33f8:	cc c1       	rjmp	.+920    	; 0x3792 <vfprintf+0x3b6>
    33fa:	ce 01       	movw	r24, r28
    33fc:	01 96       	adiw	r24, 0x01	; 1
    33fe:	3c 01       	movw	r6, r24
    3400:	f6 01       	movw	r30, r12
    3402:	93 81       	ldd	r25, Z+3	; 0x03
    3404:	f7 01       	movw	r30, r14
    3406:	93 fd       	sbrc	r25, 3
    3408:	85 91       	lpm	r24, Z+
    340a:	93 ff       	sbrs	r25, 3
    340c:	81 91       	ld	r24, Z+
    340e:	7f 01       	movw	r14, r30
    3410:	88 23       	and	r24, r24
    3412:	09 f4       	brne	.+2      	; 0x3416 <vfprintf+0x3a>
    3414:	ba c1       	rjmp	.+884    	; 0x378a <vfprintf+0x3ae>
    3416:	85 32       	cpi	r24, 0x25	; 37
    3418:	39 f4       	brne	.+14     	; 0x3428 <vfprintf+0x4c>
    341a:	93 fd       	sbrc	r25, 3
    341c:	85 91       	lpm	r24, Z+
    341e:	93 ff       	sbrs	r25, 3
    3420:	81 91       	ld	r24, Z+
    3422:	7f 01       	movw	r14, r30
    3424:	85 32       	cpi	r24, 0x25	; 37
    3426:	29 f4       	brne	.+10     	; 0x3432 <vfprintf+0x56>
    3428:	b6 01       	movw	r22, r12
    342a:	90 e0       	ldi	r25, 0x00	; 0
    342c:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    3430:	e7 cf       	rjmp	.-50     	; 0x3400 <vfprintf+0x24>
    3432:	91 2c       	mov	r9, r1
    3434:	21 2c       	mov	r2, r1
    3436:	31 2c       	mov	r3, r1
    3438:	ff e1       	ldi	r31, 0x1F	; 31
    343a:	f3 15       	cp	r31, r3
    343c:	d8 f0       	brcs	.+54     	; 0x3474 <vfprintf+0x98>
    343e:	8b 32       	cpi	r24, 0x2B	; 43
    3440:	79 f0       	breq	.+30     	; 0x3460 <vfprintf+0x84>
    3442:	38 f4       	brcc	.+14     	; 0x3452 <vfprintf+0x76>
    3444:	80 32       	cpi	r24, 0x20	; 32
    3446:	79 f0       	breq	.+30     	; 0x3466 <vfprintf+0x8a>
    3448:	83 32       	cpi	r24, 0x23	; 35
    344a:	a1 f4       	brne	.+40     	; 0x3474 <vfprintf+0x98>
    344c:	23 2d       	mov	r18, r3
    344e:	20 61       	ori	r18, 0x10	; 16
    3450:	1d c0       	rjmp	.+58     	; 0x348c <vfprintf+0xb0>
    3452:	8d 32       	cpi	r24, 0x2D	; 45
    3454:	61 f0       	breq	.+24     	; 0x346e <vfprintf+0x92>
    3456:	80 33       	cpi	r24, 0x30	; 48
    3458:	69 f4       	brne	.+26     	; 0x3474 <vfprintf+0x98>
    345a:	23 2d       	mov	r18, r3
    345c:	21 60       	ori	r18, 0x01	; 1
    345e:	16 c0       	rjmp	.+44     	; 0x348c <vfprintf+0xb0>
    3460:	83 2d       	mov	r24, r3
    3462:	82 60       	ori	r24, 0x02	; 2
    3464:	38 2e       	mov	r3, r24
    3466:	e3 2d       	mov	r30, r3
    3468:	e4 60       	ori	r30, 0x04	; 4
    346a:	3e 2e       	mov	r3, r30
    346c:	2a c0       	rjmp	.+84     	; 0x34c2 <vfprintf+0xe6>
    346e:	f3 2d       	mov	r31, r3
    3470:	f8 60       	ori	r31, 0x08	; 8
    3472:	1d c0       	rjmp	.+58     	; 0x34ae <vfprintf+0xd2>
    3474:	37 fc       	sbrc	r3, 7
    3476:	2d c0       	rjmp	.+90     	; 0x34d2 <vfprintf+0xf6>
    3478:	20 ed       	ldi	r18, 0xD0	; 208
    347a:	28 0f       	add	r18, r24
    347c:	2a 30       	cpi	r18, 0x0A	; 10
    347e:	40 f0       	brcs	.+16     	; 0x3490 <vfprintf+0xb4>
    3480:	8e 32       	cpi	r24, 0x2E	; 46
    3482:	b9 f4       	brne	.+46     	; 0x34b2 <vfprintf+0xd6>
    3484:	36 fc       	sbrc	r3, 6
    3486:	81 c1       	rjmp	.+770    	; 0x378a <vfprintf+0x3ae>
    3488:	23 2d       	mov	r18, r3
    348a:	20 64       	ori	r18, 0x40	; 64
    348c:	32 2e       	mov	r3, r18
    348e:	19 c0       	rjmp	.+50     	; 0x34c2 <vfprintf+0xe6>
    3490:	36 fe       	sbrs	r3, 6
    3492:	06 c0       	rjmp	.+12     	; 0x34a0 <vfprintf+0xc4>
    3494:	8a e0       	ldi	r24, 0x0A	; 10
    3496:	98 9e       	mul	r9, r24
    3498:	20 0d       	add	r18, r0
    349a:	11 24       	eor	r1, r1
    349c:	92 2e       	mov	r9, r18
    349e:	11 c0       	rjmp	.+34     	; 0x34c2 <vfprintf+0xe6>
    34a0:	ea e0       	ldi	r30, 0x0A	; 10
    34a2:	2e 9e       	mul	r2, r30
    34a4:	20 0d       	add	r18, r0
    34a6:	11 24       	eor	r1, r1
    34a8:	22 2e       	mov	r2, r18
    34aa:	f3 2d       	mov	r31, r3
    34ac:	f0 62       	ori	r31, 0x20	; 32
    34ae:	3f 2e       	mov	r3, r31
    34b0:	08 c0       	rjmp	.+16     	; 0x34c2 <vfprintf+0xe6>
    34b2:	8c 36       	cpi	r24, 0x6C	; 108
    34b4:	21 f4       	brne	.+8      	; 0x34be <vfprintf+0xe2>
    34b6:	83 2d       	mov	r24, r3
    34b8:	80 68       	ori	r24, 0x80	; 128
    34ba:	38 2e       	mov	r3, r24
    34bc:	02 c0       	rjmp	.+4      	; 0x34c2 <vfprintf+0xe6>
    34be:	88 36       	cpi	r24, 0x68	; 104
    34c0:	41 f4       	brne	.+16     	; 0x34d2 <vfprintf+0xf6>
    34c2:	f7 01       	movw	r30, r14
    34c4:	93 fd       	sbrc	r25, 3
    34c6:	85 91       	lpm	r24, Z+
    34c8:	93 ff       	sbrs	r25, 3
    34ca:	81 91       	ld	r24, Z+
    34cc:	7f 01       	movw	r14, r30
    34ce:	81 11       	cpse	r24, r1
    34d0:	b3 cf       	rjmp	.-154    	; 0x3438 <vfprintf+0x5c>
    34d2:	98 2f       	mov	r25, r24
    34d4:	9f 7d       	andi	r25, 0xDF	; 223
    34d6:	95 54       	subi	r25, 0x45	; 69
    34d8:	93 30       	cpi	r25, 0x03	; 3
    34da:	28 f4       	brcc	.+10     	; 0x34e6 <vfprintf+0x10a>
    34dc:	0c 5f       	subi	r16, 0xFC	; 252
    34de:	1f 4f       	sbci	r17, 0xFF	; 255
    34e0:	9f e3       	ldi	r25, 0x3F	; 63
    34e2:	99 83       	std	Y+1, r25	; 0x01
    34e4:	0d c0       	rjmp	.+26     	; 0x3500 <vfprintf+0x124>
    34e6:	83 36       	cpi	r24, 0x63	; 99
    34e8:	31 f0       	breq	.+12     	; 0x34f6 <vfprintf+0x11a>
    34ea:	83 37       	cpi	r24, 0x73	; 115
    34ec:	71 f0       	breq	.+28     	; 0x350a <vfprintf+0x12e>
    34ee:	83 35       	cpi	r24, 0x53	; 83
    34f0:	09 f0       	breq	.+2      	; 0x34f4 <vfprintf+0x118>
    34f2:	59 c0       	rjmp	.+178    	; 0x35a6 <vfprintf+0x1ca>
    34f4:	21 c0       	rjmp	.+66     	; 0x3538 <vfprintf+0x15c>
    34f6:	f8 01       	movw	r30, r16
    34f8:	80 81       	ld	r24, Z
    34fa:	89 83       	std	Y+1, r24	; 0x01
    34fc:	0e 5f       	subi	r16, 0xFE	; 254
    34fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3500:	88 24       	eor	r8, r8
    3502:	83 94       	inc	r8
    3504:	91 2c       	mov	r9, r1
    3506:	53 01       	movw	r10, r6
    3508:	13 c0       	rjmp	.+38     	; 0x3530 <vfprintf+0x154>
    350a:	28 01       	movw	r4, r16
    350c:	f2 e0       	ldi	r31, 0x02	; 2
    350e:	4f 0e       	add	r4, r31
    3510:	51 1c       	adc	r5, r1
    3512:	f8 01       	movw	r30, r16
    3514:	a0 80       	ld	r10, Z
    3516:	b1 80       	ldd	r11, Z+1	; 0x01
    3518:	36 fe       	sbrs	r3, 6
    351a:	03 c0       	rjmp	.+6      	; 0x3522 <vfprintf+0x146>
    351c:	69 2d       	mov	r22, r9
    351e:	70 e0       	ldi	r23, 0x00	; 0
    3520:	02 c0       	rjmp	.+4      	; 0x3526 <vfprintf+0x14a>
    3522:	6f ef       	ldi	r22, 0xFF	; 255
    3524:	7f ef       	ldi	r23, 0xFF	; 255
    3526:	c5 01       	movw	r24, r10
    3528:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <strnlen>
    352c:	4c 01       	movw	r8, r24
    352e:	82 01       	movw	r16, r4
    3530:	f3 2d       	mov	r31, r3
    3532:	ff 77       	andi	r31, 0x7F	; 127
    3534:	3f 2e       	mov	r3, r31
    3536:	16 c0       	rjmp	.+44     	; 0x3564 <vfprintf+0x188>
    3538:	28 01       	movw	r4, r16
    353a:	22 e0       	ldi	r18, 0x02	; 2
    353c:	42 0e       	add	r4, r18
    353e:	51 1c       	adc	r5, r1
    3540:	f8 01       	movw	r30, r16
    3542:	a0 80       	ld	r10, Z
    3544:	b1 80       	ldd	r11, Z+1	; 0x01
    3546:	36 fe       	sbrs	r3, 6
    3548:	03 c0       	rjmp	.+6      	; 0x3550 <vfprintf+0x174>
    354a:	69 2d       	mov	r22, r9
    354c:	70 e0       	ldi	r23, 0x00	; 0
    354e:	02 c0       	rjmp	.+4      	; 0x3554 <vfprintf+0x178>
    3550:	6f ef       	ldi	r22, 0xFF	; 255
    3552:	7f ef       	ldi	r23, 0xFF	; 255
    3554:	c5 01       	movw	r24, r10
    3556:	0e 94 cf 1b 	call	0x379e	; 0x379e <strnlen_P>
    355a:	4c 01       	movw	r8, r24
    355c:	f3 2d       	mov	r31, r3
    355e:	f0 68       	ori	r31, 0x80	; 128
    3560:	3f 2e       	mov	r3, r31
    3562:	82 01       	movw	r16, r4
    3564:	33 fc       	sbrc	r3, 3
    3566:	1b c0       	rjmp	.+54     	; 0x359e <vfprintf+0x1c2>
    3568:	82 2d       	mov	r24, r2
    356a:	90 e0       	ldi	r25, 0x00	; 0
    356c:	88 16       	cp	r8, r24
    356e:	99 06       	cpc	r9, r25
    3570:	b0 f4       	brcc	.+44     	; 0x359e <vfprintf+0x1c2>
    3572:	b6 01       	movw	r22, r12
    3574:	80 e2       	ldi	r24, 0x20	; 32
    3576:	90 e0       	ldi	r25, 0x00	; 0
    3578:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    357c:	2a 94       	dec	r2
    357e:	f4 cf       	rjmp	.-24     	; 0x3568 <vfprintf+0x18c>
    3580:	f5 01       	movw	r30, r10
    3582:	37 fc       	sbrc	r3, 7
    3584:	85 91       	lpm	r24, Z+
    3586:	37 fe       	sbrs	r3, 7
    3588:	81 91       	ld	r24, Z+
    358a:	5f 01       	movw	r10, r30
    358c:	b6 01       	movw	r22, r12
    358e:	90 e0       	ldi	r25, 0x00	; 0
    3590:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    3594:	21 10       	cpse	r2, r1
    3596:	2a 94       	dec	r2
    3598:	21 e0       	ldi	r18, 0x01	; 1
    359a:	82 1a       	sub	r8, r18
    359c:	91 08       	sbc	r9, r1
    359e:	81 14       	cp	r8, r1
    35a0:	91 04       	cpc	r9, r1
    35a2:	71 f7       	brne	.-36     	; 0x3580 <vfprintf+0x1a4>
    35a4:	e8 c0       	rjmp	.+464    	; 0x3776 <vfprintf+0x39a>
    35a6:	84 36       	cpi	r24, 0x64	; 100
    35a8:	11 f0       	breq	.+4      	; 0x35ae <vfprintf+0x1d2>
    35aa:	89 36       	cpi	r24, 0x69	; 105
    35ac:	41 f5       	brne	.+80     	; 0x35fe <vfprintf+0x222>
    35ae:	f8 01       	movw	r30, r16
    35b0:	37 fe       	sbrs	r3, 7
    35b2:	07 c0       	rjmp	.+14     	; 0x35c2 <vfprintf+0x1e6>
    35b4:	60 81       	ld	r22, Z
    35b6:	71 81       	ldd	r23, Z+1	; 0x01
    35b8:	82 81       	ldd	r24, Z+2	; 0x02
    35ba:	93 81       	ldd	r25, Z+3	; 0x03
    35bc:	0c 5f       	subi	r16, 0xFC	; 252
    35be:	1f 4f       	sbci	r17, 0xFF	; 255
    35c0:	08 c0       	rjmp	.+16     	; 0x35d2 <vfprintf+0x1f6>
    35c2:	60 81       	ld	r22, Z
    35c4:	71 81       	ldd	r23, Z+1	; 0x01
    35c6:	07 2e       	mov	r0, r23
    35c8:	00 0c       	add	r0, r0
    35ca:	88 0b       	sbc	r24, r24
    35cc:	99 0b       	sbc	r25, r25
    35ce:	0e 5f       	subi	r16, 0xFE	; 254
    35d0:	1f 4f       	sbci	r17, 0xFF	; 255
    35d2:	f3 2d       	mov	r31, r3
    35d4:	ff 76       	andi	r31, 0x6F	; 111
    35d6:	3f 2e       	mov	r3, r31
    35d8:	97 ff       	sbrs	r25, 7
    35da:	09 c0       	rjmp	.+18     	; 0x35ee <vfprintf+0x212>
    35dc:	90 95       	com	r25
    35de:	80 95       	com	r24
    35e0:	70 95       	com	r23
    35e2:	61 95       	neg	r22
    35e4:	7f 4f       	sbci	r23, 0xFF	; 255
    35e6:	8f 4f       	sbci	r24, 0xFF	; 255
    35e8:	9f 4f       	sbci	r25, 0xFF	; 255
    35ea:	f0 68       	ori	r31, 0x80	; 128
    35ec:	3f 2e       	mov	r3, r31
    35ee:	2a e0       	ldi	r18, 0x0A	; 10
    35f0:	30 e0       	ldi	r19, 0x00	; 0
    35f2:	a3 01       	movw	r20, r6
    35f4:	0e 94 21 1c 	call	0x3842	; 0x3842 <__ultoa_invert>
    35f8:	88 2e       	mov	r8, r24
    35fa:	86 18       	sub	r8, r6
    35fc:	45 c0       	rjmp	.+138    	; 0x3688 <vfprintf+0x2ac>
    35fe:	85 37       	cpi	r24, 0x75	; 117
    3600:	31 f4       	brne	.+12     	; 0x360e <vfprintf+0x232>
    3602:	23 2d       	mov	r18, r3
    3604:	2f 7e       	andi	r18, 0xEF	; 239
    3606:	b2 2e       	mov	r11, r18
    3608:	2a e0       	ldi	r18, 0x0A	; 10
    360a:	30 e0       	ldi	r19, 0x00	; 0
    360c:	25 c0       	rjmp	.+74     	; 0x3658 <vfprintf+0x27c>
    360e:	93 2d       	mov	r25, r3
    3610:	99 7f       	andi	r25, 0xF9	; 249
    3612:	b9 2e       	mov	r11, r25
    3614:	8f 36       	cpi	r24, 0x6F	; 111
    3616:	c1 f0       	breq	.+48     	; 0x3648 <vfprintf+0x26c>
    3618:	18 f4       	brcc	.+6      	; 0x3620 <vfprintf+0x244>
    361a:	88 35       	cpi	r24, 0x58	; 88
    361c:	79 f0       	breq	.+30     	; 0x363c <vfprintf+0x260>
    361e:	b5 c0       	rjmp	.+362    	; 0x378a <vfprintf+0x3ae>
    3620:	80 37       	cpi	r24, 0x70	; 112
    3622:	19 f0       	breq	.+6      	; 0x362a <vfprintf+0x24e>
    3624:	88 37       	cpi	r24, 0x78	; 120
    3626:	21 f0       	breq	.+8      	; 0x3630 <vfprintf+0x254>
    3628:	b0 c0       	rjmp	.+352    	; 0x378a <vfprintf+0x3ae>
    362a:	e9 2f       	mov	r30, r25
    362c:	e0 61       	ori	r30, 0x10	; 16
    362e:	be 2e       	mov	r11, r30
    3630:	b4 fe       	sbrs	r11, 4
    3632:	0d c0       	rjmp	.+26     	; 0x364e <vfprintf+0x272>
    3634:	fb 2d       	mov	r31, r11
    3636:	f4 60       	ori	r31, 0x04	; 4
    3638:	bf 2e       	mov	r11, r31
    363a:	09 c0       	rjmp	.+18     	; 0x364e <vfprintf+0x272>
    363c:	34 fe       	sbrs	r3, 4
    363e:	0a c0       	rjmp	.+20     	; 0x3654 <vfprintf+0x278>
    3640:	29 2f       	mov	r18, r25
    3642:	26 60       	ori	r18, 0x06	; 6
    3644:	b2 2e       	mov	r11, r18
    3646:	06 c0       	rjmp	.+12     	; 0x3654 <vfprintf+0x278>
    3648:	28 e0       	ldi	r18, 0x08	; 8
    364a:	30 e0       	ldi	r19, 0x00	; 0
    364c:	05 c0       	rjmp	.+10     	; 0x3658 <vfprintf+0x27c>
    364e:	20 e1       	ldi	r18, 0x10	; 16
    3650:	30 e0       	ldi	r19, 0x00	; 0
    3652:	02 c0       	rjmp	.+4      	; 0x3658 <vfprintf+0x27c>
    3654:	20 e1       	ldi	r18, 0x10	; 16
    3656:	32 e0       	ldi	r19, 0x02	; 2
    3658:	f8 01       	movw	r30, r16
    365a:	b7 fe       	sbrs	r11, 7
    365c:	07 c0       	rjmp	.+14     	; 0x366c <vfprintf+0x290>
    365e:	60 81       	ld	r22, Z
    3660:	71 81       	ldd	r23, Z+1	; 0x01
    3662:	82 81       	ldd	r24, Z+2	; 0x02
    3664:	93 81       	ldd	r25, Z+3	; 0x03
    3666:	0c 5f       	subi	r16, 0xFC	; 252
    3668:	1f 4f       	sbci	r17, 0xFF	; 255
    366a:	06 c0       	rjmp	.+12     	; 0x3678 <vfprintf+0x29c>
    366c:	60 81       	ld	r22, Z
    366e:	71 81       	ldd	r23, Z+1	; 0x01
    3670:	80 e0       	ldi	r24, 0x00	; 0
    3672:	90 e0       	ldi	r25, 0x00	; 0
    3674:	0e 5f       	subi	r16, 0xFE	; 254
    3676:	1f 4f       	sbci	r17, 0xFF	; 255
    3678:	a3 01       	movw	r20, r6
    367a:	0e 94 21 1c 	call	0x3842	; 0x3842 <__ultoa_invert>
    367e:	88 2e       	mov	r8, r24
    3680:	86 18       	sub	r8, r6
    3682:	fb 2d       	mov	r31, r11
    3684:	ff 77       	andi	r31, 0x7F	; 127
    3686:	3f 2e       	mov	r3, r31
    3688:	36 fe       	sbrs	r3, 6
    368a:	0d c0       	rjmp	.+26     	; 0x36a6 <vfprintf+0x2ca>
    368c:	23 2d       	mov	r18, r3
    368e:	2e 7f       	andi	r18, 0xFE	; 254
    3690:	a2 2e       	mov	r10, r18
    3692:	89 14       	cp	r8, r9
    3694:	58 f4       	brcc	.+22     	; 0x36ac <vfprintf+0x2d0>
    3696:	34 fe       	sbrs	r3, 4
    3698:	0b c0       	rjmp	.+22     	; 0x36b0 <vfprintf+0x2d4>
    369a:	32 fc       	sbrc	r3, 2
    369c:	09 c0       	rjmp	.+18     	; 0x36b0 <vfprintf+0x2d4>
    369e:	83 2d       	mov	r24, r3
    36a0:	8e 7e       	andi	r24, 0xEE	; 238
    36a2:	a8 2e       	mov	r10, r24
    36a4:	05 c0       	rjmp	.+10     	; 0x36b0 <vfprintf+0x2d4>
    36a6:	b8 2c       	mov	r11, r8
    36a8:	a3 2c       	mov	r10, r3
    36aa:	03 c0       	rjmp	.+6      	; 0x36b2 <vfprintf+0x2d6>
    36ac:	b8 2c       	mov	r11, r8
    36ae:	01 c0       	rjmp	.+2      	; 0x36b2 <vfprintf+0x2d6>
    36b0:	b9 2c       	mov	r11, r9
    36b2:	a4 fe       	sbrs	r10, 4
    36b4:	0f c0       	rjmp	.+30     	; 0x36d4 <vfprintf+0x2f8>
    36b6:	fe 01       	movw	r30, r28
    36b8:	e8 0d       	add	r30, r8
    36ba:	f1 1d       	adc	r31, r1
    36bc:	80 81       	ld	r24, Z
    36be:	80 33       	cpi	r24, 0x30	; 48
    36c0:	21 f4       	brne	.+8      	; 0x36ca <vfprintf+0x2ee>
    36c2:	9a 2d       	mov	r25, r10
    36c4:	99 7e       	andi	r25, 0xE9	; 233
    36c6:	a9 2e       	mov	r10, r25
    36c8:	09 c0       	rjmp	.+18     	; 0x36dc <vfprintf+0x300>
    36ca:	a2 fe       	sbrs	r10, 2
    36cc:	06 c0       	rjmp	.+12     	; 0x36da <vfprintf+0x2fe>
    36ce:	b3 94       	inc	r11
    36d0:	b3 94       	inc	r11
    36d2:	04 c0       	rjmp	.+8      	; 0x36dc <vfprintf+0x300>
    36d4:	8a 2d       	mov	r24, r10
    36d6:	86 78       	andi	r24, 0x86	; 134
    36d8:	09 f0       	breq	.+2      	; 0x36dc <vfprintf+0x300>
    36da:	b3 94       	inc	r11
    36dc:	a3 fc       	sbrc	r10, 3
    36de:	11 c0       	rjmp	.+34     	; 0x3702 <vfprintf+0x326>
    36e0:	a0 fe       	sbrs	r10, 0
    36e2:	06 c0       	rjmp	.+12     	; 0x36f0 <vfprintf+0x314>
    36e4:	b2 14       	cp	r11, r2
    36e6:	88 f4       	brcc	.+34     	; 0x370a <vfprintf+0x32e>
    36e8:	28 0c       	add	r2, r8
    36ea:	92 2c       	mov	r9, r2
    36ec:	9b 18       	sub	r9, r11
    36ee:	0e c0       	rjmp	.+28     	; 0x370c <vfprintf+0x330>
    36f0:	b2 14       	cp	r11, r2
    36f2:	60 f4       	brcc	.+24     	; 0x370c <vfprintf+0x330>
    36f4:	b6 01       	movw	r22, r12
    36f6:	80 e2       	ldi	r24, 0x20	; 32
    36f8:	90 e0       	ldi	r25, 0x00	; 0
    36fa:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    36fe:	b3 94       	inc	r11
    3700:	f7 cf       	rjmp	.-18     	; 0x36f0 <vfprintf+0x314>
    3702:	b2 14       	cp	r11, r2
    3704:	18 f4       	brcc	.+6      	; 0x370c <vfprintf+0x330>
    3706:	2b 18       	sub	r2, r11
    3708:	02 c0       	rjmp	.+4      	; 0x370e <vfprintf+0x332>
    370a:	98 2c       	mov	r9, r8
    370c:	21 2c       	mov	r2, r1
    370e:	a4 fe       	sbrs	r10, 4
    3710:	10 c0       	rjmp	.+32     	; 0x3732 <vfprintf+0x356>
    3712:	b6 01       	movw	r22, r12
    3714:	80 e3       	ldi	r24, 0x30	; 48
    3716:	90 e0       	ldi	r25, 0x00	; 0
    3718:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    371c:	a2 fe       	sbrs	r10, 2
    371e:	17 c0       	rjmp	.+46     	; 0x374e <vfprintf+0x372>
    3720:	a1 fc       	sbrc	r10, 1
    3722:	03 c0       	rjmp	.+6      	; 0x372a <vfprintf+0x34e>
    3724:	88 e7       	ldi	r24, 0x78	; 120
    3726:	90 e0       	ldi	r25, 0x00	; 0
    3728:	02 c0       	rjmp	.+4      	; 0x372e <vfprintf+0x352>
    372a:	88 e5       	ldi	r24, 0x58	; 88
    372c:	90 e0       	ldi	r25, 0x00	; 0
    372e:	b6 01       	movw	r22, r12
    3730:	0c c0       	rjmp	.+24     	; 0x374a <vfprintf+0x36e>
    3732:	8a 2d       	mov	r24, r10
    3734:	86 78       	andi	r24, 0x86	; 134
    3736:	59 f0       	breq	.+22     	; 0x374e <vfprintf+0x372>
    3738:	a1 fe       	sbrs	r10, 1
    373a:	02 c0       	rjmp	.+4      	; 0x3740 <vfprintf+0x364>
    373c:	8b e2       	ldi	r24, 0x2B	; 43
    373e:	01 c0       	rjmp	.+2      	; 0x3742 <vfprintf+0x366>
    3740:	80 e2       	ldi	r24, 0x20	; 32
    3742:	a7 fc       	sbrc	r10, 7
    3744:	8d e2       	ldi	r24, 0x2D	; 45
    3746:	b6 01       	movw	r22, r12
    3748:	90 e0       	ldi	r25, 0x00	; 0
    374a:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    374e:	89 14       	cp	r8, r9
    3750:	38 f4       	brcc	.+14     	; 0x3760 <vfprintf+0x384>
    3752:	b6 01       	movw	r22, r12
    3754:	80 e3       	ldi	r24, 0x30	; 48
    3756:	90 e0       	ldi	r25, 0x00	; 0
    3758:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    375c:	9a 94       	dec	r9
    375e:	f7 cf       	rjmp	.-18     	; 0x374e <vfprintf+0x372>
    3760:	8a 94       	dec	r8
    3762:	f3 01       	movw	r30, r6
    3764:	e8 0d       	add	r30, r8
    3766:	f1 1d       	adc	r31, r1
    3768:	80 81       	ld	r24, Z
    376a:	b6 01       	movw	r22, r12
    376c:	90 e0       	ldi	r25, 0x00	; 0
    376e:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    3772:	81 10       	cpse	r8, r1
    3774:	f5 cf       	rjmp	.-22     	; 0x3760 <vfprintf+0x384>
    3776:	22 20       	and	r2, r2
    3778:	09 f4       	brne	.+2      	; 0x377c <vfprintf+0x3a0>
    377a:	42 ce       	rjmp	.-892    	; 0x3400 <vfprintf+0x24>
    377c:	b6 01       	movw	r22, r12
    377e:	80 e2       	ldi	r24, 0x20	; 32
    3780:	90 e0       	ldi	r25, 0x00	; 0
    3782:	0e 94 e5 1b 	call	0x37ca	; 0x37ca <fputc>
    3786:	2a 94       	dec	r2
    3788:	f6 cf       	rjmp	.-20     	; 0x3776 <vfprintf+0x39a>
    378a:	f6 01       	movw	r30, r12
    378c:	86 81       	ldd	r24, Z+6	; 0x06
    378e:	97 81       	ldd	r25, Z+7	; 0x07
    3790:	02 c0       	rjmp	.+4      	; 0x3796 <vfprintf+0x3ba>
    3792:	8f ef       	ldi	r24, 0xFF	; 255
    3794:	9f ef       	ldi	r25, 0xFF	; 255
    3796:	2b 96       	adiw	r28, 0x0b	; 11
    3798:	e2 e1       	ldi	r30, 0x12	; 18
    379a:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__epilogue_restores__>

0000379e <strnlen_P>:
    379e:	fc 01       	movw	r30, r24
    37a0:	05 90       	lpm	r0, Z+
    37a2:	61 50       	subi	r22, 0x01	; 1
    37a4:	70 40       	sbci	r23, 0x00	; 0
    37a6:	01 10       	cpse	r0, r1
    37a8:	d8 f7       	brcc	.-10     	; 0x37a0 <strnlen_P+0x2>
    37aa:	80 95       	com	r24
    37ac:	90 95       	com	r25
    37ae:	8e 0f       	add	r24, r30
    37b0:	9f 1f       	adc	r25, r31
    37b2:	08 95       	ret

000037b4 <strnlen>:
    37b4:	fc 01       	movw	r30, r24
    37b6:	61 50       	subi	r22, 0x01	; 1
    37b8:	70 40       	sbci	r23, 0x00	; 0
    37ba:	01 90       	ld	r0, Z+
    37bc:	01 10       	cpse	r0, r1
    37be:	d8 f7       	brcc	.-10     	; 0x37b6 <strnlen+0x2>
    37c0:	80 95       	com	r24
    37c2:	90 95       	com	r25
    37c4:	8e 0f       	add	r24, r30
    37c6:	9f 1f       	adc	r25, r31
    37c8:	08 95       	ret

000037ca <fputc>:
    37ca:	0f 93       	push	r16
    37cc:	1f 93       	push	r17
    37ce:	cf 93       	push	r28
    37d0:	df 93       	push	r29
    37d2:	fb 01       	movw	r30, r22
    37d4:	23 81       	ldd	r18, Z+3	; 0x03
    37d6:	21 fd       	sbrc	r18, 1
    37d8:	03 c0       	rjmp	.+6      	; 0x37e0 <fputc+0x16>
    37da:	8f ef       	ldi	r24, 0xFF	; 255
    37dc:	9f ef       	ldi	r25, 0xFF	; 255
    37de:	2c c0       	rjmp	.+88     	; 0x3838 <fputc+0x6e>
    37e0:	22 ff       	sbrs	r18, 2
    37e2:	16 c0       	rjmp	.+44     	; 0x3810 <fputc+0x46>
    37e4:	46 81       	ldd	r20, Z+6	; 0x06
    37e6:	57 81       	ldd	r21, Z+7	; 0x07
    37e8:	24 81       	ldd	r18, Z+4	; 0x04
    37ea:	35 81       	ldd	r19, Z+5	; 0x05
    37ec:	42 17       	cp	r20, r18
    37ee:	53 07       	cpc	r21, r19
    37f0:	44 f4       	brge	.+16     	; 0x3802 <fputc+0x38>
    37f2:	a0 81       	ld	r26, Z
    37f4:	b1 81       	ldd	r27, Z+1	; 0x01
    37f6:	9d 01       	movw	r18, r26
    37f8:	2f 5f       	subi	r18, 0xFF	; 255
    37fa:	3f 4f       	sbci	r19, 0xFF	; 255
    37fc:	31 83       	std	Z+1, r19	; 0x01
    37fe:	20 83       	st	Z, r18
    3800:	8c 93       	st	X, r24
    3802:	26 81       	ldd	r18, Z+6	; 0x06
    3804:	37 81       	ldd	r19, Z+7	; 0x07
    3806:	2f 5f       	subi	r18, 0xFF	; 255
    3808:	3f 4f       	sbci	r19, 0xFF	; 255
    380a:	37 83       	std	Z+7, r19	; 0x07
    380c:	26 83       	std	Z+6, r18	; 0x06
    380e:	14 c0       	rjmp	.+40     	; 0x3838 <fputc+0x6e>
    3810:	8b 01       	movw	r16, r22
    3812:	ec 01       	movw	r28, r24
    3814:	fb 01       	movw	r30, r22
    3816:	00 84       	ldd	r0, Z+8	; 0x08
    3818:	f1 85       	ldd	r31, Z+9	; 0x09
    381a:	e0 2d       	mov	r30, r0
    381c:	09 95       	icall
    381e:	89 2b       	or	r24, r25
    3820:	e1 f6       	brne	.-72     	; 0x37da <fputc+0x10>
    3822:	d8 01       	movw	r26, r16
    3824:	16 96       	adiw	r26, 0x06	; 6
    3826:	8d 91       	ld	r24, X+
    3828:	9c 91       	ld	r25, X
    382a:	17 97       	sbiw	r26, 0x07	; 7
    382c:	01 96       	adiw	r24, 0x01	; 1
    382e:	17 96       	adiw	r26, 0x07	; 7
    3830:	9c 93       	st	X, r25
    3832:	8e 93       	st	-X, r24
    3834:	16 97       	sbiw	r26, 0x06	; 6
    3836:	ce 01       	movw	r24, r28
    3838:	df 91       	pop	r29
    383a:	cf 91       	pop	r28
    383c:	1f 91       	pop	r17
    383e:	0f 91       	pop	r16
    3840:	08 95       	ret

00003842 <__ultoa_invert>:
    3842:	fa 01       	movw	r30, r20
    3844:	aa 27       	eor	r26, r26
    3846:	28 30       	cpi	r18, 0x08	; 8
    3848:	51 f1       	breq	.+84     	; 0x389e <__ultoa_invert+0x5c>
    384a:	20 31       	cpi	r18, 0x10	; 16
    384c:	81 f1       	breq	.+96     	; 0x38ae <__ultoa_invert+0x6c>
    384e:	e8 94       	clt
    3850:	6f 93       	push	r22
    3852:	6e 7f       	andi	r22, 0xFE	; 254
    3854:	6e 5f       	subi	r22, 0xFE	; 254
    3856:	7f 4f       	sbci	r23, 0xFF	; 255
    3858:	8f 4f       	sbci	r24, 0xFF	; 255
    385a:	9f 4f       	sbci	r25, 0xFF	; 255
    385c:	af 4f       	sbci	r26, 0xFF	; 255
    385e:	b1 e0       	ldi	r27, 0x01	; 1
    3860:	3e d0       	rcall	.+124    	; 0x38de <__ultoa_invert+0x9c>
    3862:	b4 e0       	ldi	r27, 0x04	; 4
    3864:	3c d0       	rcall	.+120    	; 0x38de <__ultoa_invert+0x9c>
    3866:	67 0f       	add	r22, r23
    3868:	78 1f       	adc	r23, r24
    386a:	89 1f       	adc	r24, r25
    386c:	9a 1f       	adc	r25, r26
    386e:	a1 1d       	adc	r26, r1
    3870:	68 0f       	add	r22, r24
    3872:	79 1f       	adc	r23, r25
    3874:	8a 1f       	adc	r24, r26
    3876:	91 1d       	adc	r25, r1
    3878:	a1 1d       	adc	r26, r1
    387a:	6a 0f       	add	r22, r26
    387c:	71 1d       	adc	r23, r1
    387e:	81 1d       	adc	r24, r1
    3880:	91 1d       	adc	r25, r1
    3882:	a1 1d       	adc	r26, r1
    3884:	20 d0       	rcall	.+64     	; 0x38c6 <__ultoa_invert+0x84>
    3886:	09 f4       	brne	.+2      	; 0x388a <__ultoa_invert+0x48>
    3888:	68 94       	set
    388a:	3f 91       	pop	r19
    388c:	2a e0       	ldi	r18, 0x0A	; 10
    388e:	26 9f       	mul	r18, r22
    3890:	11 24       	eor	r1, r1
    3892:	30 19       	sub	r19, r0
    3894:	30 5d       	subi	r19, 0xD0	; 208
    3896:	31 93       	st	Z+, r19
    3898:	de f6       	brtc	.-74     	; 0x3850 <__ultoa_invert+0xe>
    389a:	cf 01       	movw	r24, r30
    389c:	08 95       	ret
    389e:	46 2f       	mov	r20, r22
    38a0:	47 70       	andi	r20, 0x07	; 7
    38a2:	40 5d       	subi	r20, 0xD0	; 208
    38a4:	41 93       	st	Z+, r20
    38a6:	b3 e0       	ldi	r27, 0x03	; 3
    38a8:	0f d0       	rcall	.+30     	; 0x38c8 <__ultoa_invert+0x86>
    38aa:	c9 f7       	brne	.-14     	; 0x389e <__ultoa_invert+0x5c>
    38ac:	f6 cf       	rjmp	.-20     	; 0x389a <__ultoa_invert+0x58>
    38ae:	46 2f       	mov	r20, r22
    38b0:	4f 70       	andi	r20, 0x0F	; 15
    38b2:	40 5d       	subi	r20, 0xD0	; 208
    38b4:	4a 33       	cpi	r20, 0x3A	; 58
    38b6:	18 f0       	brcs	.+6      	; 0x38be <__ultoa_invert+0x7c>
    38b8:	49 5d       	subi	r20, 0xD9	; 217
    38ba:	31 fd       	sbrc	r19, 1
    38bc:	40 52       	subi	r20, 0x20	; 32
    38be:	41 93       	st	Z+, r20
    38c0:	02 d0       	rcall	.+4      	; 0x38c6 <__ultoa_invert+0x84>
    38c2:	a9 f7       	brne	.-22     	; 0x38ae <__ultoa_invert+0x6c>
    38c4:	ea cf       	rjmp	.-44     	; 0x389a <__ultoa_invert+0x58>
    38c6:	b4 e0       	ldi	r27, 0x04	; 4
    38c8:	a6 95       	lsr	r26
    38ca:	97 95       	ror	r25
    38cc:	87 95       	ror	r24
    38ce:	77 95       	ror	r23
    38d0:	67 95       	ror	r22
    38d2:	ba 95       	dec	r27
    38d4:	c9 f7       	brne	.-14     	; 0x38c8 <__ultoa_invert+0x86>
    38d6:	00 97       	sbiw	r24, 0x00	; 0
    38d8:	61 05       	cpc	r22, r1
    38da:	71 05       	cpc	r23, r1
    38dc:	08 95       	ret
    38de:	9b 01       	movw	r18, r22
    38e0:	ac 01       	movw	r20, r24
    38e2:	0a 2e       	mov	r0, r26
    38e4:	06 94       	lsr	r0
    38e6:	57 95       	ror	r21
    38e8:	47 95       	ror	r20
    38ea:	37 95       	ror	r19
    38ec:	27 95       	ror	r18
    38ee:	ba 95       	dec	r27
    38f0:	c9 f7       	brne	.-14     	; 0x38e4 <__ultoa_invert+0xa2>
    38f2:	62 0f       	add	r22, r18
    38f4:	73 1f       	adc	r23, r19
    38f6:	84 1f       	adc	r24, r20
    38f8:	95 1f       	adc	r25, r21
    38fa:	a0 1d       	adc	r26, r0
    38fc:	08 95       	ret

000038fe <__prologue_saves__>:
    38fe:	2f 92       	push	r2
    3900:	3f 92       	push	r3
    3902:	4f 92       	push	r4
    3904:	5f 92       	push	r5
    3906:	6f 92       	push	r6
    3908:	7f 92       	push	r7
    390a:	8f 92       	push	r8
    390c:	9f 92       	push	r9
    390e:	af 92       	push	r10
    3910:	bf 92       	push	r11
    3912:	cf 92       	push	r12
    3914:	df 92       	push	r13
    3916:	ef 92       	push	r14
    3918:	ff 92       	push	r15
    391a:	0f 93       	push	r16
    391c:	1f 93       	push	r17
    391e:	cf 93       	push	r28
    3920:	df 93       	push	r29
    3922:	cd b7       	in	r28, 0x3d	; 61
    3924:	de b7       	in	r29, 0x3e	; 62
    3926:	ca 1b       	sub	r28, r26
    3928:	db 0b       	sbc	r29, r27
    392a:	0f b6       	in	r0, 0x3f	; 63
    392c:	f8 94       	cli
    392e:	de bf       	out	0x3e, r29	; 62
    3930:	0f be       	out	0x3f, r0	; 63
    3932:	cd bf       	out	0x3d, r28	; 61
    3934:	09 94       	ijmp

00003936 <__epilogue_restores__>:
    3936:	2a 88       	ldd	r2, Y+18	; 0x12
    3938:	39 88       	ldd	r3, Y+17	; 0x11
    393a:	48 88       	ldd	r4, Y+16	; 0x10
    393c:	5f 84       	ldd	r5, Y+15	; 0x0f
    393e:	6e 84       	ldd	r6, Y+14	; 0x0e
    3940:	7d 84       	ldd	r7, Y+13	; 0x0d
    3942:	8c 84       	ldd	r8, Y+12	; 0x0c
    3944:	9b 84       	ldd	r9, Y+11	; 0x0b
    3946:	aa 84       	ldd	r10, Y+10	; 0x0a
    3948:	b9 84       	ldd	r11, Y+9	; 0x09
    394a:	c8 84       	ldd	r12, Y+8	; 0x08
    394c:	df 80       	ldd	r13, Y+7	; 0x07
    394e:	ee 80       	ldd	r14, Y+6	; 0x06
    3950:	fd 80       	ldd	r15, Y+5	; 0x05
    3952:	0c 81       	ldd	r16, Y+4	; 0x04
    3954:	1b 81       	ldd	r17, Y+3	; 0x03
    3956:	aa 81       	ldd	r26, Y+2	; 0x02
    3958:	b9 81       	ldd	r27, Y+1	; 0x01
    395a:	ce 0f       	add	r28, r30
    395c:	d1 1d       	adc	r29, r1
    395e:	0f b6       	in	r0, 0x3f	; 63
    3960:	f8 94       	cli
    3962:	de bf       	out	0x3e, r29	; 62
    3964:	0f be       	out	0x3f, r0	; 63
    3966:	cd bf       	out	0x3d, r28	; 61
    3968:	ed 01       	movw	r28, r26
    396a:	08 95       	ret

0000396c <_exit>:
    396c:	f8 94       	cli

0000396e <__stop_program>:
    396e:	ff cf       	rjmp	.-2      	; 0x396e <__stop_program>
